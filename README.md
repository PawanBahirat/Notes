# DSA (Data structures & Algorithms)

- [Data Structures](#data-structures)
  - [Arrays](#arrays)
    - [Arrays](#arrays)
    - [2D Array](#2d-array)
    - [Remove Even Integers From An Array](#remove-even-integers-from-an-array)
    - [Merge Two Sorted Arrays](#merge-two-sorted-arrays)
    - [Find Two Numbers That Add Up To N](#find-two-numbers-that-add-up-to-n)
    - [Find Minimum Value in Array](#find-minimum-value-in-array)
    - [First Non-Repeating Integer In An Array](#first-non-repeating-integer-in-an-array)
    - [Find Second Maximum Value In An Array](#find-second-maximum-value-in-an-array)
    - [Find The Sum Of Maximum Sum Subarray](#find-the-sum-of-maximum-sum-subarray)
    - [Binary Search](#binary-search-on-sorted-array)
    - [Find Maximum In Sliding Window](#find-maximum-in-sliding-window)
    - [Move All Zeroes to the Beginning of the Array](#move-all-zeroes-to-the-beginning-of-the-array)
    - [Stock Buy Sell to Maximize Profit](#stock-buy-sell-to-maximize-profit)
    - [Sort an Array Using Quicksort Algorithm](#sort-an-array-using-quicksort-algorithm)
    - [Maximum Sum Subarray Of Size K](#maximum-sum-subarray-of-size-k)
  - [Strings](#strings)
    - [Strings](#strings)
    - [Reverse Words in a Sentence](#reverse-words-in-a-sentence)
    - [Remove Duplicates from a String](#remove-duplicates-from-a-string)
    - [Remove White Spaces from a String](#remove-white-spaces-from-a-string)
    - [Word Break Problem](#word-break-problem)
    - [Find all Palindrome Substrings](#find-all-palindrome-substrings)
    - [Balanced Parentheses](#balanced-parentheses)
    - [Longest Substring with Distinct Characters](#longest-substring-with-distinct-characters)
  - [Linked List](#linked-list)
    - [Introduction To Linked Lists](#introduction-to-linked-lists)
    - [Insertion In a Singly Linked List (insert at End)](#insertion-in-a-singly-linked-list-insert-at-end)
    - [Search In Singly Linked List](#search-in-singly-linked-list)
    - [Deletion In Singly Linked List (delete By Value)](#deletion-in-singly-linked-list-delete-by-value)
    - [Linked Lists Vs Arrays](#linked-lists-vs-Arrays)
    - [Find The Length Of A Linked List](#find-the-length-of-a-linked-list)
    - [Reverse A Linked List](#reverse-a-linked-list)
    - [Detect Loop In A Linked List](#detect-loop-in-a-linked-list)
    - [Find The Middle Node Of A Linked List](#find-the-middle-node-of-a-linked-list)
    - [Remove Duplicates From A Linked List](#remove-duplicates-from-a-linked-list)
    - [Return The Nth Node From End](#return-the-nth-node-from-end)
    - [Implementation Of Linked List](#implementation-of-linked-list)
    - [Intersection Point Of Two Lists](#intersection-point-of-two-lists)
    - [Reverse Alternate K Nodes In A Singly Linked List](#reverse-alternate-k-nodes-in-a-singly-linked-list)
    - [Merge K Sorted Lists](#merge-k-sorted-lists)
  - [Stack and Queues](#stack-and-queues)
    - [Introduction To Stacks and Queues](#introduction-to-stacks-and-queues)
    - [Implementation Of Stack](#implementation-of-stack)
    - [Implementation Of Queue](#implementation-of-queue)
    - [Implement Queue Using Stacks](#implement-queue-using-stacks)
    - [Implement Stack Using Queue](#implement-stack-using-queue)
    - [Reversing The First K Elements Of A Queue](#reversing-the-first-k-elements-of-a-queue)
    - [Evaluate Postfix Expressions Using Stacks](#evaluate-postfix-expressions-using-stacks)
    - [Next Greater Element Using Stackproblem Statement](#next-greater-element-using-stack)
    - [Solve A Celebrity Problem Using A Stack](#solve-a-celebrity-problem-using-a-stack)
    - [Check For Balanced Parentheses Using A Stack](#check-for-balanced-parentheses-using-a-stack)
    - [Create Stack Where Min() Gives Minimum In Constant Time O(1)](#create-stack-where-min-gives-minimum-in-constant-time-o1)
  - [Trees](#trees)
    - [Introduction To Trees](#introduction-to-trees)
    - [Check If Two Binary Trees Are Identical](#check-if-two-binary-trees-are-identical)
    - [In-Order Iterator For A Binary Tree](#in-order-iterator-for-a-binary-tree)
    - [Iterative In-Order Traversal Of Binary Tree](#iterative-in-order-traversal-of-binary-tree)
    - [In-Order Successor Of Binary Search Tree](#in-order-successor-of-binary-search-tree)
    - [In-Order Successor Binary Search Tree With Parent Pointers](#in-order-successor-binary-search-tree-with-parent-pointers)
    - [Level Order Traversal Of Binary Tree](#level-order-traversal-of-binary-tree)
    - [Valid Binary Search Tree](#valid-binary-search-tree)
    - [Serialize/Deserialize Binary Tree](#serializedeserialize-binary-tree)
    - [Minimum Depth Of A Binary Tree](#minimum-depth-of-a-binary-tree)
    - [All Paths For A Sum](#all-paths-for-a-sum)
    - [Count Paths For A Sum](#count-paths-for-a-sum)
  - [Trie](#trie)
    - [Introduction To Tries](#introduction-to-tries)
    - [Total Number Of Words In A Trie](#total-number-of-words-in-a-trie)
    - [Find All Of The Words In A Trie](#find-all-of-the-words-in-a-trie)
    - [Sort The Elements Of An Array Using A Trie](#sort-the-elements-of-an-array-using-a-trie)
    - [Word Formation From A Given Dictionary Using A Trie](#word-formation-from-a-given-dictionary-using-a-trie)
  - [Recursion](#recursion)
    - [Find The Greatest Common Divisor](#find-the-greatest-common-divisor)
    - [Check For Prime Number](#check-for-prime-number)
    - [How Does The Decimal To Binary Conversion Work ?](#how-does-the-decimal-to-binary-conversion-work)
    - [Is This String A Palindrome ?](#is-this-string-a-palindrome)
    - [Insert Values In A Binary Search Tree](#insert-values-in-a-binary-search-tree)
  - [DP](#dp)
    - [0/1 Knapsack](#01-knapsack)
    - [Equal Subset Sum Partition](#equal-subset-sum-partition)
    - [Target Sum](#target-sum)
    - [Unbounded Knapsack](#unbounded-knapsack)
    - [Rod Cutting](#rod-cutting)
    - [Coin Change](#coin-change)
    - [Minimum Coin Change](#minimum-coin-change)
    - [Fibonacci Numbers](#fibonacci-numbers)
    - [Staircase](#staircase)
    - [Minimum Jumps To Reach The End](#minimum-jumps-to-reach-the-end)
    - [House Thief](#house-thief)
    - [Longest Palindromic Subsequence](#longest-palindromic-subsequence)
    - [Longest Palindromic Substring](#longest-palindromic-substring)
    - [Count Of Palindromic Substrings](#count-of-palindromic-substrings)
    - [Minimum Deletions In A String To Make It A Palindrome](#minimum-deletions-in-a-string-to-make-it-a-palindrome)
    - [Palindromic Partitioning](#palindromic-partitioning)
    - [Longest Common Substring](#longest-common-substring)
    - [Longest Common Subsequence](#longest-common-subsequence)
    - [Minimum Deletions & Insertions To Transform A String Into Another](#minimum-deletions--insertions-to-transform-a-string-into-another)
    - [Longest Increasing Subsequence](#longest-increasing-subsequence)
    - [Maximum Sum Increasing Subsequence](#maximum-sum-increasing-subsequence)
    - [Subsequence Pattern Matching](#subsequence-pattern-matching)
    - [Longest Bitonic Subsequence](#longest-bitonic-subsequence)
    - [Edit Distance](#edit-distance)
    - [Egg Dropping Problem](#egg-dropping-problem)
## Data Structures

### Arrays
<hr>

- Introduction :

An array also referred to as a collection of elements, is the simplest and most widely used Data Structure. Most of the Data Structures (e.g.Stack and Queue) were derived using the Array structure, which is why it is known as one of the central building blocks of Data Structures. These Data Structures will be discussed later in the coming chapters. The purpose of an Array is to group similar kinds of data for fast access.

Look at the figure below; we have made a simple array with four elements. Each item in the collection is called a Data Element, and the number of data elements stored in an Array is known as its size. You can see that each data element has a maximum of two neighbors, except the first and last one.

- Array Indexing : 

Each data element is assigned a numerical value called the index, which corresponds to the position of that item in the array. It is important to note that the value of the index is non-negative and always starts from zero. So the first element of an array will be stored at index 0 and the last one at index size-1.

An index makes it possible to access the contents of the array directly. Otherwise, we would have to traverse through the whole array to access a single element. That is the key feature that differentiates Arrays from Linked lists (we will cover them in the next chapter).

- Types Of Arrays :

Arrays can store primitive data-type values (e.g., int, char, floats, boolean, byte, short, long, etc.), non-primitive data-type values (e.g., Java Objects, etc.) or it can even hold references of other arrays. That divides the arrays into two categories:

One Dimensional Array
Multi-Dimensional Array
In primitive array, values are stored in a contiguous memory location. Whereas, in the non-primitive array, objects are stored in the heap segment.

- One-Dimensional Array :

The basic syntax for declaring and initializing the one-dimensional array is given below:

- Array Declaration :

In the array declaration, reference of an array is created. To declare an array, you have to specify the data type and name of the array.
```java
datatype arrayName[]; or datatype[] arrayName;
```
- Example Program :
- Code :tada:
```java
class OneDArray{ 
    public static void main(String  args[]){
        //Declaration Syntax
        int myArray1[];
        int[] myArray2;
    }
}
```
The above declarations will tell the compiler that reference variables myArray1and myArray2 will hold an array of type int. For now, no actual array exists. To link these reference variables with the actual physical array, we have to create one using the new operator.

- Array Initialization : 

Array initialization actually gives memory to the elements of an array. The basic syntax for initializing an array is given below:
```java
arrayName = new type [size];
```
- Initialization and Declaration in One Step :

We can also declare and initialize the array in one step.
```java
datatype[] arrayName = new datatype [size]; or datatype arrayName[] = new datatype [size];
```
- Practice Problem üëç

[Sum of Array Elements.](https://practice.geeksforgeeks.org/problems/sum-of-array-elements2502/1)

- Adding or Updating Elements in an Array :

To add or update the element in an array, we specify the particular index and assign the new value.
```java
arrayName[index] = value;
```

- How are arrays stored in memory? 

In Java, arrays are dynamically allocated. Arrays are stored in the memory using a reference pointer, which points to the first element. For example, if we create an array of size 3 and name it myArray, then the variable will point to the start of the array. See the figure below:

The only drawback of using arrays is that we have to specify the size of the array during the time of instantiation. That means the size remains fixed and can not be extended. If we want to add more elements, we will have to create a new array, copy all the items from the old array to the new one, and then insert the new element.

### 2D Array
<hr>

- Introduction : 

The Java 2D arrays are arranged as arrays of arrays, i.e., each element of a 2D array is another array. These are generally used if we want to store the data items in a table or matrix-like structure. The representation of the elements is in rows and columns. Thus, we can get a total number of elements in a multidimensional array by multiplying row size with column size.

Like 1D arrays, 2D arrays must have values of the same data type.

- Declaration :
Syntax -
```java
data_type [] [] array_name = new data_type[row_size][column_size];
```
```java
int [][] arr = new int[3][4];
```

This line will create a pointer to store a 2D array. The size of this 2D array is 3 by 4, which means arr holds three 1D arrays, having 4 elements in each.

- Representation of above 2D array in tabular format :
  
| Column 0  | Column 1  | Column 2   | Column 3  |
| :-------  | :-------  | :-------   | :-------  |
| `a[0][0]` | `a[0][1]` | `a[0][2]`  | `a[0][3]` |
| `a[1][0]` | `a[1][1]` | `a[1][2]`  | `a[1][3]` |
| `a[2][0]` | `a[2][1]` | `a[2][2]`  | `a[2][3]` |

- Initialization :
  
There are various ways to initialize a 2D array with values.

The traditional method is to assign values to each element. 
```java
int [][] arr =new int [3][4]; //assigning 10 at Row 2 and Column 1 arr[2][1]=10;
```
We can also initialize it with the declaration itself. 
```java
int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, {9, 10, 11, 12} };
```
We can also initialize or assign the values using a loop. 
```java
for (int i = 0; i < 3; i++) { for (int j = 0; j < 4; j++) { arr[i][j]=i+j; } }
```

- Printing 2D array in tabular format :
- Code :tada:
```java
public class Main {
public static void main(String args[]) {
      int[][] arr = {  { 1, 2, 3, 4 }, 
                   { 5, 6, 7, 8 }, 
                   {9, 10, 11, 12} };
                   
     for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
 	    	 System.out.print(arr[i][j]+" ");
        }  
        System.out.println();
     }
}
}
```

- Practice Problems üëç

[Sum of Elements in a matrix.](https://practice.geeksforgeeks.org/problems/sum-of-elements-in-a-matrix2000/1)

[Diagonal Sum.](https://practice.geeksforgeeks.org/problems/diagonal-sum0158/1)

[Multiply Matrices.](https://practice.geeksforgeeks.org/problems/multiply-matrices/1)

[Transpose of Matrix.](https://practice.geeksforgeeks.org/problems/transpose-of-matrix-1587115621/1)

[Rotate by 90 degree.](https://practice.geeksforgeeks.org/problems/rotate-by-90-degree-1587115621/1)


### Remove Even Integers From An Array
<hr>

Given an array of size n, remove all even integers from it. Implement this solution in Java and see if it runs without an error.

In this problem, you have to implement the `int [] removeEven(int[] arr)` method, which removes all the even elements from the array and returns back updated array.

- Method Prototype :
```java
int[] removeEven(int[] arr);
```
- Input :
An array with integers.

- Output :
An array with only odd integers.

- Sample Input :
```java
arr = {1, 2, 4, 5, 10, 6, 3}
```
- Sample Output :
```java
arr = {1, 5, 3}
```
**SOLUTION**
- Code :tada:
```java
class CheckRemoveEven {
  
	public static int[] removeEven(int[] arr) {
		int oddElements = 0;

		//Find number of odd elements in arr
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] % 2 != 0) oddElements++;
		}

		//Create result array with the size equal to the number of odd elements in arr
		int[] result = new int[oddElements];
		int result_index = 0;

		//Put odd values from arr to the resulted array
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] % 2 != 0) 
        result[result_index++] = arr[i];
		} //end of for loop

		return result;
	} //end of removeEven


  public static void main(String args[]) {
  
    int size = 10;
    int[] arr = new int[size]; //declaration and instantiation 
  
    System.out.print("Before removing Even Numbers: "); 
    for (int i = 0; i < arr.length; i++) {
      arr[i] = i; // assigning values
      System.out.print(arr[i] +  " ");
    }
    System.out.println();
  
    int[] newArr =  removeEven(arr); // calling removeEven
  
    System.out.print("After removing Even Numbers: "); 
    for (int i = 0; i < newArr.length; i++) {
      System.out.print(newArr[i] +  " "); // prinitng array
    }
  }
}
```
- Explanation :

This solution first finds the number of odd elements in the given array by iterating over it and incrementing a count variable if an element is odd.

Next, we initialize an array with a size oddElements, and store all the odd numbers in it.

- Time Complexity :

Since the entire array has to be iterated over, this solution is in O(n).

### Merge Two Sorted Arrays
<hr>

- Problem Statement :
In this problem, given two sorted arrays, you have to implement the `int[] mergeArrays(int[] arr1, int[] arr2)` method, which returns an array consisting of all elements of both arrays in a sorted way.

- Method Prototype :
```java
int[] mergeArrays(int[] arr1, int[] arr2)
```
Here arr1 and arr2 are sorted already.

- Sample Input :
```java
arr1 = {1, 3, 4, 5}
arr2 = {2, 6, 7, 8}
```
- Sample Output :
```java
arr = {1, 2, 3, 4, 5, 6, 7, 8}
````
**SOLUTION**
- Code :tada:
```java
class checkMergeArray { 

  // Merge arr1 and arr2 into resultantArray
  public static int[] mergeArrays(int[] arr1, int[] arr2) { 
    int s1 = arr1.length;
    int s2 = arr2.length;
    int[] resultantArray = new int[s1+s2];
    int i = 0, j = 0, k = 0;

    // Traverse both array 
    while (i < s1 && j < s2) { 
      // Check if current element of first 
      // array is smaller than current element 
      // of second array. If yes, store first 
      // array element and increment first array 
      // index. Otherwise do same with second array 
      if (arr1[i] < arr2[j]) 
        resultantArray[k++] = arr1[i++]; 
      else
        resultantArray[k++] = arr2[j++]; 
    } 

    // Store remaining elements of first array 
    while (i < s1) 
      resultantArray[k++] = arr1[i++]; 

    // Store remaining elements of second array 
    while (j < s2) 
      resultantArray[k++] = arr2[j++]; 

    return resultantArray;
  } 

  public static void main(String args[]) {

    int[] arr1 = {1,12,14,17,23}; // creating a sorted array called arr1
    int[] arr2 = {11,19,27};  // creating a sorted array called arr2

    int[] resultantArray = mergeArrays(arr1, arr2); // calling mergeArrays

    System.out.print("Arrays after merging: ");
    for(int i = 0; i < arr1.length + arr2.length; i++) {
      System.out.print(resultantArray[i] + " ");
    }
  }
}
```
- Explanation : 

In the solution above, we start by creating a new empty array of the size equal to the sum of sizes of input arrays. Starting off from the index 0 individually compare the elements at corresponding indexes of both arrays. Place the element with smaller value in the resultant array, and increment the index of the array where you find the smallest element. Keep repeating this till you hit the end of one array. Move the elements of the other array into the resultantArray as it is.

Now you‚Äôve got the sorted resultantArray!

- Time Complexity :

The time complexity for this algorithm is O(n+m), where nn and mm are the sizes of arr1 and arr2, respectively. This is because both arrays are iterated over once.

### Find Two Numbers That Add Up To N
<hr>

- Problem statement :

Implement a function that takes an array `arr`, a number `value`, and the `size` of the array as an input and returns two numbers which add up to `value`.

- Input :

The input is an array, a value, and the size of the array

- Output :

An array with two integers that add up to the value given

- Sample input :
```java
arr = {1,21,3,14,5,60,7,6}; value = 81;
```
- Sample output :
```java
arr = {21,60};
```
For example, in this illustration we are given 81 as the number value. When we traverse the whole array, we find that 21 and 60 are the integers that add up to 81.

**Soluion: Using quicksort**
- Code :tada:
```java
Helper.java

import java.util.Random;

class Helper {
 static void swap(int[] array, int i, int j) {
  int temp = array[i];
  array[i] = array[j];
  array[j] = temp;
 }
 public static int choosePivot(int left, int right) {
  Random rand = new Random();
  // Pick 3 random numbers within the range of the array
  int i1 = left + (rand.nextInt(right - left + 1));
  int i2 = left + (rand.nextInt(right - left + 1));
  int i3 = left + (rand.nextInt(right - left + 1));

  // Return their median
  return Math.max(Math.min(i1, i2), Math.min(Math.max(i1, i2), i3));
 }

 public static int partition(int arr[], int left, int right) {
  int pivotInd = choosePivot(left, right); // Index of pivot
  swap(arr, right, pivotInd); // self created function to swap two indices of an array
  int pivot = arr[right]; // Pivot 
  int i = (left - 1); // All the elements less than or equal to the
  // pivot go before or at i

  for (int j = left; j <= right - 1; j++) {
   if (arr[j] <= pivot) {
    i++; // increment the index 
    swap(arr, i, j);
   }
  }
  swap(arr, i + 1, right); // Putting the pivot back in place
  return (i + 1);
 }

 public static void quickSort(int arr[], int left, int right) {
  if (left < right) {
   // pi is where the pivot is at
   int pi = partition(arr, left, right);

   // Separately sort elements before and after partition 
   quickSort(arr, left, pi - 1);
   quickSort(arr, pi + 1, right);
  }
 }
}
main.java

class CheckSum {
 static Helper obj = new Helper();

 public static int[] findSum(int[] arr, int n) //Returns 2 elements of arr that sum to the given value
 {
  //Helper sort function that uses the Quicksort Algorithm
  obj.quickSort(arr, 0, arr.length - 1); //Sort the array in Ascending Order

  int Pointer1 = 0; //Pointer 1 -> At Start
  int Pointer2 = arr.length - 1; //Pointer 2 -> At End

  int[] result = new int[2];
  int sum = 0;

  while (Pointer1 != Pointer2) {

   sum = arr[Pointer1] + arr[Pointer2]; //Calulate Sum of Pointer 1 and 2

   if (sum < n)
    Pointer1++; //if sum is less than given value => Move Pointer 1 to Right
   else if (sum > n)
    Pointer2--;
   else {
    result[0] = arr[Pointer1];
    result[1] = arr[Pointer2];
    return result; // containing 2 number 
   }
  }
  return arr;
 }

 public static void main(String args[]) {

  int n = 9;
  int[] arr1 = {2, 4, 5, 7, 8};
  int[] arr2 = findSum(arr1, n);
  int num1 = arr2[0];
  int num2 = arr2[1];

  if ((num1 + num2) != n)
   System.out.println("Results not found!");
  else
   System.out.println("Sum of " + n + " found: " + num1 + " and " + num2);
 }
}
```
While solution #1 is very intuitive, it is not very time efficient. A better way to solve this challenge is by first sorting the array, then using two variables: one starting from the first index of the array and the second starting from the last index of the array, (size-1size‚àí1).

If the sum of the elements at these indices of the array is smaller than the given value, then we increment Pointer1. If the sum is smaller, then we decrement Pointer2 from the end. If none of those conditions are true, this means that the sum is equal to the given value. That being said, we will append the elements at those indices in the array and return the result.

- Time complexity :
Since the sorting function we use in this Code takes O(nlog(n)) and the algorithm itself takes O(n) time, the overall time complexity of this algorithm is in O(nlog(n)).

**Solution: Use hashing**
- Code :tada:
```java
class CheckSum {
 public static int[] findSum(int[] arr, int n) {
  int[] result = new int[2];
  HashMap < Integer, Boolean > hmap = new HashMap < Integer, Boolean > (); // Create a hashmap

  for (int i = 0; i < arr.length; i++) {
   if (hmap.containsKey(arr[i])) // If a value from arr is present in hmap
   {
    result[0] = arr[i];
    result[1] = n - arr[i];
    return result;
   }
   else
   hmap.put(n - arr[i], true); // Store value - arr[i] if element is not present in arr
  }
  return result;
 }

 public static void main(String args[]) {

  int n = 9;
  int[] arr1 = {2, 4, 5, 7, 8};
   int[] arr2 = findSum(arr1, n);
  int num1 = arr2[0];
  int num2 = arr2[1];

  if ((num1 + num2) != n)
   System.out.println("Results not found!");
  else
   System.out.println("Sum of " + n + " found: " + num1 + " and " + num2);
 }
}
```

- Explanation :

We solve this problem by using a HashMap called `hmap`.

We will run a `for` loop on the whole array. If the element `arr[i]` doesn‚Äôt exist in the hmap, we add `n - arr[i]` to the `hmap` as shown in the line 14.

If any element of `arr` exists in the `hmap`, that means the difference of `n` and the number found `(n - arr[i])` are also present.

Therefore, an array of size 2 called `result` is created to store the pair that sums up to `n`. If `hmap` contains any array element, `result[]` is updated, or else it is returned containing the default value.

- Time complexity :

This Code works in O(n), as the whole array is iterated over once.

### Find Minimum Value in Array
<hr>

- Problem Statement :

In this problem, you have to implement the `int findMinimum(int[] arr)` method, which will traverse the whole array and find the smallest number in the array.

- Method Prototype :

`int findMinimum(int[] arr)` Here arr1 and arr2 are sorted already.

- Sample Input :
```java
arr = {9, 2, 3, 6}
```
- Sample Output :
```java
2
```
**SOLUTION**
- Code :tada:
```java
public static int findMinimum(int[] arr) {

    int minimum = arr[0];

    //At every Index compare its value with minimum and if its less 
    //then make that index value new minimum value
    for (int i = 1; i < arr.length; i++) {

      if (arr[i] < minimum) {
        minimum = arr[i];
      }
    }
    return minimum;
  }
```
- Explanation :

Start with the first element, which is 9 in this example, and save it in minimum as the smallest value. Then, iterate over the rest of the array and compare the minimum to each element. If any element is smaller than the minimum, then set the minimum to that element. By the end of the array, the number stored in the minimum will be the smallest integer in the whole array.

- Time Complexity :

Since the entire list is iterated over once, this algorithm is in linear time, O(n).

### First Non Repeating Integer In An Array
<hr>

- Problem Statement :

In this problem, you have to implement the `int findFirstUnique(int[] arr)` function that will look for a first unique integer which appears only once in the whole array. You must use hashing to implement this function in the most optimized way possible.
```
Note: We consider zero to be an integer for the premise of this challenge.
```
- Function Prototype :
```java
int findFirstUnique(int[] arr)
```
- Output :

The first unique element in the array.

- Sample Input :
```java
arr = {9, 2, 3, 2, 6, 6}
```
- Sample Output :
```java
9
```
**Solution: Using a HashMap**
- Code :tada:
```java
class CheckFirstUnique {
    public static int findFirstUnique(int[] arr) {

        Map<Integer, Integer> countElements = new HashMap<>();
        //If the element does not exist in the HashMap
        //Add that element with value = 0
        //or else update the number of occurrences of that element by adding 1
        for (int i = 0; i < arr.length; i++) {
            if(countElements.containsKey(arr[i])){
                int occurence = countElements.get(arr[i]) + 1;
                countElements.put(arr[i], occurence);
            }
            else
                countElements.put(arr[i], 0); 
        }
        //Traverse the array and check the number of occurrences
        //Return the first element with 0 occurences
        for (int i = 0; i < arr.length; i++) {
            if (countElements.get(arr[i]) == 0) {
                return arr[i];
            }
        }
        //If no such element is found, return -1
        return -1;
    }

    public static void main(String args[]) {

        int[] arr = {2, 54, 7, 2, 6, 54};

        System.out.println("Array: " + Arrays.toString(arr));

        int unique = findFirstUnique(arr);
        System.out.print("First Unique in an Array: " + unique);

    }
}
```
- Explanation :

Firstly, we store all the elements from the array into a `HashMap`. The element is stored as `key` and the count of multiple occurrences is stored as `value` in the `HashMap`. Initially, the count is 0. But if the same element is encountered again, the count is increased by `1` each time.

Afterward, we traverse the array again from the beginning and return the first element which has count equal to `0` in the `HashMap`.

- Time Complexity :

The array is iterated multiple times but the complexity is still linear. The time complexity of this Code is O(n).

**Solution: Using a TreeMap**
- Code :tada:
  
```java
class CheckFirstUnique {
    public static int findFirstUnique(int[] arr) {

        Map<Integer, Integer> countElements = new TreeMap<>(); //TreeMap is sorted
        //If the element does not exist in the TreeMap
        //Add that element with value = 0
        //or else update the number of occurrences of that element by adding 1
        for (int i = 0; i < arr.length; i++) {
            if(countElements.containsKey(arr[i])){
                int occurence = countElements.get(arr[i]) + 1;
                countElements.put(arr[i], occurence);
            }
            else
                countElements.put(arr[i], 0); 
        }
        //Traverse the array and check the number of occurrences
        //Return the first element with 0 occurences
        for (int i = 0; i < arr.length; i++) {
            if (countElements.get(arr[i]) == 0) {
                return arr[i];
            }
        }
        //If no such element is found, return -1
        return -1;
    }

    public static void main(String args[]) {

        int[] arr = {2, 54, 7, 2, 6, 54};

        System.out.println("Array: " + Arrays.toString(arr));

        int unique = findFirstUnique(arr);
        System.out.print("First Unique in an Array: " + unique);

    }
}
```
- Time Complexity :

The time complexity of this program is O(n).

### Find Second Maximum Value In An Array
<hr>

- Problem Statement :

In this problem, you have to implement the `int findSecondMaximum(int[] arr)` method, which will traverse the whole array and return the second largest element present in the array.

- Assumption :
 
Array should contain at least two unique elements.

- Method Prototyp :
```java
int findSecondMaximum(int[] arr)
```
- Sample Input :
```java
arr = {9,2,3,6}
```
- Sample Output :
```java
6
```
**SOLUTION**
- Code :tada:
```java
public static int findSecondMaximum(int[] arr) {

    int max = Integer.MIN_VALUE;;
    int secondmax = Integer.MIN_VALUE;

    // Keep track of Maximum value, whenever the value at an array index is greater
    // than current Maximum value then make that max value 2nd max value and
    // make that index value maximum value  
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        secondmax = max;
        max = arr[i];
      }
      else if (arr[i] > secondmax && arr[i] != max) {
        secondmax = arr[i];
      }
    }//end of for-loop

    return secondmax;
  }
  ```
- Explanation :

We initialize two variables `max` and `secondmax` to Integer. MIN_VALUE having value `-2147483648`, which is the maximum integer negative value range. We then traverse the array, and if the current element in the array is greater than the maximum value, then set `secondmax` to `max` and `max` to the current element. If the current element is greater than the `secondmax` but less than max, then update `secondmax` to store the value of the current element. Finally, return the value stored in `secondmax`.

- Time Complexity :

This solution is in O(n) since the list is traversed once only.

### Find The Sum Of Maximum Sum Subarray
<hr>

- Problem Statement :

Given an integer array, return the maximum subarray sum. The array may contain both positive and negative integers and is unsorted.

- Method Prototype :
```java
int findMaxSumSubArray(int[] arr)
```
- Sample Input :
```java
arr = {1, 7, -2, -5, 10, -1}
```
- Sample Output :
```java
11
```

**Kadane's Algorithm**
- Code :tada:
```java
public static int findMaxSumSubArray(int[] arr) {
        if (arr.length < 1) {
            return 0;
        }

        int currMax = arr[0];
        int globalMax = arr[0];
        int lengtharray = arr.length;
        for (int i = 1; i < lengtharray; i++) {
            if (currMax < 0) {
            currMax = arr[i];
            } else {
            currMax += arr[i];
            }

            if (globalMax < currMax) {
            globalMax = currMax;
            }
        }
        return globalMax;
    }
```
- Explanation :

The basic idea of Kadane‚Äôs algorithm is to scan the entire array and at each position find the maximum sum of the subarray ending there. This is achieved by keeping a currMax for the current array index and a globalMax. The algorithm is as follows:
```java
 currMax = A[0]
globalMax = A[0]
for i = 1 -> size of A
    if currMax is less than 0
        then currMax = A[i]
    otherwise 
        currMax = currMax + A[i]
    if globalMax is less than currMax 
        then globalMax = currMax
```

- Time Complexity :

The runtime complexity of this solution is linear, O(n).

### Binary Search on Sorted Array
<hr>

- Description :

Given a sorted array of integers, return the index of the given key. Return `-1` if the key is not found.

- Example : 

Given the following array, if the search key is `47`, binary search will return `3`.

![image](https://github.com/PawanBahirat/Notes/assets/99033177/e83ca0c0-1e65-4536-88b7-da46e32c0543)

- Explanation :

Binary search is used to find the index of an element in a sorted array. If the element doesn‚Äôt exist, that can be determined efficiently as well. The algorithm divides the input array by half at every step. After every step, either we have found the index that we are looking for or half of the array can be discarded. Hence, the solution can be calculated in O(log n) time.

Here‚Äôs how the algorithm works:

At every step, consider the array between `low` and `high` indices
Calculate the `mid` index.
If the element at the `mid` index is the `key`, return `mid`.
If the element at `mid` is greater than the `key`, then change the index `high` to `mid - 1`. The index at `low` remains the same.
If the element at `mid` is less than the `key`, then change `low` to `mid + 1`. The index at high remains the same.
When `low` is greater than `high`, the `key` doesn‚Äôt exist and -1 is returned.

- Code :tada:
```java
static int binSearch(int[] A, int key) {
  
    int low = 0;
    int high = A.length -1;

    while (low <= high) {

      int mid = low + ((high - low) / 2);

      if (A[mid] == key) {
        return mid;
      }

      if (key < A[mid]) {
        high = mid - 1;
      }
      else {
        low = mid + 1;
      }
    }
    return -1;
  }
```

### Find Maximum In Sliding Window
<hr>

- Description :

Given a large array of integers and a window of size ww, find the current maximum value in the window as the window slides through the entire array.

Let‚Äôs try to find all maximums for a window size equal to 33 in the array given below :

`-4`	`2`	`-5`	`3`	`6`

- Step1 : For the first 3 elements in the window, max is 2.

`-4`	`2`	`-5`

- Step2 : Slide window one position to the right and max for window becomes 3.

`2`	`-5`	`3`

- Step3 : In the last window, max is 6.

`-5`	`3`	`6`

- Solution Approach :

The algorithm uses the deque data structure to find the maximum in a window. A deque is a double-ended queue in which push and pop operations work in O(1) at both ends. It will act as our window. At the start of the algorithm, we search for the maximum value in the first window. The first element‚Äôs index is pushed to the front of the deque. If an element is smaller than the one at the back of the queue, then the index of this element is pushed in and becomes the new back. If the current element is larger, the back of the queue is popped repeatedly until we can find a higher value, and then we‚Äôll push the index of the current element in as the new back. As we can see, the deque stores elements in decreasing order. The front of the deque contains the index for the maximum value in that particular window. We will repeat the following steps each time our window moves to the right:

Remove the indices of all elements from the back of the deque, which are smaller than or equal to the current element.
If the element no longer falls in the current window, remove the index of the element from the front.
Push the current element index at the back of the window.
The index of the current maximum element is at the front.

- Code :tada:
```java
 public static ArrayDeque<Integer> findMaxSlidingWindow(int[] arr, int windowSize) {

    ArrayDeque<Integer> result = new ArrayDeque<>(); // ArrayDeque for storing values
    Deque<Integer> list = new LinkedList<Integer>(); // creating a linked list

    if(arr.length > 0) {

      if( arr.length < windowSize) // Invalid State
        return result;

      for(int i = 0; i < windowSize; ++i) {
        // Removing last smallest element index
        while(!list.isEmpty() && arr[i] >= arr[list.peekLast()]){
          list.removeLast();      
        }
         
        // Adding newly picked element index
        list.addLast(i);
      }

      for(int i = windowSize; i < arr.length; ++i) {
        result.add(arr[list.peek()]);

        // Removing all the elements indexes which are not in the current window
        while((!list.isEmpty()) && list.peek() <= i-windowSize)
          list.removeFirst();

        // Removing the smaller elements indexes which are not required
        while((!list.isEmpty()) && arr[i] >= arr[list.peekLast()])
          list.removeLast();

        // Adding newly picked element index
        list.addLast(i);
      }

      // Adding the max number of the current window in the result
      result.add(arr[list.peek()]);
      return result; // returning result
    }
    else 
      return result;
  }
```

### Move All Zeroes to the Beginning of the Array
<hr>

- Description :

Given an integer array, move all elements that are 0 to the left while maintaining the order of other elements in the array. The array has to be modified in-place. Let‚Äôs look at the following integer array:

`1`	`10`	`20`	`0`	`59`	`63`	`0`	`88`	`0`

After moving all zeros to the left, the array should look like this:

`0`	`0`	`0`	`1`	`10`	`20`	`59`	`63`	`88`

Remember : We need to maintain the order of non-zero elements.

- Solution Approach :

We will keep two markers: `read_index` and `write_index` and point them to the end of the array. Let‚Äôs take a look at an overview of the algorithm: While moving `read_index` towards the start of the array:

If `read_index` points to `0`, skip.
If `read_index` points to a non-zero value, write the value at `read_index` to `write_index` and decrement `write_index`.
Assign zeros to all the values before the `write_index` and to the current position of `write_index` as well.

- Code :tada:
```java
static void moveZerosToLeft(int[] A) {
    if (A.length < 1) {
      return;
    }

    int writeIndex = A.length - 1;
    int readIndex = A.length - 1;

    while(readIndex >= 0) {
      if(A[readIndex] != 0) {
        A[writeIndex] = A[readIndex];
        writeIndex--;
      }

      readIndex--;
    }

    while(writeIndex >= 0) {
      A[writeIndex] = 0;
      writeIndex--;
    }
  }
```
- Runtime complexity :

The runtime complexity if this solution is linear, O(n).

- Memory complexity :

The memory complexity of this solution is constant, O(1).

### Stock Buy Sell to Maximize Profit
<hr>

- Description :
  
Given a list of daily stock prices (integers for simplicity), return the buy and sell prices for making the maximum profit.

We need to maximize the single buy/sell profit. If we can‚Äôt make any profit, we‚Äôll try to minimize the loss. For the below examples, buy and sell prices for making a maximum profit are highlighted.

`8`	`5`	`12`	`9`	`19`	`1`

- Solution Approach :

The values in the array represent the cost of a stock each day. As we can `buy` and `sell` the stock only once, we need to find the best `buy and sell` prices for which our profit is maximized (or loss is minimized) over a given span of time.

A naive solution, with runtime complexity of O(n^2), is to find the maximum gain between each element and its succeeding elements. There is a tricky linear solution to this problem that requires maintaining `current_buy_price` (which is the smallest number seen so far), `current_profit`, and `global_profit` as we iterate through the entire array of stock prices. At each iteration, we will compare the `current_profit` with the `global_profit` and update the `global_profit` accordingly. The basic algorithm is as follows:

```
current profit = INT_MIN
current buy = stock_prices[0]
global sell = stock_prices[1]
global profit = global sell - current buy

for i = 1 to stock_prices.length:
  current profit = stock_prices[i] - current buy
  if current profit is greater than global profit 
    then update global profit to current profit and update global sell to stock_prices[i]
  if stock_prices[i] is less than current buy 
    then update current buy to stock_prices[i]

return global profit and global sell
```

- Code :tada:
```java
class Tuple<X, Y> {             
  public X x; 
  public Y y; 

  public Tuple(X x, Y y) { 
    this.x = x; 
    this.y = y; 
  } 
}

public static Tuple findBuySellStockPrices(int[] array) {
    if(array == null || array.length < 2) {
        return null;
      }

    int current_buy = array[0];
    int global_sell = array[1];
    int global_profit = global_sell - current_buy;

    int current_profit = Integer.MIN_VALUE;
  
    for(int i=1; i<array.length; i++) {
      current_profit = array[i] - current_buy;
  
      if(current_profit > global_profit) {
        global_profit = current_profit;
        global_sell = array[i];
      }

      if(current_buy > array[i]) {
        current_buy = array[i];
      }
    }

    Tuple<Integer, Integer> result = 
      new Tuple<Integer, Integer>(global_sell - global_profit, global_sell);

    return result;
  }
```
- Runtime complexity :

The runtime complexity if this solution is linear, O(n).

- Memory complexity :

The memory complexity of this solution is constant, O(1).

### Sort an Array Using Quicksort Algorithm
<hr>

- Description :

Given an integer array, sort it in ascending order using the quicksort algorithm.

- Original Array :

`55`	`23`	`26`	`2`	`25`

- Sorted Array :

`2`	`23`	`25`	`26`	`55`

- Solution Approach :

Here is an overview of how the quicksort algorithm works :

Select a pivot element from the array to divide the array into two parts based on the pivot. We pick the first element as the pivot.
Reorder the array by comparing with the pivot element such that smaller values end up at the left side, and larger values end up at the right side of the pivot.
Now, the pivot element is in its correct sorted position. Applying the above steps, we can recursively sort the sublists on the right and left sides of the pivot.

Code :tada:
```java
  static int partition(int[] arr, int low, int high) {
    int pivotValue = arr[low];
    int i = low;
    int j = high;

    while (i < j) {
      while (i <= high && arr[i] <= pivotValue) i++;
      while (arr[j] > pivotValue) j--;

      if (i < j) {
        // swap arr[i] and arr[j]
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }

    arr[low] = arr[j];
    arr[j] = pivotValue;
  
    // return the pivot index
    return j;
  }

  static void quickSortRec(int[] arr, int low, int high) {
    if (high > low) {
      int pivotIndex = partition(arr, low, high);

     quickSortRec(arr, low, pivotIndex - 1);
      quickSortRec(arr, pivotIndex + 1, high);
    }
  }

  static void quickSort(int[] arr) {
    quickSortRec(arr, 0, arr.length - 1);
  }
```

- Runtime complexity :

The runtime complexity of this solution is linearithmic, O(nlogn).

- Memory complexity :

The memory complexity of this solution is logarithmic, O(logn).

### Maximum Sum Subarray of Size K
<hr>

- Description :

Given an array of positive numbers and a positive number ‚Äòk,‚Äô find the maximum sum of any contiguous subarray of size ‚Äòk‚Äô.

- Example 1 :
```
Input: [2, 1, 5, 1, 3, 2], k=3 Output: 9 Explanation: Subarray with maximum sum is [5, 1, 3].
```
- Example 2 :
```
Input: [2, 3, 4, 1, 5], k=2 Output: 7 Explanation: Subarray with maximum sum is [3, 4].
```
- Solution Approach :

A basic brute force solution will be to calculate the sum of all ‚Äòk‚Äô sized subarrays of the given array to find the subarray with the highest sum. We can start from every index of the given array and add the next ‚Äòk‚Äô elements to find the subarray‚Äôs sum.

- Code :tada:
```java
public static int findMaxSumSubArray(int k, int[] arr) {
    int maxSum = 0, windowSum;
    for (int i = 0; i <= arr.length - k; i++) {
      windowSum = 0;
      for (int j = i; j < i + k; j++) {
        windowSum += arr[j];
      }
      maxSum = Math.max(maxSum, windowSum);
    }

    return maxSum;
  }
```
The above algorithm‚Äôs time complexity will be O(N*K)O(N‚àóK), where ‚ÄòN‚Äô is the total number of elements in the given array. Is it possible to find a better algorithm than this?

- A better approach :

If you observe closely, you will realize that to calculate the sum of a contiguous subarray, we can utilize the sum of the previous subarray. For this, consider each subarray as a Sliding Window of size ‚Äòk.‚Äô To calculate the sum of the next subarray, we need to slide the window ahead by one element. So to slide the window forward and calculate the sum of the new position of the sliding window, we need to do two things:

Subtract the element going out of the sliding window, i.e., subtract the first element of the window.
Add the new element getting included in the sliding window, i.e., the element coming right after the end of the window.
This approach will save us from re-calculating the sum of the overlapping part of the sliding window. Here is what our algorithm will look like:

- Code :tada:
```java
public static int findMaxSumSubArray(int k, int[] arr) {
   int windowSum = 0, maxSum = 0;
   int windowStart = 0;
   for (int windowEnd = 0; windowEnd < arr.length; windowEnd++) {
     windowSum += arr[windowEnd]; // add the next element
     // slide the window, we don't need to slide if we've not hit the required window size of 'k'
     if (windowEnd >= k - 1) {
       maxSum = Math.max(maxSum, windowSum);
       windowSum -= arr[windowStart]; // subtract the element going out
       windowStart++; // slide the window ahead
     }
   }

   return maxSum;
 }
 ```
- Runtime complexity :

The time complexity of the above algorithm will be O(N).

- Memory complexity :

The algorithm runs in constant space O(1).

## Strings

### Strings
<hr>

- Common Methods & Operations :

A cheat sheet of common methods and operations on strings. Take a look at the table below that lists some common operations that can be performed on a string using built-in methods.

| Method | Description |
| --- | --- |
| str.length() | Returns the length of the string str |
| str.charAt(n) | Returns the character at the specified index |
| str.indexOf(ch) | Returns the index of the first occurrence of character ch in the string. |
| str.substring(start, end) | Returns a new string which is a substring of str beginning at start and extends to end-1 |
| str.substring(start, end) | Returns a new string which is a substring of str beginning at start and extends to end-1 |
| str.toLowerCase() | Converts string str to lower case |
| str.toUpperCase() | Converts string str to upper case |
| str1.equals(str2) | Compares the str1 with the str2 and returns true if both matches else false. |
| str1.compareTo(str2) | Returns 0 if the str1 is equal to str2, negative value if the str1 is lexicographically less than str2 or value greater than 0 if the str1 is lexicographically greater than str2|
| str.split(regex) | Splits the string and returns the array of substrings that matches the given regular expression. |
| str1.contains(str2) | Returns true if str2 is found in string str1 |
| str1.concat(str2) | Combines strings str1 and str2 |
	
### Reverse Words in a Sentence
<hr>

Given a sentence (an array of characters), reverse the order of words.

- Description- :

Reverse the order of words in a given sentence (an array of characters). Take the ‚ÄúHello World‚Äù string for example:
```
The "Hello World" string reversed should be "World Hello".
```
- Solution :

Here is how the solution works:

Reverse the string.
Traverse the string and reverse each word in place.
Let‚Äôs apply this solution to our example:
```
‚ÄúThe quick brown fox jumped over the lazy dog.‚Äù.
```
Reverse the string: ‚Äú.god yzal eht revo depmuj xof nworb kciuq ehT‚Äù
Reverse each word in-place: ‚Äúdog. lazy the over jumped fox brown quick The‚Äù

- Code :tada:
```java

class ReverseWords {
  // Null terminating strings are not used in java
  public static void strRev(char[] str, int start, int end) {
    if (str == null || str.length < 2) {
      return;
    }

    while (start < end) {
      char temp = str[start];
      str[start] = str[end];
      str[end] = temp;
      start++;
      end--;
    }
  }

  public static void reverseWords(char[] sentence) {
    // Here sentence is a null-terminated string ending with char '\0'.
    if (sentence == null || sentence.length == 0) {
      return;
    }

    // To reverse all words in the string, we will first reverse
    // the string. Now all the words are in the desired location, but
    // in reverse order: "Hello World" -> "dlroW olleH".
    int len = sentence.length;
    strRev(sentence, 0, len - 2);

    // Now, let's iterate the sentence and reverse each word in place.
    // "dlroW olleH" -> "World Hello"
    int start = 0;
    int end;

    while (true) {
      // find the  start index of a word while skipping spaces.
      while (sentence[start] == ' ') {
        ++start;
      }

      if (start >= sentence.length - 1) {
        break;
      }

      // find the end index of the word.
      end = start + 1;
      while (end < sentence.length - 1 && sentence[end] != ' ') {
        ++end;
      }

      // let's reverse the word in-place.
      strRev(sentence, start, end - 1);
      start = end;
    }
  }
  static char[] getArray(String t) {
    char[] s = new char[t.length() + 1];
    int i = 0;
    for (; i < t.length(); ++i) {
      s[i] = t.charAt(i);
    }
    return s;
  }

  public static void main(String[] args) {
    char[] s = getArray("Hello World!");
    System.out.println(s);
    reverseWords(s);
    System.out.println(s);
  }
}
```

- Runtime complexity :

The runtime complexity of this solution is linear, O(n). Position of all the elements in the sentence is changed.

- Memory complexity :

The memory complexity of this solution is constant, O(1).

```
The solution reverses every word in-place i.e., it does not require any extra space.
```

### Remove Duplicates from a String
<hr>

Remove duplicate characters from a string which is passed by reference.

- Description :

Given a string that contains duplicate occurrences of characters, remove the duplicate occurrences.
```
The string is passed by reference. So you don‚Äôt need to return anything.
```
**Solution**

In this solution, we‚Äôll keep two pointers or indices one for the current reading position and one for the current writing position. Whenever we encounter the first occurrence of a character, we add it to the HashSet. Any character already existing in the HashSet is skipped on any subsequent occurrence. Below is an overview of the algorithm:
```
read_pos = 0
write_pos = 0

for each character 'c' in str
  if 'c' not found in hashset
    add 'c' to hashset
    str[write_pos] = str[read_pos]
    write_pos++
  read_pos++
```
- Code :tada:
```java
class RemoveDuplicates {
  // this solution uses extra memory
  // to keep all characters present in string.

  static void removeDuplicates(char[] str) {
    Set<Character> hashset = new LinkedHashSet<Character> ();

    int writeIndex = 0;
    int readIndex = 0;

    while (readIndex != str.length) {

      if (!hashset.contains(str[readIndex])) {

        hashset.add(str[readIndex]);
        str[writeIndex] = str[readIndex];
        ++writeIndex;
      }

      ++readIndex;
    }

    str[writeIndex] = '\0';
  }

  // Test Program

  static char[] getArray(String t) {
    char[] s = new char[t.length() + 1];
    int i = 0;
    for (; i < t.length(); ++i) {
      s[i] = t.charAt(i);
    }
    s[i] = '\0';
    return s;
  }

  static void print(char[] s) {
    int i = 0;
    while (s[i] != '\0') {
      System.out.print(s[i]);
      ++i;
    }
    System.out.println();
  }

  public static void main(String[] args) {
  
    char[] input = getArray("dabbac");
    System.out.print("Before: ");
    System.out.println(input);
    RemoveDuplicates.removeDuplicates(input);
    System.out.print("After: ");
    print(input);
  }
}
```

- Runtime complexity :

The runtime complexity of this solution is linear, O(n).

- Memory complexity :

The memory complexity of this solution is linear, O(n).

**Solution 2**

This algorithm does not require any extra memory. It maintains two pointers indices: one for the read position and one for the write position. For every character in the input string that is present in the sub-string `[0, write_pos]`, we skip it; otherwise, we write the character at `read_pos to write_pos`. Here is the algorithm:

```
read_pos = 0
write_pos = 0
while read_pos less than length(str)
  if str[read_pos] not found in sub_string(0, write_pos)
    str[write_pos] = str[read_pos]
    ++write_pos
  ++read_pos
```

- Code :tada:
```java
class RemoveDuplicates {
  // this solution does not require any extra memory
  // but runs in O(n^2) time

  static void removeDuplicates(char[] str) {
    if (str == null || str.length == 0) {
      return;
    }

    int writeIndex = 0;
    for (int i = 0; i < str.length; i++) {
      boolean found = false;

      for (int j = 0; j < writeIndex; j++) {
        if (str[i] == str[j]) {
          found = true;
          break;
        }
      }

      if (!found) {
        str[writeIndex] = str[i];
        writeIndex++;
      }
    }

    if (writeIndex != str.length) {
      str[writeIndex] = '\0';
    }
  }

  /// Test Program.
  static void print(char[] s) {
    int i = 0;
    while (s[i] != '\0') {
      System.out.print(s[i]);
      ++i;
    }
    System.out.println();
  }

  static char[] getArray(String t) {
    char[] s = new char[t.length() + 1];
    int i = 0;
    for (; i < t.length(); ++i) {
      s[i] = t.charAt(i);
    }
   
    return s;
  }
  
  public static void main(String[] args) {
    char[] input = getArray("dabbac");
    System.out.print("Before: ");
    System.out.println(input);
    RemoveDuplicates.removeDuplicates(input);
    System.out.print("After: ");
    print(input);
  }
}
```
- Runtime complexity :

The runtime complexity of this solution is quadratic, O(n^2).

- Memory complexity :

The memory complexity of this solution is constant, O(1).

### Remove White Spaces from a String
<hr>
Given a null terminated string, remove any white spaces (tabs or spaces).

- Description :

Given a null terminated string, remove any white spaces (tabs or spaces). For example:

All greek to me. After removing the white spaces, the string should look like this:
Allgreektome.

- Solution :

This problem can be solved with two pointers. Here is an overview:
```
read_ptr and write_ptr initialized to start of string, str[0]

With the read_ptr, iterate over the input string reading one character at a time.
While moving read_ptr towards the end of the array:
  if read_ptr points to a white space, skip
  if read_ptr points to any other character, write that to write_ptr and increment the write_ptr.

Terminate the loop when the read_ptr reaches the end of the string.
At this point, the write_ptr will point to the string with all white spaces removed.
```
- Code :tada:
```java
class RemoveSpaces {
  static boolean isWhiteChar(char c) {
    // there can be more white space characters
    // but for simplicity lets assume that we have
    // only two white space character
    // i.e. space and tab
    if (c == ' ' || c == '\t') {
      return true;
    }
    return false;
  }

  static void removeWhiteSpaces(char[] s) {
    if (s == null || s.length == 0 || s[0] == '\0') {
      return;
    }

    // We will use read, write pointers here.
    // Write pointer will follow the read pointer
    // and only write characters read that are neither
    // a space (' ') nor a tab ('\t').

    int readPtr = 0;
    int writePtr = 0;
    while (readPtr < s.length) {
      // Lets assume there are only two white
      // space characters: space and tab.
      if (!isWhiteChar(s[readPtr])) {
        s[writePtr] = s[readPtr];
        ++writePtr;
      }
      ++readPtr;
    }

    // Let's mark the end of string.
    s[writePtr] = '\0';
  }

  static void print(char[] s) {
    int i = 0;
    while (i < s.length && s[i] != '\0') {
      System.out.print(s[i]);
      ++i;
    }
    System.out.println();
  }

  static char[] getArray(String t) {
    char[] s = new char[t.length()];
    int i = 0;
    for (; i < t.length(); ++i) {
      s[i] = t.charAt(i);
    }
    return s;
  }

  public static void main(String[] args) {
    char[] s = getArray("All greek to me");
    System.out.print("Before: ");
    print(s);
    removeWhiteSpaces(s);
    System.out.print("After: ");
    print(s);
  }
}
```
- Runtime complexity :

The runtime complexity of this solution is linear, O(n).

- Memory complexity :

The memory complexity of this solution is linear, O(1).

### Word Break Problem
<hr>

Given a dictionary of words and an input string tell whether the input string can be completely segmented into dictionary words.

- Description :

We are given a dictionary of words and a large input string. We have to find out whether the input string can be completely segmented into the words of a given dictionary. The following two examples elaborate on the problem further.

- Solution :

We can solve this problem by segmenting the large string at each possible position to see if the string can be completely segmented to words in the dictionary. If we write the algorithm in steps it will be as follows:
```
n = length of input string
for i = 0 to n - 1
  first_word = substring (input string from index [0, i] )
  second_word = substring (input string from index [i + 1, n - 1] )
  if dictionary has first_word
    if second_word is in dictionary OR second_word is of zero length, then return true
    recursively call this method with second_word as input and return true if it can be segmented
The algorithm will compute two strings from scratch in each iteration of the loop. Worst case scenario, there would be a recursive call of the second_word each time. This shoots the time complexity up to 2^n.
```
Code :tada:
```java

class StringSegmentation {

  public static boolean canSegmentString(String s, Set <String> dictionary) {
    for (int i = 1; i <= s.length(); ++i) {
      String first = s.substring(0, i);
      if (dictionary.contains(first)) {
        String second = s.substring(i);

        if (second == null || second.length() == 0 || dictionary.contains(second) || canSegmentString(second, dictionary)) {
          return true;
        }

      }
    }
    return false;
  }

  public static void main(String[] args) {
    Set < String > dictionary = new HashSet < String > ();
    String s = new String();
    s = "hellonow";

    dictionary.add("hello");
    dictionary.add("hell");
    dictionary.add("on");
    dictionary.add("now");
    if (canSegmentString(s, dictionary)) {
      System.out.println("String Can be Segmented");
    } else {
      System.out.println("String Can NOT be Segmented");
    }
  }
}
```
You can see that we may be computing the same substring multiple times, even if it doesn‚Äôt exist in the dictionary. This redundancy can be fixed by memoization, where we remember which substrings have already been solved To achieve memoization, we can store the second string in a new set each time.This will reduce both time and memory complexities.

- Runtime complexity :

The runtime complexity of this solution is exponential, O(2^n), if we use only recursion.

With memoization, the runtime complexity of this solution can be improved to be polynomial, O(n^2).

- Memory complexity :

The memory complexity of this solution is polynomial, O(n^2).
```
Memory Complexity is O(n^2), because we create a substring on each recursion call. Creating a substring can be avoided if we pass indices.
```

### Find all Palindrome Substrings
<hr>

Given a string, find all substrings that are palindromes.

- Description :

Given a string find all non-single letter substrings that are palindromes.

**Solution**

You can see that we may be computing the same substring multiple times, even if it doesn‚Äôt exist in the dictionary. This redundancy can be fixed by memoization, where we remember which substrings have already been solved To achieve memoization, we can store the `second` string in a new set each time.This will reduce both time and memory complexities. A palindrome is a word, phrase, number, or other sequence of characters which reads the same backwards as it reads forwards. A naive solution of this problem is to find all substrings of a given string and check whether each substring is a palindrome or not. This solution has a complexity of O(n^3).

- Code :tada:
```java
class PalindromeSubStrings{
  public static boolean isPalindrome(String input, int i, int j) {
    while(j > i){
      if(input.charAt(i) != input.charAt(j))
        return false;
      i++;
      j--;
    }
    return true;
  }

  public static int findAllPalindromeSubstrings(String input) {
    int count = 0;
    for(int i = 0 ; i < input.length() ; i++) {
      for(int j = i + 1 ; j < input.length() ; j++) {
        if(isPalindrome(input,i,j)){
          System.out.println(input.substring(i,j+1));
          count++;
        }
      }
    }
  
    return count;
  }
  public static void main(String[] args) {
    String str = "aabbbaa";
    int count = findAllPalindromeSubstrings(str);
    System.out.println("Total palindrome substrings: " + count);
  }
}
```
- Runtime complexity- :

The runtime complexity of this solution is polynomial, O(n^3).

- Memory complexity :

The memory complexity of this solution is constant, O(1).

**Solution 2**

We can reduce the runtime complexity of this algorithm to O(n^2) from O(n^3) by using the following approach. For each letter in the input string, start expanding to the left and right while checking for even and odd length palindromes. Move to the next letter if we know a palindrome doesn‚Äôt exist. We expand one character to the left and right and compare them. If both of them are equal, we print out the palindrome substring.

- Code :tada:
```java
class PalindromeSubStrings{
  public static int findPalindromesInSubString(String input, int j, int k) {
    int count = 0;
    for (; j >= 0 && k < input.length(); --j, ++k) {
      if (input.charAt(j) != input.charAt(k)) {      
        break;
      } 
      System.out.println(input.substring(j, k+1));
      count++;
    }
    return count;
  }

  public static int findAllPalindromeSubstrings(String input) {
    int count = 0;
    for(int i = 0 ; i < input.length() ; ++i) {
      count+= findPalindromesInSubString(input, i-1, i+1);
      count+= findPalindromesInSubString(input, i, i+1);
    }

    return count;
  }

  public static void main(String[] args) {
    String str = "aabbbaa";
    int count = findAllPalindromeSubstrings(str);
    System.out.println("Total palindrome substrings: " + count);
  }
}  
```
- Runtime complexity :

The runtime complexity of this solution is polynomial, O(n^2).

- Memory complexity :

The memory complexity of this solution is constant, O(1).

### Balanced Parentheses
<hr>

- Problem Statement :

For a given number ‚ÄòN‚Äô, write a function to generate all combination of ‚ÄòN‚Äô pairs of balanced parentheses.

- Example 1 :
```
Input: N=2 Output: (()), ()()
```
- Example 2 :
```
Input: N=3 Output: ((())), (()()), (())(), ()(()), ()()()
```
- Basic Solution :
  
This problem follows the Subsets pattern and can be mapped to Permutations. We can follow a similar BFS approach. Let‚Äôs take Example-2 mentioned above to generate all the combinations of balanced parentheses. Following a BFS approach, we will keep adding open parentheses ( or close parentheses ). At each step we need to keep two things in mind:

We can‚Äôt add more than ‚ÄòN‚Äô open parenthesis.
To keep the parentheses balanced, we can add a close parenthesis ) only when we have already added enough open parenthesis (. For this, we can keep a count of open and close parenthesis with every combination.
Following this guideline, let‚Äôs generate parentheses for N=3:

Start with an empty combination: ‚Äú‚Äù
At every step, let‚Äôs take all combinations of the previous step and add ( or ) keeping the above-mentioned two rules in mind.
For the empty combination, we can add ( since the count of open parenthesis will be less than ‚ÄòN‚Äô. We can‚Äôt add ) as we don‚Äôt have an equivalent open parenthesis, so our list of combinations will now be: ‚Äú(‚Äù
For the next iteration, let‚Äôs take all combinations of the previous set. For ‚Äú(‚Äù we can add another ( to it since the count of open parenthesis will be less than ‚ÄòN‚Äô. We can also add ) as we do have an equivalent open parenthesis, so our list of combinations will be: ‚Äú((‚Äù, ‚Äú()‚Äù
In the next iteration, for the first combination ‚Äú((‚Äù, we can add another ( to it as the count of open parenthesis will be less than ‚ÄòN‚Äô, we can also add ) as we do have an equivalent open parenthesis. This gives us two new combinations: ‚Äú(((‚Äù and ‚Äú(()‚Äù. For the second combination ‚Äú()‚Äù, we can add another ( to it since the count of open parenthesis will be less than ‚ÄòN‚Äô. We can‚Äôt add ) as we don‚Äôt have an equivalent open parenthesis, so our list of combinations will be: ‚Äú(((‚Äù, ‚Äú(()‚Äù, ()("
Following the same approach, next we will get the following list of combinations: ‚Äú((()‚Äù, ‚Äú(()(‚Äù, ‚Äú(())‚Äù, ‚Äú()((‚Äù, ‚Äú()()‚Äù
Next we will get: ‚Äú((())‚Äù, ‚Äú(()()‚Äù, ‚Äú(())(‚Äù, ‚Äú()(()‚Äù, ‚Äú()()(‚Äù
Finally, we will have the following combinations of balanced parentheses: ‚Äú((()))‚Äù, ‚Äú(()())‚Äù, ‚Äú(())()‚Äù, ‚Äú()(())‚Äù, ‚Äú()()()‚Äù
We can‚Äôt add more parentheses to any of the combinations, so we stop here.

Code :tada:
```java

import java.util.*;

class ParenthesesString {
  String str;
  int openCount; // open parentheses count
  int closeCount; // close parentheses count

  public ParenthesesString(String s, int openCount, int closeCount) {
    str = s;
    this.openCount = openCount;
    this.closeCount = closeCount;
  }
}

class GenerateParentheses {

  public static List<String> generateValidParentheses(int num) {
    List<String> result = new ArrayList<String>();
    Queue<ParenthesesString> queue = new LinkedList<>();
    queue.add(new ParenthesesString("", 0, 0));
    while (!queue.isEmpty()) {
      ParenthesesString ps = queue.poll();
      // if we've reached the maximum number of open and close parentheses, add to the result
      if (ps.openCount == num && ps.closeCount == num) {
        result.add(ps.str);
      } else {
        if (ps.openCount < num) // if we can add an open parentheses, add it
          queue.add(new ParenthesesString(ps.str + "(", ps.openCount + 1, ps.closeCount));

        if (ps.openCount > ps.closeCount) // if we can add a close parentheses, add it
          queue.add(new ParenthesesString(ps.str + ")", ps.openCount, ps.closeCount + 1));
      }
    }
    return result;
  }

  public static void main(String[] args) {
    List<String> result = GenerateParentheses.generateValidParentheses(2);
    System.out.println("All combinations of balanced parentheses are: " + result);

    result = GenerateParentheses.generateValidParentheses(3);
    System.out.println("All combinations of balanced parentheses are: " + result);
  }
}
```
Let‚Äôs try to estimate how many combinations we can have for ‚ÄòN‚Äô pairs of balanced parentheses. If we don‚Äôt care for the ordering - that ) can only come after ( - then we have two options for every position, i.e., either put open parentheses or close parentheses. This means we can have a maximum of 2^N‚Äã combinations. Because of the ordering, the actual number will be less than 2^N‚Äã

- Time complexity :

You will realize that, in the worst case, it is equivalent to a binary tree, where each node will have two children. This means that we will have 2^N leaf nodes and 2^N-1 intermediate nodes. So the total number of elements pushed to the queue will be 2^N + 2^N ‚àí1, which is asymptotically equivalent to O(2^N). While processing each element, we do need to concatenate the current string with ( or ). This operation will take O(N), so the overall time complexity of our algorithm will be O(N2^N)*. This is not completely accurate but reasonable enough to be presented in the interview.

The actual time complexity (O(4^n/sqrt{n}) is bounded by the Catalan number and is beyond the scope of a coding interview.

- Space complexity :

All the additional space used by our algorithm is for the output list. Since we can‚Äôt have more than O(2^N) combinations, the space complexity of our algorithm is O(N2^N)*.

- Recursive Solution :

Here is the recursive algorithm following a similar approach:

```java
import java.util.*;

class GenerateParenthesesRecursive {

  public static List<String> generateValidParentheses(int num) {
    List<String> result = new ArrayList<String>();
    char[] parenthesesString = new char[2 * num];
    generateValidParenthesesRecursive(num, 0, 0, parenthesesString, 0, result);
    return result;
  }

  private static void generateValidParenthesesRecursive(int num, int openCount, int closeCount,
      char[] parenthesesString, int index, List<String> result) {

    // if we've reached the maximum number of open and close parentheses, add to the result
    if (openCount == num && closeCount == num) {
      result.add(new String(parenthesesString));
    } else {
      if (openCount < num) { // if we can add an open parentheses, add it
        parenthesesString[index] = '(';
        generateValidParenthesesRecursive(num, openCount + 1, closeCount, parenthesesString, index + 1, result);
      }

      if (openCount > closeCount) { // if we can add a close parentheses, add it
        parenthesesString[index] = ')';
        generateValidParenthesesRecursive(num, openCount, closeCount + 1, parenthesesString, index + 1, result);
      }
    }
  }

  public static void main(String[] args) {
    List<String> result = GenerateParenthesesRecursive.generateValidParentheses(2);
    System.out.println("All combinations of balanced parentheses are: " + result);

    result = GenerateParenthesesRecursive.generateValidParentheses(3);
    System.out.println("All combinations of balanced parentheses are: " + result);
  }
}
```

### Longest Substring with Distinct Characters
<hr>

Given a string, find the length of the longest substring, which has all distinct characters.

- Example 1 :
```
Input: String="aabccbb" Output: 3 Explanation: The longest substring with distinct characters is "abc".
```
- Example 2 :
```
Input: String="abbbb" Output: 2 Explanation: The longest substring with distinct characters is "ab".
```
**Solution**
This problem follows the Sliding Window pattern, and we can use a similar dynamic sliding window strategy as discussed in Longest Substring with K Distinct Characters. We can use a HashMap to remember the last index of each character we have processed. Whenever we get a duplicate character, we will shrink our sliding window to ensure that we always have distinct characters in the sliding window.

Code :tada:
```java

import java.util.*;

class NoRepeatSubstring {
  public static int findLength(String str) {
    int windowStart = 0, maxLength = 0;
    Map<Character, Integer> charIndexMap = new HashMap<>();
    // try to extend the range [windowStart, windowEnd]
    for (int windowEnd = 0; windowEnd < str.length(); windowEnd++) {
      char rightChar = str.charAt(windowEnd);
      // if the map already contains the 'rightChar', shrink the window from the beginning so that
      // we have only one occurrence of 'rightChar'
      if (charIndexMap.containsKey(rightChar)) {
        // this is tricky; in the current window, we will not have any 'rightChar' after its previous index
        // and if 'windowStart' is already ahead of the last index of 'rightChar', we'll keep 'windowStart'
        windowStart = Math.max(windowStart, charIndexMap.get(rightChar) + 1);
      }
      charIndexMap.put(rightChar, windowEnd); // insert the 'rightChar' into the map
      maxLength = Math.max(maxLength, windowEnd - windowStart + 1); // remember the maximum length so far
    }

    return maxLength;
  }

  public static void main(String[] args) {
    System.out.println("Length of the longest substring: " + NoRepeatSubstring.findLength("aabccbb"));
    System.out.println("Length of the longest substring: " + NoRepeatSubstring.findLength("abbbb"));
    System.out.println("Length of the longest substring: " + NoRepeatSubstring.findLength("abccde"));
  }
}
```
- Time Complexity :

The above algorithm‚Äôs time complexity will be O(N), where ‚ÄòN‚Äô is the number of characters in the input string.

- Space Complexity :

The algorithm‚Äôs space complexity will be O(K)O(K), where KK is the number of distinct characters in the input string. This also means K<=NK<=N, because in the worst case, the whole string might not have any duplicate character, so the entire string will be added to the HashMap. Having said that, since we can expect a fixed set of characters in the input string (e.g., 26 for English letters), we can say that the algorithm runs in fixed space O(1)O(1); in this case, we can use a fixed-size array instead of the HashMap.

## Linked List

### Introduction TO Linked Lists
<hr>

A linked list is a linear data structure consisting of nodes where each node contains data and a pointer to the next node in the list. There are two kinds of linked lists:

```
Singly linked list 
Doubly link
```
- Singly Linked List :

A singly linked list can only be traversed in one direction, meaning, from the first node (head) towards the last node. The last node points to NULL, indicating the end of the list.

- Pros :

Insertion and deletion at head is more efficient compared to the corresponding operations in an array.
Changes are localized when inserting and deleting somewhere in the middle of the linked list. In the case of an array, all subsequent elements need to be moved around. Of course, if you first have to search for the position to insert or delete in a linked list, then it still takes O(n) in the worst case.
- Cons :

As each node also contains a pointer, it has a memory overhead.
We cannot access a node through indexing directly, rather we have to traverse from the start to access an element at a given position n.
Reverse traversing is not possible with a singly linked list.

- Doubly Linked List :

Each node in a doubly linked list contains a pointer to the next node as well as pointer to the previous node. This allows the list to be traversed in both directions: forward and backward.

Doubly linked lists have all the advantages of singly-linked lists while providing some additional pros and cons.

- Pros :

Insert and delete at the head as well as tail are O(1) operations
The list can be traversed forward as well as backward

- Cons :

Have greater space overhead than singly-linked lists

- Singly vs. Doubly linked list table :

Deletion at the tail is one of the operations that distinguishes a doubly-linked list from a singly-linked list. The following table shows a side by side comparison of key operations on both.

| Operations | Singly Linked List | Doubly Linked List|
| --- | --- | --- |
| Insert at head | O(1) | O(1) |
| Delete at head | O(1)	| O(1) |
| Insert at tail | O(n)	| O(1) |
| Delete at tail | O(n)	| O(1) |

In terms of space, if there are `n` nodes in a linked list, `d` is the (average) number of bytes of data in each node and `p` is the number of bytes consumed by a pointer, then a `singly linked list` consumes n*(d+p) bytes, whereas a `doubly linked list` consumes n*(d+2p) bytes.

### Insertion in a Singly Linked List (insert at End)
<hr>

- Introduction :

Now, we are going to explain the second part (Insertion at End) and look at its examples, along with one coding challenge for the sake of practice. So let‚Äôs see how elements are inserted at the end of a linked list. In this type of insertion, we add an element at the end of the list.

- Problem Statement :

In the code snippet provided below, you will complete the void insertAtEnd(T data) method. This will take a generic type T value called data and insert that value at the end of the list. This code would be the part of the SinglyLinkedList class that we created in the previous lesson, therefore, any private members of that class can be accessed inside the function as well. After writing the code, run it and see how many tests you passed.

- Method Prototype :
```
void insertAtEnd(T data)
```
- Output :

The return type of the method is `void`. The object on which it is called will be modified only.

- Sample Input :

```
linkedlist = 0->1->2 data = 3
```
- Sample Output :

```
linkedlist = 0->1->2->3
```
**Solution**

If you grasped the logic behind insertion at the head of a linked list, this shouldn‚Äôt be much of a challenge. If the list is empty, the situation is exactly like insertion at the head. Otherwise, we can use a loop to reach the tail of the list and set our new node as the `nextNode` of the `last` node.

- Code :tada:
```java

public class SinglyLinkedList<T> {
//Node inner class for SLL
    public class Node {
        public T data;
        public Node nextNode;

    }

    public Node headNode; //head node of the linked list
    public int size;      //size of the linked list

    //Constructor - initializes headNode and size
    public SinglyLinkedList() {
        headNode = null;
        size = 0;
    }

    //Helper Function that checks if List is empty or not 
    public boolean isEmpty() {
        if (headNode == null) return true;
        return false;
    }

    //Inserts new data at the start of the linked list
    public void insertAtHead(T data) {
        //Creating a new node and assigning it the new data value
        Node newNode = new Node();
        newNode.data = data;
        //Linking head to the newNode's nextNode
        newNode.nextNode = headNode;
        headNode = newNode;
        size++;
    }

    // Helper Function to printList
    public void printList() {
        if (isEmpty()) {
            System.out.println("List is Empty!");
            return;
        }

        Node temp = headNode;
        System.out.print("List : ");
        while (temp.nextNode != null) {
            System.out.print(temp.data.toString() + " -> ");
            temp = temp.nextNode;
        }
        System.out.println(temp.data.toString() + " -> null");
    }
    
    //Inserts new data at the end of the linked list
    public void insertAtEnd(T data) {
        //if the list is empty then call insertATHead()
        if (isEmpty()) {
            insertAtHead(data);
            return;
        }
        //Creating a new Node with value data 
        Node newNode = new Node();
        newNode.data = data;
        newNode.nextNode = null;

        Node last = headNode;
        //iterate to the last element 
        while (last.nextNode != null) {
            last = last.nextNode;
        }
        //make newNode the next element of the last node
        last.nextNode = newNode;
        size++;
    }
}
```
- Time Complexity :

This algorithm traverses the entire linked list, and hence, works in O(n) time.

### Search in Singly Linked List
<hr>

- Introduction :

Now, we will take a look at the second most important operation, i.e. searching for an element in a linked list. This exercise of finding a value in a Singly Linked List is relatively more straightforward than the other three operations of insertion.

The steps to search for a node in a Singly Linked List are as follows:

Start from the `headNode`.
Traverse the list till you either find a node with the given value, or you reach the end showing that the node being searched doesn‚Äôt exist.

- Problem Statement :

If you know how to insert an element in a list, then searching for an item will not be that difficult for you. Now, based on the steps mentioned above, we have designed a simple coding exercise for your practice. There is a solution placed in the solution section for your help, but try to solve it on your own first.

- Method Prototype :
```
boolean searchNode(T data)
```
- Output :

It returns true or false to show if a certain value does or does not exists in the list.

- Sample Input :
```
linkedlist = 5->90->10->4 and value = 4
```
- Sample Output :
```
true
```
**Soution**

In this function, we traverse through the list, checking whether the currentNode‚Äôs `data` matches the searched value `data`. If the currentNode‚Äôs `data` matches the searched value `data`, we will return `True` else we will return `False`.

- Code :tada:
```java
public class SinglyLinkedList<T> {
    //Node inner class for SLL
    public class Node {
        public T data;
        public Node nextNode;

    }

    //head node of the linked list
    public Node headNode;
    public int size;

    //constructor
    public SinglyLinkedList() {
        headNode = null;
        size = 0;
    }

    public boolean isEmpty() {

        if (headNode == null) return true;
        return false;
    }

    //Inserts new data at the start of the linked list
    public void insertAtHead(T data) {
        //Creating a new node and assigning it the new data value
        Node newNode = new Node();
        newNode.data = data;
        //Linking head to the newNode's nextNode
        newNode.nextNode = headNode;
        headNode = newNode;
        size++;
    }

    //Inserts new data at the end of the linked list
    public void insertAtEnd(T data) {
        //if the list is empty then call insertATHead()
        if (isEmpty()) {
            insertAtHead(data);
            return;
        }
        //Creating a new Node with value data
        Node newNode = new Node();
        newNode.data = data;
        newNode.nextNode = null;

        Node last = headNode;
        //iterate to the last element
        while (last.nextNode != null) {
            last = last.nextNode;
        }
        //make newNode the next element of the last node
        last.nextNode = newNode;
        size++;
    }

    //inserts data after the given prev data node
    public void insertAfter(T data, T previous) {

        //Creating a new Node with value data
        Node newNode = new Node();
        newNode.data = data;
        //Start from head node
        Node currentNode = this.headNode;
        //traverse the list until node having data equal to previous is found
        while (currentNode != null && currentNode.data != previous) {
            currentNode = currentNode.nextNode;
        }
        //if such a node was found
        //then point our newNode to currentNode's nextElement
        if (currentNode != null) {
            newNode.nextNode = currentNode.nextNode;
            currentNode.nextNode = newNode;
            size++;
        }
    }

    public void printList() {
        if (isEmpty()) {
            System.out.println("List is Empty!");
            return;
        }

        Node temp = headNode;
        System.out.print("List : ");

        while (temp.nextNode != null) {
            System.out.print(temp.data.toString() + " -> ");
            temp = temp.nextNode;
        }

        System.out.println(temp.data.toString() + " -> null");
    }

    //Searches a value in the given list.
    public boolean searchNode(T data) {
        //Start from first element
        Node currentNode = this.headNode;

        //Traverse the list till you reach end
        while (currentNode != null) {
            if (currentNode.data.equals(data))
                return true; //value found

            currentNode = currentNode.nextNode;
        }
        return false; //value not found
    }
}

```
- Time Complexity :

The time complexity for this algorithm is O(n) because we have to traverse through the list.

### Deletion in Singly Linked List (Delete by Value)
<hr>

- Introduction :

This operation deletes the required node, e.g., n, from any position in a Singly Linked List. This deletion follows the following steps:

It takes in the value that needs to be deleted from the list.
It traverses the list searching for that value.
Once the node (n) with the required value is found, it connects n's previous node to the nextNode of n.
It then removes n from the list.

- Problem Statement :

In the code snippet given below, you have to implement the void deleteByValue(T data) method. In this method, we will pass a particular value that we want to delete from the list. The node containing this value could be anywhere on the list. It is also possible that such a node may not exist at all. Therefore, we would have to traverse the whole list until we find the value which needs to be deleted. If the value doesn‚Äôt exist, we simply return control to the calling function.

```
Note: This function removes only the first occurrence of the value from the list.
```
- Method Prototype :
```
void deleteByValue(T data)
```
- Output :
```
A linked list with the element removed.
```
- Sample Input :
```
linkedlist = 3->2->1->0, data = 1
```
- Sample Output :
```
linkedlist = 3->2->0
```
- Solution :

While traversing through the linked list, there are three cases we can come across:

List is empty
One element in the list
More than one element in the list
If the list is empty, then we have nothing to do; just return the control to calling function. For a single element in the list, we‚Äôll call `deleteAtHead()`, and this will delete the value at the head.

If there is more than one element in the list, then we simply start traversing from the `headNode` and keep on checking until that node found and delete it.

- Code :tada:
```java

  public class SinglyLinkedList<T> {
    //Node inner class for SLL
    public class Node {
        public T data;
        public Node nextNode;

    }

    //head node of the linked list
    public Node headNode;
    public int size;

    //constructor
    public SinglyLinkedList() {
        headNode = null;
        size = 0;
    }

    public boolean isEmpty() {

        if (headNode == null) return true;
        return false;
    }

    //Inserts new data at the start of the linked list
    public void insertAtHead(T data) {
        //Creating a new node and assigning it the new data value
        Node newNode = new Node();
        newNode.data = data;
        //Linking head to the newNode's nextNode
        newNode.nextNode = headNode;
        headNode = newNode;
        size++;
    }

    //Inserts new data at the end of the linked list
    public void insertAtEnd(T data) {
        //if the list is empty then call insertATHead()
        if (isEmpty()) {
            insertAtHead(data);
            return;
        }
        //Creating a new Node with value data
        Node newNode = new Node();
        newNode.data = data;
        newNode.nextNode = null;

        Node last = headNode;
        //iterate to the last element
        while (last.nextNode != null) {
            last = last.nextNode;
        }
        //make newNode the next element of the last node
        last.nextNode = newNode;
        size++;
    }

    //inserts data after the given prev data node
    public void insertAfter(T data, T previous) {

        //Creating a new Node with value data
        Node newNode = new Node();
        newNode.data = data;
        //Start from head node
        Node currentNode = this.headNode;
        //traverse the list until node having data equal to previous is found
        while (currentNode != null && currentNode.data != previous) {
            currentNode = currentNode.nextNode;
        }
        //if such a node was found
        //then point our newNode to currentNode's nextElement
        if (currentNode != null) {
            newNode.nextNode = currentNode.nextNode;
            currentNode.nextNode = newNode;
            size++;
        }
    }

    public void printList() {
        if (isEmpty()) {
            System.out.println("List is Empty!");
            return;
        }

        Node temp = headNode;
        System.out.print("List : ");

        while (temp.nextNode != null) {
            System.out.print(temp.data.toString() + " -> ");
            temp = temp.nextNode;
        }

        System.out.println(temp.data.toString() + " -> null");
    }

    //Searches a value in the given list.
    public boolean searchNode(T data) {
        //Start from first element
        Node currentNode = this.headNode;

        //Traverse the list till you reach end
        while (currentNode != null) {
            if (currentNode.data.equals(data))
                return true; //value found

            currentNode = currentNode.nextNode;
        }
        return false; //value not found
    }

    //Deletes data from the head of list
    public void deleteAtHead() {
        //if list is empty then simply return
        if (isEmpty())
            return;
        //make the nextNode of the headNode equal to new headNode
        headNode = headNode.nextNode;
        size--;
    }

    //Deletes data given from the linked list
    public void deleteByValue(T data) {
        //if empty then simply return
        if (isEmpty())
            return;

        //Start from head node
        Node currentNode = this.headNode;
        Node prevNode = null; //previous node starts from null

        if(currentNode.data.equals(data)) {
            //data is at head so delete from head
            deleteAtHead();
            return;
        }
        //traverse the list searching for the data to delete
        while (currentNode != null) {
            //node to delete is found
            if (data.equals(currentNode.data)){
                prevNode.nextNode = currentNode.nextNode;
                size--;
                return; 
            }
            prevNode = currentNode;
            currentNode = currentNode.nextNode;
        }
    }
}   
```

`deleteByValue():` It takes a value as a parameter. Additionally, it searches for a node in the Singly Linked List that has the given data value while keeping track of current and previous nodes. If not found, it means no such value exists in the list. If found, it performs a series of steps to delete this value. However, before jumping to those steps, look at some of the terminologies that we used in the function:

`currentNode` ‚Äì node we are currently standing at
`prevNode` ‚Äì element that comes before `currentNode`
`nextNode` ‚Äì pointer to the next node of `currentNode`

Executing the single line of code,
```
prevNode.nextNode = currentNode.nextNode
```
links the prevNode to the nextNode. The current node‚Äôs link will be destroyed from the list, and the garbage collector will take care of the deletion automatically.

- Time Complexity :

In the worst case, you would have to traverse until the end of the list. This means the time complexity will be O(n).

### Linked Lists vs Arrays
<hr>

Let's put the two data structures against each other to find out which is more efficient.

- Memory Allocation :

The main difference between a linked list and an array is the way they are allocated memory. Arrays instantiate a whole block of memory, e.g., array[1000] gets space to store 1000 elements at the start even if it doesn‚Äôt contain any element yet. On the other hand, a linked list only instantiates the portion of memory it uses.

- Insertion and Deletion :

For lists and arrays, many differences can be observed in the way elements are inserted and deleted. In a linked list, insertion and deletion at head happen in a constant amount of time (O(1)), while arrays take O(n) time to insert or delete a value because you have to shift the array elements left or right after that operation.

- Searching :

In an array, it takes constant time to access an index. In a linked list, you have to iterate the list from the start until you find the node with the correct value.

The table given below will summarize the performance difference between linked lists and arrays.

| Operation | Linked List | Array |
| --- | --- | --- |
| Access | O(n) | O(1) |
| Insert (at head) | O(1) | O(n) |
| Delete (at head) | O(1) | O(n) |
| Insert (at tail) | O(n) | O(n) |
| Delete (at tail) | O(n) | O(n) |

As you can see, there is a trade-off between the facilities provided by both structures. You will understand more about the working of linked lists in the lessons that follow.

### Find the Length of a Linked List
<hr>

- Problem Statement :

In this problem, you have to implement the method `int length()`, which will count the number of nodes in a linked list. An illustration is also provided for your understanding.

- Method Prototype :
```
int length()
```
Output :

The length of the given linked list.

- Sample Input :
```
linkedlist = 0->1->2-3->4
```
- Sample Output :
```
length = 5
```
**Solution**

```java
class CheckLength {
  public static void main( String args[] ) {
        SinglyLinkedList<String> list = new SinglyLinkedList<String>();
        list.insertAtEnd("This");
        list.insertAtEnd("list");
        list.insertAtEnd("is");
        list.insertAtEnd("Generic");
        list.printList();
        System.out.println("Length : " + list.length());
    }
}
```

- Explanation :

The logic behind it is very similar to that of the `search` function. The trick is to iterate through the list and keep count of how many nodes you‚Äôve visited. This count is held in a variable that is returned when the end of the list is reached.

- Time Complexity :

Since this is a linear algorithm, the time complexity will be O(n).

### Reverse a Linked List
<hr>

- Problem Statement :

In this problem, you have to implement the public static void reverse(SinglyLinkedList list) method, which will take a linked list as input and reverse its content. An illustration is also provided for your help to see how the linked list will look after passing it to your function.

- Method Prototype :
```
public static void reverse(SinglyLinkedList list)
```
- Output :

A Singly linked list with all its content stored in reverse order.

- Sample Input :
```
linkedlist = 10->9->4->4-6
```
- Sample Output :
```
linkedlist = 6->4->4->9->10
```

**Solution**
- Code :tada:

```java
public static void reverse(SinglyLinkedList list){
	SinglyLinkedList.Node previous = null; //To keep track of the previous element, will be used in swapping links
			SinglyLinkedList.Node current = list.headNode; //firstElement
			SinglyLinkedList.Node next = null;

			//While Traversing the list, swap links
			while (current != null) {
					next = current.nextNode;
					current.nextNode = previous;
					previous = current;
					current = next;
			}
			//Linking Head Node with the new First Element
			list.headNode = previous;
}
```

- Explanation :

The brain of this solution lies in the loop, which iterates through the list. For any `current` node, its link with the `previous` node is reverse and the next stores `next` node in the list:

Store the `current` node‚Äôs `nextNode` in `next`
Set `current` node‚Äôs `nextNode` to `previous` (reversal)
Make the `current` node the new `previous` so that it can be used for the next iteration
Use `next` to move on to the next node
In the end, we simply point the head to the last node in our loop.

- Time Complexity :

The algorithm runs in O(n) since the list is traversed once.

### Detect Loop in a Linked List
<hr>

- Problem Statement :

In this problem, you have to implement the public static boolean detectLoop(SinglyLinkedList list) method, which will take a Singly linked list as input and find if there is a loop present in the list. A loop in a linked list occurs if any node contains a reference to any previous node, then a loop will be formed. An illustration is also provided for your understanding.

- Method Prototype :
```
public static boolean detectLoop(SinglyLinkedList list)
```
- Output :

It returns true if a loop exists in the linked list; otherwise, false.

- Sample Input :
```
linkedlist = 7->14->21->7
```
- Sample Output :
```
true
```

**Solution**
- Code :tada:
  
```java
    public static boolean detectLoop(SinglyLinkedList list) {
        SinglyLinkedList.Node slow = list.headNode;
        SinglyLinkedList.Node fast = list.headNode;
        
        while(slow != null && fast != null && fast.nextNode != null)
        {
            slow = slow.nextNode;	//the slow pointer will jump 1 step
            fast = fast.nextNode.nextNode; //the fast pointer will jump 2 steps 
			// when the pointers become equal then there must be a loop
            if(slow == fast){
                return true;
            }
        }
        return false;
    }
```

- Explanation :

This is the most optimized method to find out the loop in the LinkedList. We start traversing the LinkedList using two pointers called slow and fast. Move slow by one (line # 9) and fast by two (line # 10). If these pointers meet at the same node, then there is a loop. If these pointers do not meet, then LinkedList doesn‚Äôt have a loop.

- Time Complexity :

The algorithm runs in Constant with O(n) with the Auxiliary Space complexity of O(1).

### Find the Middle Node of a Linked List
<hr>

- Problem Statement :

In this problem, you have to implement the public static Object findMiddle(SinglyLinkedList list) method, which will take a linked list as an input and return the value at the middle node of the list. An illustration is also provided for your understanding.

- Method Prototype :
```
public static Object findMiddle(SinglyLinkedList list)
```
- Output :

The value at the middle node in a linked list.

- Sample Input :
```
linkedlist = 7->14->10->21
```
- Sample Output :
```
mid = 14
```
**Solution**
- Code :tada;

```java
    public static  Object findMiddle(SinglyLinkedList list) {
        //if list is empty, then return null
        if (list.isEmpty())
            return null;
        
        //both nodes start from the head
        SinglyLinkedList.Node mid = list.headNode;
        SinglyLinkedList.Node current = list.headNode;
        
        while(mid != null && current != null && current.nextNode != null)
        {
            //current jumps 2 nodes on each iteration
            current = current.nextNode.nextNode;
            //if current is not null (end of list is not reached)
            if(current != null){
                //then mid jumps 1 node
                //mid is always halfway behind current
                mid = mid.nextNode;
            }
        }
        return mid.data;
    }
```

- Explanation :

We are using two pointers, which will work simultaneously. Think of it this way:

The `current` pointer moves two steps at a time till the end of the list
The `mid` pointer moves one step at a time
When the `current` pointer reaches the end, the `mid` pointer will be at the middle

- Time Complexity :

We are traversing the linked list at twice the speed, so it is certainly faster. However, the bottleneck complexity is still O(n).

### Remove Duplicates from a Linked List
<hr>

- Problem Statement :

In this problem, you have to implement `public static void removeDuplicates(SinglyLinkedList list)` method. This method will take a Singly linked list as input and remove all the elements that appear more than once in the list. An illustration is also provided for your understanding.

- Method Prototype :
```
public static void removeDuplicates(SinglyLinkedList list)
```
- Output :

The linked list with all the duplicates removed.

- Sample Input :
```
linkedlist = 7->14->21->14->22->null
```
- Sample Output :
```
linkedlist = 7->14->21->22->null
```
- Solution**
- Code :tada:

```java
    public static void removeDuplicates(SinglyLinkedList list) {
        SinglyLinkedList.Node current = list.headNode; // will be used for outer loop
        SinglyLinkedList.Node compare = null;     // will be used for inner loop

        while (current != null && current.nextNode != null) {
            compare = current;
            while (compare.nextNode != null) {
                if (current.data.equals(compare.nextNode.data)) { //check if duplicate
                    compare.nextNode = compare.nextNode.nextNode;
                } else {
                    compare = compare.nextNode;
                }
            }
            current = current.nextNode;
        }
    }
 ```
    
- Explanation :

This solution is simply a brute force solution. In this solution, we traverse the linked list using two loops. The pointer `current` keeps track of the outer loop, and the pointer `compare` is used for the inner loop. When both of these pointers point to the same value, then that node is deleted. This is not the most efficient approach to solve this problem. It can also be solved using a Hash Table.

- Time Complexity :

This algorithm has two nested loops. Hence, the time complexity is O(n^2).

```
Note: The solution provided above is not the optimal solution for this problem. A more efficient approach is to use hashing instead.
```

### Return the Nth node from End
<hr>

- Problem Statement :

In this problem, you have to implement `Object nthElementFromEnd(SinglyLinkedList list, int n)` method, which will take a linked list as an input and returns the nth element of the list from the end. To solve this, you will have to come up with a formula by comparing multiple outputs and inputs and identifying a common pattern. An illustration is also provided for your understanding.

- Method Prototype :
```
public static Object nthElementFromEnd(SinglyLinkedList list, int n)
```
- Output: 

It will return nth node from the end of the linked list.

- Sample Input :
```
linkedlist = 22->18->60->78->47->39->99 and n=3
```
- Sample Output :
```
47
```
**Solution**
- Code :tada:
```java

    public static Object nthElementFromEnd(SinglyLinkedList list, int n) {
        int size = list.getSize();
        n = size - n + 1; //we can use the size variable to calculate distance from start
        if (size == 0 || n > size) {
            return null; //returns null if list is empty or n is greater than size
        }
        SinglyLinkedList.Node current = list.getHeadNode();
        int count = 1;
        //traverse until count is not equal to n
        while (current != null) {
            if (count == n)
                return current.data;
            count++;
            current = current.nextNode;
        }
        return null;
    }
```
- Explanation :

In the above solution, we first use the getter function `list.getSize()` to access the length of the list. Then we find the node which is at x position from the start.

- Time Complexity :

In the worst-case time complexity of this algorithm is O(n). Because we might have to access the 1st element from the end.

### Implementation of Linked List
<hr>

Linked list implementation will be covered in this lesson. We'll use this implementation in the whole chapter. Before moving on to the challenges of the linked list, let‚Äôs look at the implementation of `LinkedListNode` and `LinkedList` classes first. These classes are prepended in all the coming challenges of the chapter.

- Implementation of LinkedListNode Class :
- Code :tada:
```java
class LinkedListNode {
    public int key;
    public int data;
    public LinkedListNode next;
    public LinkedListNode arbitraryPointer;

    public LinkedListNode(int data) {
        this.data = data;
        this.next = null;
    }

    public LinkedListNode(int key, int data) {
        this.key = key;
        this.data = data;
        this.next = null;
    }

    public LinkedListNode(int data, LinkedListNode next) {
        this.data = data;
        this.next = next;
    }

    public LinkedListNode(int data, LinkedListNode next, LinkedListNode arbitraryPointer) {
        this.data = data;
        this.next = next;
        this.arbitraryPointer = arbitraryPointer;
    }
}
Implementation of LinkedList Class
import java.util.*;

class LinkedList { 

    public static LinkedListNode insertAtHead(LinkedListNode head, int data) {
        LinkedListNode newNode = new LinkedListNode(data);
        newNode.next = head;
        return newNode;
    }

    public static LinkedListNode insertAtTail(LinkedListNode head, int data) {
        LinkedListNode newNode = new LinkedListNode(data);
        if (head == null) {
            return newNode;
        }
        LinkedListNode temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        return head;
    }

    public static LinkedListNode createLinkedList(ArrayList<Integer> lst) {
        LinkedListNode head = null;
        LinkedListNode tail = null;
        for (Integer x : lst) {
            LinkedListNode newNode = new LinkedListNode(x);
            if (head == null) {
                head = newNode;
            } else {
                tail.next = newNode;
            }
            tail = newNode;
        }
        return head;
    }

    public static LinkedListNode createLinkedList(int[] arr) {
        LinkedListNode head = null;
        LinkedListNode tail = null;
        for (int i = 0; i < arr.length; ++i) {
            LinkedListNode newNode = new LinkedListNode(arr[i]);
            if (head == null) {
                head = newNode;
            } else {
                tail.next = newNode;
            }
            tail = newNode;
        }
        return head;
    }

    public static LinkedListNode createRandomList(int length) {
        LinkedListNode listHead = null;
        Random generator = new Random();
        for(int i = 0; i < length; ++i) {
            listHead = insertAtHead(listHead, generator.nextInt(100));
        }
        return listHead;
    }

    public static void display(LinkedListNode head) {
        LinkedListNode temp = head;
        while (temp != null) {
            System.out.printf("%d", temp.data);
            temp = temp.next;
            if (temp != null) {
              System.out.printf(", ");
            }
        }
        System.out.println();
    }  
}

class Pair<X, Y> {
    public X first;
    public Y second;
    public Pair(X first, Y second) {
    this.first = first;
    this.second = second;
  }
}
```

### Intersection Point of Two Lists
<hr>

Given the head nodes of two linked lists that may or may not intersect, find out if they intersect and return the point of intersection. Return null otherwise.

- Description :

Given the head nodes of two linked lists that may or may not intersect, find out if they do in fact intersect and return the point of intersection. Return null otherwise

- Hints :
Find the length of both linked lists.

The linked lists have to physically intersect. This means that their addresses need to be the same. If two nodes have the same data but their addresses are not the same, the lists won‚Äôt intersect and the function should return NULL.

**Solution**

The first solution that comes to mind is one with quadratic time complexity, i.e., for each node in the first linked list, a linear scan must be done in the second linked list. If any node from the first linked list is found in the second linked list (comparing addresses of nodes, not their data), that is the intersection point. However, if none of the nodes from the first list is found in the second list, that means there is no intersection point. Although this works, it is not efficient. A more efficient solution would be to store the nodes of the first linked list in a HashSet and then go through the second linked list nodes to check whether any of the nodes exist in the HashSet. This approach has a linear runtime complexity and linear space complexity. We can use a much better, i.e., O(m + n), linear time complexity algorithm that doesn‚Äôt require extra memory. To simplify our problem, let‚Äôs say both the linked lists are of the same size. In this case, you can start from the heads of both lists and compare their addresses. If these addresses match, it means it is an intersection point. If they don‚Äôt match, move both pointers forward one step and compare their addresses. Repeat this process until an intersection point is found, or both of the lists are exhausted. How do we solve this problem if the lists are not of the same length? We can extend the linear time solution with one extra scan on the linked lists to find their lengths. Below is the complete algorithm:

```
Find lengths of both linked lists: L1 and L2 Calculate the difference in length of both linked lists: d = |L1 - L2| Move head pointer of longer list 'd' steps forward Now traverse both lists, comparing nodes until we find a match or reach the end of lists
```

Code :tada:
```java

class Intersect{
  public static LinkedListNode intersect(LinkedListNode head1, LinkedListNode head2) {

    LinkedListNode list1node = null;
    int list1length = get_length(head1);
    LinkedListNode list2node = null;
    int list2length = get_length(head2);

    int length_difference = 0;
    if(list1length >= list2length) {
      length_difference = list1length - list2length;
      list1node = head1;
      list2node = head2;
    } else {
      length_difference = list2length - list1length;
      list1node = head2;
      list2node = head1;
    }

    while(length_difference > 0) {
      list1node = list1node.next;
      length_difference--;
    }

    while(list1node != null) {
      if(list1node == list2node) {
        return list1node;
      }

      list1node = list1node.next;
      list2node = list2node.next;
    }
    return null;
  }

  private static int get_length(
    LinkedListNode head) {      
    int list_length = 0;
    while(head != null) {
      head = head.next;
      list_length++;
    }
    return list_length;
  }
  public static void main(String[] args) {
    int [] a1 = {13,4};
    int [] a2 = {29, 23, 82, 11};
    LinkedListNode list_head_1 = LinkedList.createLinkedList(a1);
    LinkedListNode list_head_2 = LinkedList.createLinkedList(a2);
    LinkedListNode node1 = new LinkedListNode(12);
    LinkedListNode node2 = new LinkedListNode(27);

    LinkedList.insertAtTail(list_head_1, node1);
    LinkedList.insertAtTail(list_head_1, node2);
    
    LinkedList.insertAtTail(list_head_2, node1);
    
    System.out.print("List 1: ");
    LinkedList.display(list_head_1);
    System.out.print("List 2: ");
    LinkedList.display(list_head_2);

    LinkedListNode intersect_node = intersect(list_head_1, list_head_2);
    System.out.println(String.format("Intersect at %d", intersect_node.data));  
  }
}  
```

- Runtime complexity :

The runtime complexity of this solution is linear, O(m + n) Where m is the length of the first linked list and n is the length of the second linked list.

- Memory complexity :

The memory complexity of this solution is constant, O(1).

### Reverse Alternate K Nodes in a Singly Linked List
<hr>

Given a singly linked list and an integer 'k', reverse every 'k' element. If k <= 1, then the input list is unchanged. If k >= n (n is the length of linked list), then reverse the whole linked list.

- Description :

Given a singly linked list and an integer ‚Äòk‚Äô, reverse every ‚Äòk‚Äô element. If `k <= 1`, then the input list is unchanged. If` k >= n` (n is the length of the linked list), then reverse the whole linked list.

- Hints :

Reverse the first k element, then move to the next k element.

**Solution**

Algorithmically, it is a simple problem, but writing code for this is a bit trickier as it involves keeping track of a few pointers. Logically, we break down the list to sub-lists each of size ‚Äòk‚Äô. We‚Äôll use the below pointers:

`reversed`: it points to the head of the output list.
`current_head`: head of the sub-list of size ‚Äòk‚Äô currently being worked upon.
`current_tail`: tail of the sub-list of size ‚Äòk‚Äô currently being worked upon.
`prev_tail`: tail of the already processed linked list (where sub-lists of size ‚Äòk‚Äô have been reversed).
We‚Äôll work upon one sub-list of size ‚Äòk‚Äô at a time. Once that sub-list is reversed, we have its head and tail in `current_head` and `current_tail` respectively. If it was the first sub-list of size ‚Äòk‚Äô, its head (i.e., `current_head`) is the head (i.e., `reversed`) of the output linked list. We‚Äôll point `reversed` to `current_head` of the first sub-list. If it is the 2nd or higher sub-list, we‚Äôll connect the tail of the previous sub-list to head of the current sub-list, i.e., update `next` pointer of the tail of the previous sub-list with the head pointer of current sub-list to join the two sub-lists.

- Code :tada:
```java

class ReverseK{
  static LinkedListNode reverseKNodes(LinkedListNode head, int k) {

    // if k is 0 or 1, then list is not changed
    if (k <= 1 || head == null) {
      return head;
    }

    LinkedListNode reversed = null;
    LinkedListNode prevTail = null;

    while (head != null && k > 0) {
      LinkedListNode currentHead = null;
      LinkedListNode currentTail = head;

      int n = k;
      while (head != null && n > 0) {
        LinkedListNode temp = head.next;
        head.next = currentHead;
        currentHead = head;

        head = temp;
        n--;
      }

      if (reversed == null) {
        reversed = currentHead;
      }

      if (prevTail != null) {
        prevTail.next = currentHead;
      }
      prevTail = currentTail;
    }

    return reversed;
  }

  public static void main(String[] args) {
    int[] v1 = new int[]{1, 2, 3, 4, 5, 6, 7};
    LinkedListNode listHead = LinkedList.createLinkedList(v1);
    System.out.print("Original list: ");
    LinkedList.display(listHead);

    listHead = reverseKNodes(listHead, 4);
    System.out.print("List reversed by 4: ");
    LinkedList.display(listHead);
  }
}  
```

- Runtime complexity :

The runtime complexity of this solution is linear, O(n).

- Memory complexity :

The memory complexity of this solution is constant, O(1).

### Merge K Sorted Lists
<hr>

- Problem Statement :

Given an array of ‚ÄòK‚Äô sorted LinkedLists, merge them into one sorted list.

- Example 1 :
```
Input: L1=[2, 6, 8], L2=[3, 6, 7], L3=[1, 3, 4] Output: [1, 2, 3, 3, 4, 6, 6, 7, 8]
```
- Example 2 :
```
Input: L1=[5, 8, 9], L2=[1, 7] Output: [1, 5, 7, 8, 9]
```
- Solution : 

A brute force solution could be to add all elements of the given ‚ÄòK‚Äô lists to one list and sort it. If there are a total of ‚ÄòN‚Äô elements in all the input lists, then the brute force solution will have a time complexity of O(NlogN)* as we will need to sort the merged list. Can we do better than this? How can we utilize the fact that the input lists are individually sorted? If we have to find the smallest element of all the input lists, we have to compare only the smallest (i.e. the first) element of all the lists. Once we have the smallest element, we can put it in the merged list. Following a similar pattern, we can then find the next smallest element of all the lists to add it to the merged list.

The best data structure that comes to mind to find the smallest number among a set of ‚ÄòK‚Äô numbers is a Heap. Let‚Äôs see how can we use a `heap` to find a better algorithm.

We can insert the first element of each array in a Min Heap.
After this, we can take out the smallest (top) element from the heap and add it to the merged list.
After removing the smallest element from the heap, we can insert the next element of the same list into the heap.
We can repeat steps 2 and 3 to populate the merged list in sorted order.

- Code :tada:
```java
import java.util.*;

class ListNode {
  int value;
  ListNode next;

  ListNode(int value) {
    this.value = value;
  }
}

class MergeKSortedLists {

  public static ListNode merge(ListNode[] lists) {
    PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>((n1, n2) -> n1.value - n2.value);

    // put the root of each list in the min heap
    for (ListNode root : lists)
      if (root != null)
        minHeap.add(root);

    // take the smallest (top) element form the min-heap and add it to the result; 
    // if the top element has a next element add it to the heap
    ListNode resultHead = null, resultTail = null;
    while (!minHeap.isEmpty()) {
      ListNode node = minHeap.poll();
      if (resultHead == null) {
        resultHead = resultTail = node;
      } else {
        resultTail.next = node;
        resultTail = resultTail.next;
      }
      if (node.next != null)
        minHeap.add(node.next);
    }

    return resultHead;
  }

  public static void main(String[] args) {
    ListNode l1 = new ListNode(2);
    l1.next = new ListNode(6);
    l1.next.next = new ListNode(8);

    ListNode l2 = new ListNode(3);
    l2.next = new ListNode(6);
    l2.next.next = new ListNode(7);

    ListNode l3 = new ListNode(1);
    l3.next = new ListNode(3);
    l3.next.next = new ListNode(4);

    ListNode result = MergeKSortedLists.merge(new ListNode[] { l1, l2, l3 });
    System.out.print("Here are the elements form the merged list: ");
    while (result != null) {
      System.out.print(result.value + " ");
      result = result.next;
    }
  }
}
```

- Time complexity :

Since we‚Äôll be going through all the elements of all arrays and will be removing/adding one element to the heap in each step, the time complexity of the above algorithm will be O(N*logK), where ‚ÄòN‚Äô is the total number of elements in all the ‚ÄòK‚Äô input arrays.

- Space complexity :

The space complexity will be `O(K)` because, at any time, our min-heap will be storing one number from all the ‚ÄòK‚Äô input arrays

## Stack and Queues

### Introduction to Stacks & Queues
<hr>

- Introduction to stack :

A stack is a collection of elements in which the storage and retrieval follows the Last in First Out (LIFO) ordering. This means that the last element added is the element on the top, and the first element added is at the bottom.

A real-life example of Stack could be a stack of books. To get the book that‚Äôs somewhere in the middle, you will have to remove all the books placed at the top of it. Also, the last book you added to the Stack of books is at the top! A typical implementation of stack supports the following operations:

`push()`: adds an element to the stack
`pop()`: removes the last inserted element from the stack
`top()`: Returns the value of the last inserted element from the stack, without removing it
`size()`: Returns the number of elements currently in the stack
`isEmpty()`: Returns true if there are no elements in the stack
`isFull()` : Returns true if the stack is full, false otherwise. This method is implemented only if there is a constraint on the maximum size of the stack

- What are stacks used for? :

Despite the simple implementation, stacks can be used to solve very complex problems! There are many famous algorithms, such as Depth First Search and the Expression Evaluation Algorithm, which harness the functionality of stacks. Stacks are used:

To backtrack to the previous task/state, for example in recursive code
To store a partially completed task, for example, when you are exploring two different paths on a Graph from a point while figuring out the smallest path to the target.

- Introduction to queue :

Similar to the stack, a queue is another linear data structure that stores the elements in a sequential manner. The storage and retrieval in a queue follows the FIFO principle, which is short for First in First Out. In other words, in a queue, the first element inserted is the one that comes out first. You can think of a queue as a pipe with both ends open. Elements enter from one end (back) and leave from the other (front). A perfect real-life example of a queue is a line of people waiting to get a ticket from the booth. A new person joins the line at the end, and the person standing at the front will be the first to get the ticket and leave the line.

- What are queues used for? :

Just like stacks, queues are used widely in searching and sorting algorithms such as the Breadth-First Search algorithm. Most operating systems also perform operations based on a Priority Queue that allows operating systems to switch between appropriate processes. They are also used to store packets on routers in a certain order when a network is congested. Implementing a cache also heavily relies on queues. We generally use Queues when:

We want to prioritize something over another
A resource is shared between multiple devices

- Operations :

The key operations on a queue are as follows:

`enqueue()`: Adds an element to the tail of the queue
`dequeue()`: Removes the element from the front of the queue
`front()`: Returns the element from the front of the queue without actually removing it from the queue
`size()` : Returns the number of elements currently in the queue
`isEmpty()` : Returns true if
`isFull()` : Returns true if the queue is full, false otherwise.

This is only implemented if there is a constraint on the maximum size of the queue

### Implementation of Stack
<hr>

How is Stack implemented in Java? What are some of the main methods that each stack have? That is what we are going to cover in this lesson.

- Introduction :

Every programming language comes with the basic functionality of Stack. In Java, you can use the pre-built class of Stack by importing it to your program. However, you can manually implement a stack and extend its functionality for your use. Stacks can either be implemented using arrays or linked lists. It has yet to be concluded which implementation is more efficient, as both data structures offer different variations of Stack. However, stacks are generally implemented using arrays because it takes less space; we don‚Äôt need to store an additional pointer like in a linked list.

- Implementation :

As we discussed in the previous lesson, a typical Stack must contain the following standard methods:

`push (datatype V)`
`datatype pop()`
`boolean isEmpty()`
`datatype top()`

Before we take a look at these methods one by one, let‚Äôs construct a class of Stack, and create an instance. This class has the following three data members:

the array that will hold all the elements
the size of this array
a variable for the `top` element of Stack.

The following code shows how to construct the `Stack` class:

- Code :tada:
```java

public class Stack <V> {
    private int maxSize;
    private int top;
    private V array[];

    /*
    Java does not allow generic type arrays. So we have used an
    array of Object type and type-casted it to the generic type V.
    This type-casting is unsafe and produces a warning.
    Comment out the line below and execute again to see the warning.
    */
    @SuppressWarnings("unchecked")
    public Stack(int max_size) {
        this.maxSize = max_size;
        this.top = -1; //initially when stack is empty
        array = (V[]) new Object[max_size];//type casting Object[] to V[]
    }

    //returns the maximum size capacity
    public int getMaxSize() {
        return maxSize;
    }

    //returns true if Stack is empty
    public boolean isEmpty(){
        return top == -1;
    }

    //returns true if Stack is full
    public boolean isFull(){
        return top == maxSize -1;
    }

    //returns the value at top of Stack
    public V top(){
        if(isEmpty())
            return null;
        return array[top];
    }

    //inserts a value to the top of Stack
    public void push(V value){
        if(isFull()) {
            System.err.println("Stack is Full!");
            return;
        }
        array[++top] = value; //increments the top and adds value to updated top
    }

    //removes a value from top of Stack and returns
    public V pop(){
        if(isEmpty())
            return null;
        return array[top--]; //returns value and top and decrements the top
    }

}
```
- Complexities of Stack Operations :

Let‚Äôs look at the time complexity of each stack operation.

|Operation | Time Complexity |
| --- | --- |
| isEmpty | O(1) |
| top | O(1) |
| size | O(1) |
| push | O(1) |
| pop | O(1) |

### Implementation of Queue
<hr>

How is Queue implemented in Java? What are some of the main methods that each Queue have? That is what we are going to cover in this lesson.

- Implementation of Queues :

Queues are implemented in many ways. They can be represented by using an array, a linked list, or even a stack. That being said, an array is most commonly used because it‚Äôs the easiest way to implement Queues. As discussed in the previous lesson, a typical Queue must contain the following standard methods:

`enqueue (datatype V)`
`datatype dequeue()`
`boolean isEmpty()`
`boolean isFull()`
`datatype top()`

Before we take a look at these methods one by one, let‚Äôs construct a Queue class with an integer data type and create an instance. We will make a class with 5 data members to hold the following information:

The `array` that will contain all the elements
The `maxSize` is the size of this array
The `front` element of the Queue
The `back` element of the Queue
The `currentSize` of elements in the Queue
The following code shows how to construct the `Stack` class:

- Code :tada:
```java

public class Queue<V> {
    private int maxSize;
    private V[] array;
    private int front;
    private int back;
    private int currentSize;

    /*
    Java does not allow generic type arrays. So we have used an
    array of Object type and type-casted it to the generic type V.
    This type-casting is unsafe and produces a warning.
    Comment out the line below and execute again to see the warning.
    */
    @SuppressWarnings("unchecked")
    public Queue(int maxSize) {
        this.maxSize = maxSize;
        array = (V[]) new Object[maxSize];
        front = 0;
        back = -1;
        currentSize = 0;
    }

    public int getMaxSize() {
        return maxSize;
    }

    public int getCurrentSize() {
        return currentSize;
    }

    public boolean isEmpty() {
        return currentSize == 0;
    }

    public boolean isFull() {
        return currentSize == maxSize;
    }

    public V top() {
        return array[front];
    }

    public void enqueue(V value) {
        if (isFull())
            return;
        back = (back + 1) % maxSize; //to keep the index in range
        array[back] = value;
        currentSize++;
    }

    public V dequeue() {
        if (isEmpty())
            return null;

        V temp = array[front];
        front = (front + 1) % maxSize; //to keep the index in range
        currentSize--;

        return temp;
    }
}
```
If you look at the output of the code, you can see that the elements are enqueued in the back and dequeued from the front. This means that our queue works perfectly.

### Implement Queue Using Stacks
<hr>

- Description :

Suppose we have a `Stack` class that provides all common operations like `push()`, `pop()`, `isEmpty() / empty()`. Using the instances of this `Stack` class, implement a Queue class with its `enqueue()`, `dequeue()`, and `isEmpty()` operations.
```
If the queue is empty, the dequeue() function should return -1.
```
**Solution**
- Runtime complexity :

The runtime complexity of `enqueue()` is linear, O(n).
The runtime complexity of `dequeue()` is constant, O(1).

- Memory complexity :

The memory complexity of this solution is linear, O(n).
Let‚Äôs look at the pseudocode enqueue() and dequeue() operations:

```	
enqueue()
  pop each element from stack1 and push it to stack2.
  push item being enqueued to stack1.
  pop each element back from stack2 and push it to stack1.

dequeue()
  if queue size is 0, 
    return -1

  pop from stack1 and return.
```
- Code :tada:
```java
class QueueUsingStackClass{
  class QueueUsingStack{''
    Stack<Integer> stack1 = new Stack<Integer>(); 
    Stack<Integer> stack2 = new Stack<Integer>(); 

    void enqueue(int data) {
      while(!stack1.isEmpty()) {
          stack2.push(stack1.pop());
      }

      stack1.push(data);

      while(!stack2.isEmpty()) {
          stack1.push(stack2.pop());
      }
    }

    boolean isEmpty() {
      return stack1.size() + stack2.size() == 0;
    }

    int dequeue() {
      if(isEmpty()) {
        return -1;
      }

      return stack1.pop();
    }
  }
  public static void main(String[] args) {
  
    QueueUsingStackClass qsc = new QueueUsingStackClass();
    QueueUsingStackClass.QueueUsingStack qs = qsc.new QueueUsingStack();

    System.out.println("dequeue()" + " = " + qs.dequeue());
    qs.enqueue(3);
    qs.enqueue(6);
    qs.enqueue(16);
    System.out.println("dequeue()" + " = " + qs.dequeue());
    qs.enqueue(8);
    qs.enqueue(4);
    System.out.println("dequeue()" + " = " + qs.dequeue());
  }
}  
```

### Implement Stack Using Queue
<hr>

- Description :

A stack is a data structure in which objects are inserted and removed according to the LIFO (Last In First Out) principle. An item is added at the top of the stack and removed from the top as well. There are two important functionalities in the stack: `push()` and `pop()`.

`push()` means to insert an item at the top of the stack.
`pop()` means to remove an item from the top of the stack.

A queue is a data structure in which objects are inserted and removed according to the FIFO (First In First Out) principle. An item is added at the back of the queue and removed from the front. There are two important functionalities in the queue: `enque()` and `deque()`.

`enqueue()` means to insert an item at the back of the queue.
`dequeue()` means to remove an item from the front of the queue.

Suppose we have a `Queue` class that provides all common operations such as `enqueue()`,`dequeue()`, and `size()`.

Using the instances of this `Queue` class, implement a `Stack` class with its `push()`, `pop()`, and `isEmpty()` operations.
```
If the stack is empty, the pop() function should return -1.
```
**Solution**

- Runtime complexity :

The runtime complexity of this solution for push() is linear, O(n).
The runtime complexity of this solution for pop() is constant, O(1).

- Memory complexity :

The memory complexity of this solution is linear, O(n).

Let‚Äôs see what our push and pop operations look like:
```
push():
  if queue1 is empty, 
    then enqueue on queue1.
  
  otherwise,
    enqueue on queue2 and dequeue all elements from queue1 and push them on queue2. 
    then swap the queue references.

pop():
  if stack size is 0, 
    return -1.
  
  dequeue from queue1 and return.
  ```
- Code :tada:
```java

class StackUsingQueueClass{  
  class StackUsingQueue{

    Queue<Integer> queue1 = new ArrayDeque<Integer>(); 
    Queue<Integer> queue2 = new ArrayDeque<Integer>(); 

    void push(int data) {
      if(queue1.isEmpty()) {
        queue1.add(data);
      }
      else {
        queue2.add(data);
        while(!queue1.isEmpty()) {
          queue2.add(queue1.remove());
        }
        swap_queues();
      }
    }  

    boolean isEmpty() {
      return queue1.size() + queue2.size() == 0;
    }

    int pop() {
      if(isEmpty()) {
        return -1;
      }
      return queue1.remove();
    }

    void swap_queues() {
      Queue<Integer> queue3 = queue1;
      queue1 = queue2;
      queue2 = queue3;
    }
  }
  
  public static void main(String[] args) {
    StackUsingQueueClass sqc = new StackUsingQueueClass();
    StackUsingQueueClass.StackUsingQueue sq = sqc.new StackUsingQueue();
    System.out.println("Pop(): " + sq.pop());
    sq.push(3);
    sq.push(5);
    sq.push(9);
    System.out.println("Pop(): " + sq.pop());
    sq.push(10);
    sq.push(16);
    System.out.println("Pop(): " + sq.pop());
  }    
}
```

### Reversing The First K Elements Of A Queue
<hr>

- Problem Statement :

In this problem, you have to implement the void reverseK(Queue queue, int k) method; this will take a queue and any number (k) as input, and reverse the first k elements of the queue. An illustration is also provided for your understanding.

- Method Prototype :
```
void reverseK(Queue queue, int k)
```
Output :

An array with the first ‚Äúk‚Äù elements reversed.

- Sample Input :
```
Queue = {1,2,3,4,5,6,7,8,9,10} k = 5
```
- Sample Output :
```
result = {5,4,3,2,1,6,7,8,9,10}
```
**Solution: Using a queue**

- Code :tada:
```java

    //1.Push first k elements in queue in a stack.
    //2.Pop Stack elements and enqueue them at the end of queue
    //3.Dequeue queue elements till "k" and append them at the end of queue   
    //4.Dequeue the remaining elements and enqueue them again to append them at end of the queue
    public static void reverseK(Queue queue, int k) {
        if (queue.isEmpty() || k <= 0)
            return;
        Stack stack = new Stack<>(k);

        while(!stack.isFull())
            stack.push(queue.dequeue());

        while(!stack.isEmpty())
            queue.enqueue(stack.pop());

        int size = queue.getCurrentSize();
        for(int i = 0; i < size - k; i++)
            queue.enqueue(queue.dequeue());
    }
```
- Explanation :

`reverseK(queue, k)` takes `queue` as an input parameter, where k represents the number of elements we want to reverse.

Now, moving on to the actual logic of the method. First, check if the queue is empty or if k is a valid non-zero positive number. If either of them is false, then do nothing, just return.

If none of the conditions given above are true, then create a Stack. Start removing first k values from the queue and push them to the stack by using `stack.push(queue.dequeue)`.

Once all the k values have been pushed to the stack, start popping them and enqueueing them to the back of the queue sequentially. We will do this using `queue.enqueue(stack.pop())`. At the end of this step, we will be left with an empty stack, and the `k` reversed elements will be appended to the back of the queue.

Now we need to move these reversed elements to the front of the queue. To do this, we used `queue.enqueue(queue.dequeue())`. Each element is first dequeued from the back.

- Time Complexity :

Overall, kk elements are dequeued, pushed to the stack, popped from it, and then enqueued. Additionally, n-k elements are dequeued and enqueued to the queue. Each push, pop, enqueue, or dequeue operation takes constant time; the time complexity of this method is O(n)O as all nn elements have to be processed with constant-time‚Äã operations.

### Evaluate Postfix Expressions using Stacks
<hr>

- Infix and Postfix Expressions :

In the `infix expression` (the usual convention followed in mathematics), operators like + and * appear between the operands involved in the calculation:
```
6 + 3 * 8 - 4
```
Another convention is the `postfix expression`, where the operators appear after the operands involved in the expression. In postfix, the expression written above will become:
```
6 3 8 * + 4 -
```
The two operands preceding an operator will be used with that operator

From the first block of digits `6 3 8`, we pick the last two, which are `3` and `8`.
Reading the operators from left to right, the first one is *. The expression now becomes `3 * 8`
The next number is `6` while the next operator is +, so we have `6 + 8 * 3`.
The value of this expression is followed by `4`, which is right before -. Hence we have `6 + 8 * 3 - 4`.

- Problem Statement :

In this problem, you have to implement the `evaluatePostFix()` method that will compute a postfix expression given to it in a string.

Input :

The input is a string containing a valid postfix mathematic expression. Each digit is considered a separate number, i.e., there are no double-digit numbers.

Output :

An integer result of the given postfix expression.

Sample Input :
```
expression = "921*-8-4+" # 9 - 2 * 1 - 8 + 4
```
Sample Output :
```
3
```
- Explanation :

1st operation => 2 * 1 = 2, 2nd operation => 9 - 2 = 7, 3rd operation => 7 - 8 = -1, 4th operation => -1 + 4 = 3

**Solution : Numbers as Stack Elements**

Code :tada:
```java

class EvaluatePostfixChallenge {
    public static int evaluatePostFix(String expression) {
        Stack<Integer> stack = new Stack<>(expression.length());
        //1.Scan expression character by character,
		//2.If character is a number push it in stack
		//3.If character is operator then pop two elements from stack
		//perform the operation and put the result back in stack
		//At the end, Stack will contain result of whole expression.
        for (int i = 0; i < expression.length(); i++) {
            char character = expression.charAt(i);

            if (!Character.isDigit(character)) {
                Integer x = stack.pop();
                Integer y = stack.pop();

                switch (character) {
                    case '+':
                        stack.push(y + x);
                        break;
                    case '-':
                        stack.push(y - x);
                        break;
                    case '*':
                        stack.push(y * x);
                        break;
                    case '/':
                        stack.push(y / x);
                        break;
                }

            } else
                stack.push(Character.getNumericValue(character));
        }
        return stack.pop();
    }
	public static void main(String args[]) {
	
		System.out.println(evaluatePostFix("921*-8-4+"));
		//Try your own examples below
		
	}
  
}
```

- Explanation :

We check each character of the string from left to right. If we find a digit, it is pushed into the stack.

If we find an operator, we pop two elements from the stack (there have to be at least two present or else this postfix expression is incorrect) and solve the expression. The resulting value is pushed back into the stack.

The process continues until we reach the end of the string.

- Time Complexity :

Since we traverse the string of n characters once, the time complexity for this algorithm is O(n).

### Next Greater Element using Stack
<hr>

- Problem Statement :

In this problem, you have to implement `int[] nextGreaterElement(int[] arr)` method. For each element in an array, it finds the next greater element in that array.
```
Note: The next greater element is the first element towards the right, which is greater than the current element. For example, in the array [1, 3, 8, 4, 10, 5], the next greater element of 3 is 8, and the next greater element for 8 is 10. To keep it simple, the next greater element for the last or maximum value in the array is -1.
```
In each iteration, we only check the array elements appearing after the current element.

Method Prototype :
```
int[] nextGreaterElement(int[] arr);
```
where arr is an Integer array

- Input :

The input is an integer array

- Output :

An array containing the next greater element of each element from the input array. For the maximum value in the array, the next greater value is `-1`.

- Sample Input :

```
arr = {4,6,3,2,8,1}
```
- Sample Output :
```
result = {6,8,8,8,-1,-1}
```
**Solution: Stack Iteration**

- Code :tada:
```java

class NextGreaterChallenge {
    public static int[] nextGreaterElement(int[] arr) {
        int[] result = new int[arr.length];
        int resultIndex = 0;
        Stack<Integer> stack = new Stack<>(arr.length);
        // iterate for rest of the elements
        for (int i = arr.length - 1; i >= 0; i--) {
            if (!stack.isEmpty()) {
                while (!stack.isEmpty() && stack.top() <= arr[i]) {
                    stack.pop();
                }
            }
            if(stack.isEmpty()){
                result[i] = -1;
            }
            else
                result[i]  = stack.top();
            stack.push(arr[i]);
        }
        return result;
    }

	public static void main(String[] args) 
	{ 
    	int arr[] = {4,6,3,2,8,1,11}; 
		System.out.println(Arrays.toString(arr));
		int result[] = nextGreaterElement(arr); 
		System.out.println(Arrays.toString(result));
	} 
}
```
- Explanation :

Although this method can be solved by brute force using nested loops, a stack can do it much more efficiently.

Using the for-loop on line 7, we iterate the array from the last element to the first one. This is because, at every index, we will have access to the next greater element in the array, which will be present in the stack. Therefore, we just pop from the stack until we get the greater element on top of the stack on lines 8-12. After we have the next greater element on top of the stack, we simply update the value of the current index in the `result` array to the value of the top of the stack (line 17). In case the stack gets empty, we update the value of the current index in the result array to be -1. Finally, we return the `result` array from the function on line 20.

- Time Complexity : 

In the above algorithm, it is observed that every element is pushed on the stack exactly once. Furthermore, since once an element is removed from the stack, it is never re-inserted, every element is removed exactly once, too. That means we perform one push and one pop operation per element, exactly. Therefore, the time complexity of this algorithm will be O(n). This is a significant improvement over the brute force method‚Äôs runtime complexity of O(n2).

### Solve a Celebrity Problem using a Stack
<hr>

- Problem Statement :

In this problem, you have to implement `findCelebrity()` method to find the celebrity in a party (matrix) using a stack. A celebrity is someone that everyone knows, but he/she doesn‚Äôt know anyone at the party.

- Method Prototype :
```
int findCelebrity(int[][] party,int numPeople);
```
Where the party is a reference variable storing a 2D matrix, which has stored all the information about acquaintances, numPeople and the number of people present in the party.

In the party matrix, a particular [row][col] stores acquaintance information for row and col. In other words, if [row][col] == 1, then it means row knows col, and if it‚Äôs zero, then it means row doesn‚Äôt know col. Remember that everyone knows a celebrity, but the celebrity doesn‚Äôt know the people at the party.

An illustration is also provided for your understanding.

- Output :

It will return - 1 if there is no celebrity in the party. Otherwise, it will return the ID or number of celebrities from the party matrix.

- Sample Input :
```
party = { {0,1,1,0}, {1,0,1,1}, {0,0,0,0}, {0,1,1,0}, } numPeople = 4 (Number of rows in party array)
```
- Sample Output- :
```
2 (because row Index = 2 is a celebrity)
```
**Solution**

- Code :tada:
```java
class FindCelebChallenge {
   //returns true if x knows y else returns false
    private static boolean aqStatus(int[][] party, int x, int y) {
        if (party[x][y] == 1) return true;
        return false;
    }

    public static int findCelebrity(int[][] party, int numPeople) {
        Stack<Integer> stack = new Stack<>(numPeople);
        int celebrity = -1;

        //Push all people in stack
        for (int i = 0; i < numPeople; i++) {
            stack.push(i);
        }

        while (!stack.isEmpty()) {

            //Take two people out of stack and check if they know each other
            //One who doesn't know the other, push it back in stack.
            int x = stack.pop();

            if (stack.isEmpty()) {
                celebrity = x;
                break;
            }

            int y = stack.pop();

            if (aqStatus(party, x, y)) {
                //x knows y , discard x and push y in stack
                stack.push(y);
            } else stack.push(x);

        } //end of while

        //At this point we will have last element of stack as celebrity
        //Check it to make sure it's the right celebrity
        for (int j = 0; j < numPeople; j++) {

            //Celebrity knows no one while everyone knows celebrity
            if (celebrity != j && (aqStatus(party, celebrity, j) || !(aqStatus(party, j, celebrity)))) return -1;
        }
        return celebrity;
    }//end of findCelebrity()

    public static void main(String args[]) {
        
        int [][] party1 = {
          {0,1,1,0},
          {1,0,1,1},
          {0,0,0,0},
          {0,1,1,0},   
        };

        int [][] party2 = {
          {0,1,1,0},
          {1,0,1,1},
          {0,0,0,1},
          {0,1,1,0},   
        };

        int [][] party3 = {
          {0,0,0,0},
          {1,0,0,1},
          {1,0,0,1},
          {1,1,1,0},   
        };
        
        System.out.println(findCelebrity(party1,4));
        System.out.println(findCelebrity(party2,4));
        System.out.println(findCelebrity(party3,4));
    }
}
```
- Explanation :

Although this method can be solved by brute force using nested loops, a stack can do it much more efficiently.

First of all, we push all the people to the stack at line number `13 - 15`. Then we pop 2 people from the stack and check if they know each other or not. If someone doesn‚Äôt know, then we push back that person into the stack.

This step repeats until we have only one person in the stack. For the last person, we check if he/she is a celebrity or not at line number `39 - 43`.

- ime Complexity :

The time complexity of this problem is O(n).

### Check For Balanced Parentheses Using A Stack
<hr>

- Problem Statement :

In this problem, you have to implement the `isBalanced()` method, which will take a string containing only curly `{}`, square `[]`, and round `()` parentheses. The method will tell us whether all the parentheses in the string are balanced or not.

For all the parentheses to be balanced, every opening parenthesis must have a closing one. The order in which they appear, also matters. For example,`{[]}` is balanced, but `{[}]` is not.

- Method Prototype :
```
boolean isBalanced(String exp);
```
where exp is an expression containing a combination of parentheses.

- Input :

A string consisting solely of ``(,` )`, `{`, `}`, `[`, and `]`	

- Output :

It returns `False` if the expression doesn‚Äôt have balanced parentheses. If it does, the function returns True.

- Sample Input :
```
exp = "{[({})]}"
```
- Sample Output :
```
True
```
**Solution**

- Code :tada:
```java

class CheckBalancedChallenge {
    public static boolean isBalanced(String exp) {

        //Iterate through the string exp.
        //For each opening parentheses, push it into stack
        //For every closing parenthesis check for its opening parentheses in stack
        //If you can't find the opening parentheses for any closing one then returns false.
        //and after complete traversal of string exp, if there's any opening parentheses left
        //in stack then also return false.
        //At the end return true if you haven't encountered any of the above false conditions.
        Stack<Character> stack = new Stack<>(exp.length());

        for (int i = 0; i < exp.length(); i++) {

            char character = exp.charAt(i);

            if (character == '}' || character == ')' || character == ']') {

                if (stack.isEmpty()) return false;

                if ((character == '}' && stack.pop() != '{') || (character == ')' && stack.pop() != '(') || (character == ']' && stack.pop() != '[')) return false;

            }
            else stack.push(character);

        } //end of for
        if (!stack.isEmpty()) return false;

        return true;
    }

    public static void main(String args[]) {

        System.out.println(isBalanced("{[()]}"));
        System.out.println(isBalanced("[{(}]"));

    }
}
```
- Explanation :

This is a simple algorithm. We iterate over the string, one character at a time. Whenever we find a closing parenthesis, we can deduce that the string is unbalance based on two conditions:

The stack is empty.
The top element in the stack is not an opening parenthesis of the same type.
If any of these conditions are `true`, we return `false`.

If the parenthesis in the string is an opening parenthesis, it is simply pushed into the stack. If all the parentheses are balanced, the stack should be empty by the end because we `pop()` every opening parenthesis once its closing parenthesis is found.

If it is not empty, we return `false`.

- Time Complexity :

We traverse the string `exp` once. So, the time complexity is O(n), where n is the length of the string. Similarly, the space complexity of this algorithm is also O(n) because we have initialized the stack with the size equal to the length of string `exp`.

### Create Stack Where Min() Gives Minimum In Constant Time O(1)

- Problem Statement :

In this problem, you have to implement a new kind of stack called` MinStack`, which can get the minimum value in O(1) time. An illustration is also provided for your understanding.
```
Note: `MinStack` only deals with integer type values.
```
- Method Prototype:
```
int min()
```
- Output :

It returns the minimum number in O(1) time

**Solution**

- Code :tada:
```java

public class MinStack {
    int maxSize;
    Stack<Integer> mainStack;
    Stack<Integer> minStack;
    //constructor
    public MinStack(int maxSize) {
        //We will use two stacks mainStack to hold original values
        //and minStack to hold minimum values. Top of minStack will always
        //be the minimum value from mainStack
        this.maxSize = maxSize;
        mainStack = new Stack<>(maxSize);
        minStack = new Stack<>(maxSize);
    }
    //removes and returns value from stack
    public int pop(){
        //1. Pop element from minStack to make it sync with mainStack,
        //2. Pop element from mainStack and return that value
        minStack.pop();
        return mainStack.pop();
    }
    //pushes value into the stack
    public void push(Integer value){
        //1. Push value in mainStack and check value with the top value of minStack
        //2. If value is greater than top, then push top in minStack
        //else push value in minStack
        mainStack.push(value);
        if(!minStack.isEmpty() && minStack.top() < value)
            minStack.push(minStack.top());
        else
            minStack.push(value);
    }
    //returns minimum value in O(1)
    public int min(){
        return minStack.top();
    }
}
```
- Explanation :

This is a smart solution for obtaining the minimum value in a stack, yet, it isn‚Äôt a very tricky one.

The whole implementation relies on the existence of two stacks, `minStack`, and `mainStack`.

`mainStack` holds the actual stack with all the elements, whereas `minStack` is a stack whose `top` always contains the current minimum value in the stack.

How does it do this? The answer is in the `push` function. Whenever `push` is called, `mainStack` simply inserts the new value at the top. However, `minStack` checks the value being pushed. If `minStack` is empty, this value is pushed into it and becomes the current minimum. If `minStack` already has elements in it, the value is compared with the top element. If the value is lower than the top of `minStack`, it is pushed in and hence, becomes the new minimum. Otherwise, the top remains the same.

Due to all these safeguards we‚Äôve put in place, the `min` function only needs to return the value at the top of `minStack`.

- Time Complexity :

Our goal was to create a stack that returns the minimum value in constant time. As we can see in the algorithm above, the `min` function truly works in O(1).

## Trees

### Introduction to Trees
<hr>

- Introduction :

Trees consist of vertices (nodes) and edges that connect them. An edge is nothing but an ordered pair of nodes. Unlike the linear data structures, trees are hierarchical. We focus on rooted trees, here, in which, one of the nodes has a special significance and is designated the root of the tree.

An edge connects two nodes in a tree. If (u, v) is an edge in a tree, then uu is the parent of v and v is a child of uu. Each node in a tree contains a value. Trees are similar to Graphs (which we‚Äôll cover later), except that a cycle cannot exist in a Tree - they are acyclic. In other words, there is always exactly one path between any two nodes.

- The following terminology is important :

`Root Node` : A node with no parent nodes. Generally, trees don‚Äôt have to have a root. However, rooted trees have one distinguished node and are largely what we will use in this course.

`Parent and Child Nodes` : If uu and vv are nodes in a tree and (u, v)(u,v) is an edge in the tree, then uu is the parent of vv. Conversely, vv is a child of uu. The root node has no parent

`Sibling Node` : Nodes that have the same Parent Node

`Leaf Node` : A node that doesn‚Äôt have any Child Node

`Ancestor Nodes` : All the nodes on the path from a node uu to the root node are ancestors of uu. In other words, ancestors of a node include its parents, grandparents, and so on.

`Descendant Nodes` : The children, grand children and so on, of a node

`Sub-tree` : The tree under a given node is its sub tree. It includes all of its descendants

`Degree of a node` : Total number of children of a node

`Path` : The path between two nodes uu and vv is an alternating sequence of nodes and edges, which starts at uu and ends at vv with edges that are present in the tree and no node is repeated. In a tree, there is exactly one path between any pair of nodes

`Length of a path` : The number of edges in a path

`Depth of a node n` : The length of the path from a node n to the root node. The depth of the root node is 0.

`Level of a node u` : (Depth of a Node uu)+1

`Height of a node uu` : The length of the path from uu to its deepest descendant. The height of the leaf nodes is always 0.

`Height of a Tree` : Height of the root node

- Binary tree :

In a binary tree, any node can have at most two children. A binary tree is called a full (or proper) binary tree if every node other than the leaf nodes has exactly two children. A binary tree is called a complete binary tree if every level, except possibly the last one, are completely filled with nodes and the leaf nodes are as far left as possible.

- Implementation :

There are different ways to implement trees. A common approach is:

Declare a class to represent a node in the tree
If it is a binary tree, have pointers to the left and right children. Otherwise, have a pointer to a list of children
Maintain a root pointer that holds a reference to the root of the tree

### Check If Two Binary Trees Are Identical
<hr>

- Description :

Given the roots of two binary trees, determine if these trees are identical or not. Identical trees have the same layout and data at each node. Consider the following two identical binary trees that have the same layout and data. Trees that have the same data don‚Äôt need to be identical trees. Trees that have the same data may not be structurally identical. For example, if you look at the two trees below, although they have the same data, they are not identical.

**Solution**

- Runtime complexity :

The runtime complexity of this solution is linear, O(n).

- Memory complexity :

The memory complexity of this solution is O(h).

- Explanation :

The recursive solution has O(h)memory complexity as it will consume memory on the stack up to the height of binary tree hh. It will be O(log n) for a balanced tree and, in the worst case, can be O(n).

This problem can be effectively solved using a recursive solution. The base case of recursion for this solution is if both nodes being compared are null, or one of them is null.

Two trees ‚ÄòA‚Äô and ‚ÄòB‚Äô are identical if:

data on their roots is the same or both roots are null left sub-tree of ‚ÄòA‚Äô is identical to the left sub-tree of 'B‚Äô right sub-tree of ‚ÄòA‚Äô is identical to the right sub-tree of 'B‚Äô To solve this problem, we‚Äôll do a depth-first traversal on both trees simultaneously and keep comparing the data at each level.

- Code :tada:
```java

class IdenticalTrees{
  public static boolean areIdentical(BinaryTreeNode root1, BinaryTreeNode root2) {

    if (root1 == null && root2 == null) {
      return true;
    }

    if (root1 != null && root2 != null) {
      return ((root1.data == root2.data) &&
              areIdentical(root1.left, root2.left) &&
              areIdentical(root1.right, root2.right));
    }

    return false;
  }
  
  public static void main(String[] argv) {
    
    List<Integer> input1 = new ArrayList<Integer>();
    input1.add(100);input1.add(50);input1.add(200);input1.add(25);input1.add(125);input1.add(250);
    BinaryTreeNode root1  = BinaryTree.createBST(input1);
    
    List<Integer> input2 = new ArrayList<Integer>();
    input2.add(1);input2.add(2);input2.add(10);input2.add(50);input2.add(180);input2.add(199);
    BinaryTreeNode root2  = BinaryTree.createBST(input2);
    
    BinaryTree.displayLevelOrder(root1);

    BinaryTree.displayLevelOrder(root2);
  
    if (areIdentical(root1, root2)) {
      System.out.println("The trees are identical");
    } else {
      System.out.println("The trees are not identical");
    }
  }
}  
```

### In-Order Iterator For A Binary Tree
<hr>

- Description :

We are given the root node of a binary tree. We have to write an iterator that takes in this root and iterates through the nodes of a binary tree in an in-order way. The expectation is to write two critical methods of any iterator: `hasNext()` and `getNext()`. Consider the following binary tree:

**Solution**

- Runtime complexity :

The runtime complexity of this solution is linear, O(n).

- Memory complexity :

The memory complexity of this solution is O(h).
```
An iterative solution has O(h)O(h) memory complexity as it instantiates a stack that has to store information up to the height of the binary tree (h)(h). It will be O(logn)O(logn) for a balanced tree and, in the worst case, can be O(n)O(n).
```
- Explanation :

We strongly recommend that you read the solution for iterative in-order traversal. It will help you better understand this solution. In this problem, we will need a stack to help us navigate the binary tree in-order and maintain the necessary state. Let‚Äôs see some basic rules for writing this iterator:

A stack will contain the next element at the top, to return on getNext(). hasNext() will only check whether the stack is empty or not. To be able to carry out the aforementioned steps, we will need to set up a stack in the correct state at iterator construction. For that purpose, we push all elements from the root up to the leftmost node of the binary tree at iterator construction. The next task is to implement the getNext() method. It requires returning the next element in in-order traversal. It can be done by just returning the top node from the stack AND also setting up the stack in the correct state for the next getNext() call. For the latter, we look at the right child of the top node of the stack. If it‚Äôs non-null, we push all the nodes from this node to its leftmost node on to the stack.

- Code :tada:
```java

class InorderIterator {
  Stack<BinaryTreeNode> stk = new Stack<BinaryTreeNode>();

  public InorderIterator(BinaryTreeNode root) {
    populateIterator(root);
  }

  public void populateIterator(BinaryTreeNode root) {
    while(root != null) {
      stk.push(root);
      root = root.left;
    }
  }

  public boolean hasNext() {
    return !stk.isEmpty();
  }

  public BinaryTreeNode getNext() {
    if(stk.isEmpty())
      return null;

    BinaryTreeNode rVal = stk.pop();
    BinaryTreeNode temp = rVal.right;
    populateIterator(temp);

    return rVal;
  }
  
  public static String inorderUsingIterator(BinaryTreeNode root) {
    InorderIterator iter = new InorderIterator(root);
    String result = "";
    while (iter.hasNext()) {
      result += iter.getNext().data + " "; 
    }
    return result;
  }

  public static void main(String[] args) {
    
    List<Integer> input = new ArrayList<Integer>();
    input.add(100);input.add(50);input.add(200);input.add(25);input.add(75);input.add(125);input.add(300);
    input.add(12); input.add(35); input.add(60);
    BinaryTreeNode root = BinaryTree.createBST(input);
    System.out.print("Inorder Iterator = ");
    System.out.println(inorderUsingIterator(root));
  }
}
```

### Iterative In-Order Traversal Of Binary Tree
<hr>

- Description :

Given a binary tree, write an iterative algorithm to traverse the tree in-order. Let‚Äôs look at the tree below as an example.

**Solution**

- Runtime complexity:

The runtime complexity of this solution is linear, O(n).

- Memory complexity :

The memory complexity of this solution is O(h).

```
The iterative solution has O(h) memory complexity as it instantiates a stack that has to store information up to the height of binary tree h. It will be O(log n) for a balanced tree and can be O(n) in the worst case.
```
- Explanation :

The in-order traversal of a binary tree starts from the root. First, it visits the left node (L)(L), followed by the current node (N)(N), and finally, the right node (R)(R). This is repeated for every node during the traversal. An easy way to remember this is LNRLNR, the node comes in the middle. For a BST, in-order traversal will always print nodes in an ascending order (based on their values). For an iterative in-order traversal, a stack is used to track the nodes. Here is the pseudocode.
```
initialize the current_node as root.
create an empty stack stk.
Push the current_node in stk and set  current_node = current_node->left until current_node becomes NULL.
if stk is not empty and current_node == NULL then
  Print the top element from stk
  Pop the top element from stk and set current_node = element_popped->right
  go to step 3
if current_node is null and stack is empty then algorithm terminates.
```
- Code :tada:
```java

class InorderIterative{
  static String iterativeInorder(BinaryTreeNode root)
  {
    String result = "";
    if(root == null)
      return result;

    Stack<BinaryTreeNode> stk = new Stack<BinaryTreeNode>();
  
    while(!stk.empty() || root != null)
    {
      if(root != null)
      {
        stk.push(root);
        root = root.left;
        continue;
      }
      result+=stk.peek().data + " ";
      System.out.print(stk.peek().data + " ");
      root = stk.pop().right;
    }
    return result;
  }

  public static void main(String[] args) {
    List<Integer> input = new ArrayList<Integer>();
    input.add(100);input.add(50);input.add(200);input.add(25);input.add(75);input.add(125);input.add(350);
    BinaryTreeNode root = BinaryTree.createBST(input);
    System.out.print("Inorder Iterative Traversal= ");
    iterativeInorder(root);
    System.out.println();
  }
}  
```

### In-order Successor Of Binary Search Tree
<hr>

- Description :

The in-order successor of a node in a binary Search Tree (BST) is the next node in in-order traversal. Write a method to find the in-order successor of a given value ‚Äúd‚Äù in a BST.

**Solution**

- Runtime complexity :

The runtime complexity of this solution is logarithmic, O(logn)O(logn).

- Memory complexity :

The memory complexity of this solution is constant, O(1)O(1).

- Explanation :

A naive solution of this problem would be doing an in-order traversal of the BST. Once dd is found, it returns the next node in the traversal. The runtime of this approach is linear. We can do better than linear in this problem if we closely look at the possible locations of the in-order successor. Let‚Äôs define some rules around that:

Find the value dd in BST.

If dd has a right child then the left most child in right child‚Äôs subtree will be the in-order successor of dd. This would also be the child with the minimum value in that subtree.

If dd has no right child then:

in-order successor is NULL if dd is right most node in the BST i.e. last node in the in-order traversal.
in-order successor is the node with minimum value higher than dd in the parent chain of d.

- Code :tada:
```java
class InorderSuccessor {
  static BinaryTreeNode findMin(BinaryTreeNode root) {
    if(root == null)
      return null;
  
    while(root.left != null) {
      root = root.left;
    }

    return root;
  }

  static BinaryTreeNode inorderSuccessorBST(BinaryTreeNode root, int d) {

    if(root == null) {
      return null;
    }

    BinaryTreeNode successor = null;

    while (root != null) {

      if(root.data < d) {
        root = root.right;
      }
      else if(root.data > d) {
        successor = root;
        root = root.left;
      }
      else {
        if(root.right != null)
        {
          successor = findMin(root.right);
        }
        break;
      }
    }
    return successor;
  }
  
  /// Test Program.
  public static void main(String[] args) {
    ArrayList<Integer> origData = new ArrayList<Integer>();
    origData.add(100);origData.add(50);origData.add(200);origData.add(25);origData.add(75);
    origData.add(125);origData.add(350);
    BinaryTreeNode root = BinaryTree.createBST(origData);

    ArrayList<Integer> allData = BinaryTree.BSTtoArraylist(root);
  
    for (Integer d : origData) {
      BinaryTreeNode successor = inorderSuccessorBST(root, d);
      int i = allData.indexOf(d);
      Integer expectedVal = null;
      if (i < allData.size() - 1) {
        expectedVal = allData.get(i + 1);
      }

      if (successor != null) {
        if (expectedVal.intValue() != successor.data) {
          System.out.println("*******" + d + " ==== " + expectedVal + ", " + successor.data + "*****");
          //System.out.println(expectedVal.intValue() == successor.data);
        }
      }  else {
        //System.out.println(successor == null);
      }    
      if (successor != null) {
        System.out.print("(" + d + ", " + successor.data + ") ");
      } else { 
        System.out.print("(" + d + ", null) ");
      }
    }
  }
}  
```

### In-order Successor Binary Search Tree With Parent Pointers
<hr>

- Description :

An in-order successor of a node in a binary tree is the next node in an in-order traversal. Write a method to find an in-order successor of a given binary tree node in a binary search tree given parent pointers.

**Solution**

- Runtime complexity :

The runtime complexity of this solution is logarithmic, O(logn)O(logn).

- Memory complexity :

The memory complexity of this solution is constant, O(1)O(1).

- Explanation :

We strongly recommend that you try solving the in-order successor in BST without parent pointers first. Here is the algorithm for finding an in-order successor with parent pointers:

If the given node has a right child, then the left most child in the right child‚Äôs subtree will be the in-order successor If the given node has no right child, then: Start going up the parent chain. In this chain, keep going until you find a node who is a left child of its parent. This parent node will be the in-order successor If no such node is found, the in-order successor will be `NULL`

- Code :tada:
```java

class InorderSuccessor{
  static BinaryTreeNode findMinInTree(
      BinaryTreeNode root) {

    if(root == null)
      return null;
  
    while(root.left != null) {
      root = root.left;
    }

    return root;
  }

  static BinaryTreeNode inorderSuccessorBstParentPointer(
      BinaryTreeNode node){
  
    if(node == null) {
      return null;
    }

    if(node.right != null)
    {
      return findMinInTree(node.right);
    }
  
    while(node.parent != null)
    {
      if(node.parent.left == node){
        return node.parent;
      }
      node = node.parent;
    }

    return null;
  }

  static BinaryTreeNode findSuccessor(
    BinaryTreeNode root, int d) {
    while (root != null) {

      if(root.data < d) {
        root = root.right;
      } else if(root.data > d) {
        root = root.left;
      } else {
        return inorderSuccessorBstParentPointer(root);
      }
    }
    return null;
  }
    /// Test Program.
  public static void main(String[] args) {

    List<Integer> input = new ArrayList<Integer>();
    input.add(100);input.add(50);input.add(200);input.add(25);input.add(75);input.add(125);input.add(350);
    BinaryTreeNode root = BinaryTree.createBST(input);

    BinaryTree.populate_parents(root);
  
    for (Integer d : input) {
      BinaryTreeNode successor = findSuccessor(root, d);
      int i = input.indexOf(d);
      Integer expected_val = null;
      if (i < input.size() - 1) {
        expected_val = input.get(i + 1);
      }
      if (successor != null)
        System.out.print("(" + d + ", " + successor.data + ") ");
      else 
        System.out.print("(" + d + ", null) ");
    }
  }
}  
```

### Level Order Traversal Of Binary Tree
<hr>

- Description :

Given the root of a binary tree, display the node values at each level. Node values for all levels should be displayed on separate lines.

**Solution**

- Runtime complexity :

The runtime complexity of this solution is linear, O(n)O(n).

- Memory complexity :

The memory complexity of this solution is linear, O(n)O(n).
```
Iterative solution has O(n)O(n) memory complexity as it instantiates queues that can take space up to n/2n/2 nodes.
```
- Explanation :

Here, we are using two queues: current_queue and next_queue. We push the nodes in both queues alternately based on the current level number.

We‚Äôll dequeue nodes from the current_queue, print the node‚Äôs data, and enqueue the node‚Äôs children to the next_queue. Once the current_queue becomes empty, we have processed all nodes for the current level_number. To indicate the new level, we will print a line break (‚Äô\n‚Äô), swap the two queues, and continue with the above-mentioned logic.

- Code :tada:
```java

class LevelOrderTraversal{
  // Using two queues
  public static String levelOrderTraversal(BinaryTreeNode root) {

    if (root == null) {
      return "";
    }

    String result = "";
  
    ArrayList<Queue<BinaryTreeNode>> queues = 
      new ArrayList<Queue<BinaryTreeNode>>();

    queues.add(new ArrayDeque<BinaryTreeNode>());
    queues.add(new ArrayDeque<BinaryTreeNode>());

    Queue<BinaryTreeNode> current_queue = queues.get(0);
    Queue<BinaryTreeNode> next_queue = queues.get(1);

    current_queue.add(root);
    int level_number = 0;

    while (!current_queue.isEmpty()) {
      BinaryTreeNode temp = current_queue.poll();
      System.out.print(temp.data + " ");
      result += String.valueOf(temp.data) + " ";

      if (temp.left != null) {
        next_queue.add(temp.left);
      }

      if (temp.right != null) {
        next_queue.add(temp.right);
      }

      if (current_queue.isEmpty()) {
        System.out.println();
        ++level_number;
        current_queue = queues.get(level_number % 2);
        next_queue = queues.get((level_number + 1) % 2);
      }
    }
    System.out.println();
    return result;
  }

  public static void main(String[] argv) {
    List<Integer> input = new ArrayList<Integer>();
    input.add(100);input.add(50);input.add(200);input.add(25);input.add(75);input.add(350);
    BinaryTreeNode root = BinaryTree.createBST(input);
    System.out.println("Level Order Traversal:");
    levelOrderTraversal(root);
  }
}  
```

### Valid Binary Search Tree
<hr>

- Description :

Given a Binary Tree, figure out whether it‚Äôs a Binary Search Tree. In a binary search tree, each node‚Äôs key value is smaller than the key value of all nodes in the right subtree, and are greater than the key values of all nodes in the left subtree i.e. L < N < RL<N<R.

**Solution**

- Runtime complexity :

The runtime complexity of this solution is linear, O(n)O(n).

- Memory complexity :

The memory complexity of this solution is linear, O(n)O(n).
```
Recursive solution has O(h)O(h) memory complexity as it will consume memory on the stack up to the height of binary tree h. It will be O(log n)O(logn) for a balanced tree and in the worst case can be O(n)O(n).
```
- Explanation :

There are several ways of solving this problem. A basic algorithm would be to check on each node where the maximum value of its left sub-tree is less than the node‚Äôs data and the minimum value of its right sub-tree is greater than the node‚Äôs data. This is highly inefficient as for each node, both of its left and right sub-trees are explored.

Another approach would be to do a regular in-order traversal and in each recursive call, pass maximum and minimum bounds to check whether the current node‚Äôs value is within the given bounds. This approach is efficient compared to the one above.

- Code :tada:
```java

class IsBST{
  private static boolean isBstRec(BinaryTreeNode root, int min_value, int max_value) {

    if (root == null) {
      return true;
    }

    if (root.data < min_value || root.data > max_value) {
      return false;
    }

    return isBstRec(root.left, min_value, root.data) &&
           isBstRec(root.right, root.data, max_value);
  }

  public static boolean isBst(BinaryTreeNode root) {
    return isBstRec(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
  }
 
  public static void main(String[] argv) {
    BinaryTreeNode root = new BinaryTreeNode(100);
    BinaryTree.insert(root, 50);
    BinaryTree.insert(root, 200);
    BinaryTree.insert(root, 25);
    // Add a node at an incorrect position
    BinaryTree.insertInorderBinaryTree(root, 125);
    BinaryTree.insert(root, 150);
    BinaryTree.insert(root, 300);
    
    BinaryTree.displayInorder(root);
    System.out.println();
    System.out.println(Boolean.toString(isBst(root)));
  }
}
```

### Serialize/Deserialize Binary Tree
<hr>

- Description :

Serialize a binary tree to a file and then deserialize it back to a tree so that the original and the deserialized trees are identical. Serialize: write the tree in a file.

Deserialize: read from a file and reconstruct the tree in memory.
```
There is no restriction regarding the format of a serialized stream, therefore you can serialize it in any efficient format. However, after deserializing the tree from the stream, it should be exactly like the original tree.
```
**Solution**

- Runtime complexity :

The runtime complexity of this solution is linear, O(n)O(n).

- Memory complexity :

The memory complexity of this solution is Logarithmic, O(logn)O(logn).
```
The recursive solution has O(h)O(h) memory complexity as it will consume memory on the stack up to the height of the binary tree h. It will be O(logn)O(logn) for a balanced tree and in the worst case can be O(n)O(n).
```
- Explanation :

There can be multiple approaches to serialize and deserialize the tree. One approach is to perform a depth-first traversal and serialize individual nodes to the stream. We‚Äôll use a pre-order traversal here. We‚Äôll also serialize some marker to represent a null pointer to help deserialize the tree. Consider the below binary tree as an example. Markers (M*) have been added in this tree to represent null nodes. The number with each marker i.e. 11 in M1M1, 22 in M2M2, merely represents the relative position of a marker in the stream. When deserializing the tree we‚Äôll again use the pre-order traversal and create a new node for every non-marker node. Encountering a marker indicates that it was a null node.

- Code :tada:
```java

class SerializeBT{
  private static final int MARKER = Integer.MIN_VALUE;

  public static void serialize(BinaryTreeNode node,
      ObjectOutputStream stream)
          throws java.io.IOException {
    if (node == null) {
      stream.writeInt(MARKER);
      return;
    }

    stream.writeInt(node.data);
    serialize(node.left, stream);
    serialize(node.right, stream);
  }

  public static BinaryTreeNode deserialize(
      ObjectInputStream stream) throws java.io.IOException {
    int val = stream.readInt();
    if (val == MARKER) {
      return null;
    }

    BinaryTreeNode node = new BinaryTreeNode(val);
    node.left = deserialize(stream);
    node.right = deserialize(stream);
    return node;
  }
  
  public static void main(String[] args) {
    try{
      List<Integer> input = new ArrayList<Integer>();
      input.add(100);input.add(50);input.add(200);input.add(25);input.add(75);input.add(125);input.add(350);
      BinaryTreeNode root = BinaryTree.createBST(input);

      BinaryTree.displayLevelOrder(root);

      ByteArrayOutputStream baostream = new ByteArrayOutputStream();
      ObjectOutputStream stream = new ObjectOutputStream(baostream);
      serialize(root, stream);
      stream.close();

      ByteArrayInputStream baistream = new ByteArrayInputStream(
        baostream.toByteArray());
      ObjectInputStream  istream = new ObjectInputStream(baistream);
      BinaryTreeNode rootDeserialized = deserialize(istream);

      System.out.println("\nResult:");
      BinaryTree.displayLevelOrder(rootDeserialized);
    }
    catch(Exception ex){
      ex.printStackTrace();
    }
  }
}  
```

### Minimum Depth Of A Binary Tree
<hr>

- Description :

Find the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node.

**Solution**

- Runtime complexity :

The time complexity of the above algorithm is O(N)O(N), where ‚ÄòN‚Äô is the total number of nodes in the tree. This is due to the fact that we traverse each node once.

- Memory complexity :

The space complexity of the above algorithm will be O(N)O(N) which is required for the queue. Since we can have a maximum of N/2N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N)O(N) space to store them in the queue.

- Explanation :

This problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. The only difference will be, instead of keeping track of all the nodes in a level, we will only track the depth of the tree. As soon as we find our first leaf node, that level will represent the minimum depth of the tree.

- Code :tada:
```java

import java.util.*;

class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

  TreeNode(int x) {
    val = x;
  }
};

class MinimumBinaryTreeDepth {
  public static int findDepth(TreeNode root) {
    if (root == null)
      return 0;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int minimumTreeDepth = 0;
    while (!queue.isEmpty()) {
      minimumTreeDepth++;
      int levelSize = queue.size();
      for (int i = 0; i < levelSize; i++) {
        TreeNode currentNode = queue.poll();

        // check if this is a leaf node
        if (currentNode.left == null && currentNode.right == null)
          return minimumTreeDepth;

        // insert the children of current node in the queue
        if (currentNode.left != null)
          queue.add(currentNode.left);
        if (currentNode.right != null)
          queue.add(currentNode.right);
      }
    }
    return minimumTreeDepth;
  }

  public static void main(String[] args) {
    TreeNode root = new TreeNode(12);
    root.left = new TreeNode(7);
    root.right = new TreeNode(1);
    root.right.left = new TreeNode(10);
    root.right.right = new TreeNode(5);
    System.out.println("Tree Minimum Depth: " + MinimumBinaryTreeDepth.findDepth(root));
    root.left.left = new TreeNode(9);
    root.right.left.left = new TreeNode(11);
    System.out.println("Tree Minimum Depth: " + MinimumBinaryTreeDepth.findDepth(root));
  }
}
```

### All Paths For A Sum
<hr>

- Description :

Given a binary tree and a number ‚ÄòS‚Äô, find all paths from root-to-leaf such that the sum of all the node values of each path equals ‚ÄòS‚Äô.

**Solution**

- Runtime complexity :

The time complexity of the above algorithm is O(N^2), where ‚ÄòN‚Äô is the total number of nodes in the tree. This is due to the fact that we traverse each node once (which will take O(N), and for every leaf node, we might have to store its path (by making a copy of the current path) which will take O(N).

We can calculate a tighter time complexity of O(NlogN) from the space complexity discussion below.

- Memory complexity :

If we ignore the space required for the allPaths list, the space complexity of the above algorithm will be O(N) in the worst case. This space will be used to store the recursion stack. The worst-case will happen when the given tree is a linked list (i.e., every node has only one child).

- Explanation :

This problem follows the Binary Tree Path Sum pattern. We can follow the same DFS approach. There will be two differences:

Every time we find a root-to-leaf path, we will store it in a list.
We will traverse all paths and will not stop processing after finding the first path.

- Code :tada:
```java

import java.util.*;

class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

  TreeNode(int x) {
    val = x;
  }
};

class FindAllTreePaths {
  public static List<List<Integer>> findPaths(TreeNode root, int sum) {
    List<List<Integer>> allPaths = new ArrayList<>();
    List<Integer> currentPath = new ArrayList<Integer>();
    findPathsRecursive(root, sum, currentPath, allPaths);
    return allPaths;
  }

  private static void findPathsRecursive(TreeNode currentNode, int sum, List<Integer> currentPath,
      List<List<Integer>> allPaths) {
    if (currentNode == null)
      return;

    // add the current node to the path
    currentPath.add(currentNode.val);

    // if the current node is a leaf and its value is equal to sum, save the current path
    if (currentNode.val == sum && currentNode.left == null && currentNode.right == null) {
      allPaths.add(new ArrayList<Integer>(currentPath));
    } else {
      // traverse the left sub-tree
      findPathsRecursive(currentNode.left, sum - currentNode.val, currentPath, allPaths);
      // traverse the right sub-tree
      findPathsRecursive(currentNode.right, sum - currentNode.val, currentPath, allPaths);
    }

    // remove the current node from the path to backtrack, 
    // we need to remove the current node while we are going up the recursive call stack.
    currentPath.remove(currentPath.size() - 1);
  }

  public static void main(String[] args) {
    TreeNode root = new TreeNode(12);
    root.left = new TreeNode(7);
    root.right = new TreeNode(1);
    root.left.left = new TreeNode(4);
    root.right.left = new TreeNode(10);
    root.right.right = new TreeNode(5);
    int sum = 23;
    List<List<Integer>> result = FindAllTreePaths.findPaths(root, sum);
    System.out.println("Tree paths with sum " + sum + ": " + result);
  }
}
```

### Count Paths For A Sum
<hr>

- Description :

Given a binary tree and a number ‚ÄòS‚Äô, find all paths in the tree such that the sum of all the node values of each path equals ‚ÄòS‚Äô. Please note that the paths can start or end at any node but all paths must follow direction from parent to child (top to bottom).

**Solution**

- Runtime complexity :

The time complexity of the above algorithm is O(N^2) in the worst case, where ‚ÄòN‚Äô is the total number of nodes in the tree. This is due to the fact that we traverse each node once, but for every node, we iterate the current path. The current path, in the worst case, can be O(N) (in the case of a skewed tree). But, if the tree is balanced, then the current path will be equal to the height of the tree, i.e., O(logN). So the best case of our algorithm will be O(NlogN).

- Space complexity :

The space complexity of the above algorithm will be O(N). This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child). We also need O(N) space for storing the currentPath in the worst case.

Overall space complexity of our algorithm is O(N).

- Explanation :

This problem follows the Binary Tree Path Sum pattern. We can follow the same DFS approach. But there will be four differences:

We will keep track of the current path in a list which will be passed to every recursive call.

Whenever we traverse a node we will do two things:

Add the current node to the current path.
As we added a new node to the current path, we should find the sums of all sub-paths ending at the current node. If the sum of any sub-path is equal to ‚ÄòS‚Äô we will increment our path count.
We will traverse all paths and will not stop processing after finding the first path.

Remove the current node from the current path before returning from the function. This is needed to Backtrack while we are going up the recursive call stack to process other paths.

- Code :tada:
```java

import java.util.*;

class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

  TreeNode(int x) {
    val = x;
  }
};

class CountAllPathSum {
  public static int countPaths(TreeNode root, int S) {
    List<Integer> currentPath = new LinkedList<>();
    return countPathsRecursive(root, S, currentPath);
  }

  private static int countPathsRecursive(TreeNode currentNode, int S, List<Integer> currentPath) {
    if (currentNode == null)
      return 0;

    // add the current node to the path
    currentPath.add(currentNode.val);
    int pathCount = 0, pathSum = 0;
    // find the sums of all sub-paths in the current path list
    ListIterator<Integer> pathIterator = currentPath.listIterator(currentPath.size());
    while (pathIterator.hasPrevious()) {
      pathSum += pathIterator.previous();
      // if the sum of any sub-path is equal to 'S' we increment our path count.
      if (pathSum == S) {
        pathCount++;
      }
    }

    // traverse the left sub-tree
    pathCount += countPathsRecursive(currentNode.left, S, currentPath);
    // traverse the right sub-tree
    pathCount += countPathsRecursive(currentNode.right, S, currentPath);

    // remove the current node from the path to backtrack, 
    // we need to remove the current node while we are going up the recursive call stack.
    currentPath.remove(currentPath.size() - 1);

    return pathCount;
  }

  public static void main(String[] args) {
    TreeNode root = new TreeNode(12);
    root.left = new TreeNode(7);
    root.right = new TreeNode(1);
    root.left.left = new TreeNode(4);
    root.right.left = new TreeNode(10);
    root.right.right = new TreeNode(5);
    System.out.println("Tree has path: " + CountAllPathSum.countPaths(root, 11));
  }
}
```
## Trie

### Introduction to Tries
<hr>

Tries are prefix trees that are used to store strings for fast retrieval. A node in a Trie represents a letter in an alphabet. For insertion, the tree takes a string as input and then creates a new node for each character of that string/word. The node registered for the last character of the string/word is marked as the `end of word`. A Boolean variable is usually used to do this.

- Trie node :

A typical Node in a Trie consists of two data members:

children: An array that consists of the children nodes. The size of this array depends on the number of alphabets (26 for the English language). By default, all elements are set to Null.
isEndWord: A flag to indicate the end of a word. It is set to false by default and is only updated when an end of the word is observed during insertion.

- Methods :

The following are the common operations performed by tries:

`Insert(String)` : Inserts a string into the trie.
`Delete(String)` : Deletes an existing string from the trie.
`Search(String)` : Searches if the input string exists as a complete word in the trie.
`prefixSearch(String)` : Searches if the prefix string exists in the trie.

### Total Number Of Words In A Trie
<hr>

- Problem Statement :

Implement the `totalWords(TrieNode root)` function to find the total number of words in a Trie.

- Function Prototype :

```
int totalWords(TrieNode root);
```
Here, root is the root node of the Trie.

- Output :

It returns the total number of words in the Trie

- Sample Input :
```
String keys[] = {"the", "a", "there", "answer", "any", "by", "bye", "their","abc"};
```
- Sample Output :
```
9
```
- Explanation :

There are 9 words total in the given keys array.

**Solution: Increment Recursively**

- TrieNode.java :tada:
```java

class TrieNode
{
    TrieNode[] children;
    boolean isEndWord; //will be true if the node represents the end of word
    static final int ALPHABET_SIZE = 26; //Total # of English Alphabets = 26
    TrieNode(){
        this.isEndWord = false;
        this.children = new TrieNode[ALPHABET_SIZE]; 
    }

    //Function to mark the currentNode as Leaf
    public void markAsLeaf(){
        this.isEndWord = true;
    }

    //Function to unMark the currentNode as Leaf
    public void unMarkAsLeaf(){
        this.isEndWord = false;
    }
}
```
- Trie.java :tada:
```java

class Trie {
    private TrieNode root; //Root Node

    //Constructor
    Trie() {
        root = new TrieNode();
    }

    //Function to get the index of a character 't'
    public int getIndex(char t) {
        return t - 'a';
    }

    //Function to get root
    public TrieNode getRoot() {
        return root;
    }

    //Function to insert a key in the Trie
    public void insert(String key) {
        //Null keys are not allowed
        if (key == null) {
            return;
        }
        key = key.toLowerCase(); //Keys are stored in lowercase
        TrieNode currentNode = this.root;
        int index = 0; //to store character index

        //Iterate the Trie with given character index,
        //If it is null, then simply create a TrieNode and go down a level
        for (int level = 0; level < key.length(); level++) {
            index = getIndex(key.charAt(level));

            if (currentNode.children[index] == null) {
                currentNode.children[index] = new TrieNode();
            }
            currentNode = currentNode.children[index];
        }
        //Mark the end character as leaf node
        currentNode.markAsLeaf();
    }

    //Function to search given key in Trie
    public boolean search(String key) {

        if (key == null) return false; //Null Key

        key = key.toLowerCase();
        TrieNode currentNode = this.root;
        int index = 0;

        //Iterate the Trie with given character index,
        //If it is null at any point then we stop and return false
        //We will return true only if we reach leafNode and have traversed the
        //Trie based on the length of the key

        for (int level = 0; level < key.length(); level++) {
            index = getIndex(key.charAt(level));
            if (currentNode.children[index] == null) return false;
            currentNode = currentNode.children[index];
        }
        if (currentNode.isEndWord) return true;

        return false;
    }

    //Helper Function to return true if currentNode does not have any children
    private boolean hasNoChildren(TrieNode currentNode) {
        for (int i = 0; i < currentNode.children.length; i++) {
            if ((currentNode.children[i]) != null)
                return false;
        }
        return true;
    }

    //Recursive function to delete given key
    private boolean deleteHelper(String key, TrieNode currentNode, int length, int level) {
        boolean deletedSelf = false;

        if (currentNode == null) {
            System.out.println("Key does not exist");
            return deletedSelf;
        }

        //Base Case: If we have reached at the node which points to the alphabet at the end of the key.
        if (level == length) {
            //If there are no nodes ahead of this node in this path
            //Then we can delete this node
            if (hasNoChildren(currentNode)) {
                currentNode = null;
                deletedSelf = true;
            }
            //If there are nodes ahead of currentNode in this path
            //Then we cannot delete currentNode. We simply unmark this as leaf
            else {
                currentNode.unMarkAsLeaf();
                deletedSelf = false;
            }
        } else {
            TrieNode childNode = currentNode.children[getIndex(key.charAt(level))];
            boolean childDeleted = deleteHelper(key, childNode, length, level + 1);
            if (childDeleted) {
                //Making children pointer also null: since child is deleted
                currentNode.children[getIndex(key.charAt(level))] = null;
                //If currentNode is leaf node that means currntNode is part of another key
                //and hence we can not delete this node and it's parent path nodes
                if (currentNode.isEndWord) {
                    deletedSelf = false;
                }
                //If childNode is deleted but if currentNode has more children then currentNode must be part of another key.
                //So, we cannot delete currenNode
                else if (!hasNoChildren(currentNode)) {
                    deletedSelf = false;
                }
                //Else we can delete currentNode
                else {
                    currentNode = null;
                    deletedSelf = true;
                }
            } else {
                deletedSelf = false;
            }
        }
        return deletedSelf;
    }

    //Function to delete given key from Trie
    public void delete(String key) {
        if ((root == null) || (key == null)) {
            System.out.println("Null key or Empty trie error");
            return;
        }
        deleteHelper(key, root, key.length(), 0);
    }

}
```
- main.java :tada:
```java

class numWords{
  public static int totalWords(TrieNode root){
    int result = 0;

    // Leaf denotes end of a word
    if (root.isEndWord)
      result++;

    for (int i = 0; i < 26; i++)
      if (root.children[i] != null)
        result += totalWords(root.children[i]);
    return result;
  }


  public static void main(String args[]){
    // Input keys (use only 'a' through 'z' and lower case)
    String keys[] = {"the", "a", "there", "answer", "any",
                     "by", "bye", "their","abc"};

    System.out.println("Keys: "+ Arrays.toString(keys));

    // Construct trie
    Trie t = new Trie();

    for (int i = 0; i < keys.length ; i++)
      t.insert(keys[i]);

    System.out.println(totalWords(t.getRoot()));
  }
}
```
- Explanation :

It‚Äôs a pretty straightforward algorithm. Starting from the root, we visit each branch recursively. Whenever a node is found with its isEndWord set to true, the result variable is incremented by 1.

- Time Complexity :

Since the array under each node is traversed and checked for children, the worst-case running time is O(d^h), where dd is the size of the alphabet (26 for English), and hh is the length of the longest word in the dictionary. Note that dd is constant, but hh is not. So, this is an exponential function.

### Find All Of The Words In A Trie
<hr>

- Problem Statement :

In this problem, you have to implement the `findWords()` function to return all of the words stored in the Trie in alphabetically sorted order.

- Function Prototype :
```
ArrayList< String > findWords(TrieNode root);
```
Here, root is the root node of the Trie.

- Output :

In the form of an ArrayList, it returns all of the words stored in the Trie in lexicographic order.

- Sample Input :
```
String keys[] = {"the", "a", "there", "answer", "any", "by", "bye", "their","abc"};
```
- Sample Output :
```
"a", "abc","answer","any","by","bye","the","their","there"
```
- Explanation :

There are 9 words total in the given keys array, so we just need to iterate the Trie and return all of the words present in it.

**Solution: Recursion**

- main.java :tada:
```java
class TrieWords {
  //Recursive Function to generate all words
  public static void getWords(TrieNode root, ArrayList < String > result, int level, char[] str) {
    //Leaf denotes end of a word
    if (root.isEndWord) {
      //current word is stored till the 'level' in the character array
      String temp = "";
      for (int x = 0; x < level; x++) {
        temp += Character.toString(str[x]);
      }
      result.add(temp);
    }
    for (int i = 0; i < 26; i++) {
      if (root.children[i] != null) {
        //Non-null child, so add that index to the character array
        str[level] = (char)(i + 'a');
        getWords(root.children[i], result, level + 1, str);
      }
    }
  }
  public static ArrayList < String > findWords(TrieNode root) {
    ArrayList < String > result = new ArrayList < String > ();
    char[] chararr = new char[20];
    getWords(root, result, 0, chararr);
    return result;
  }

  public static void main(String args[]) {
    // Input keys (use only 'a' through 'z' and lower case)
    String keys[] = {"the", "a", "there", "answer", "any",
                     "by", "bye", "their","abc"};
    String output[] = {"Not present in trie", "Present in trie"};
    Trie t = new Trie();

    System.out.println("Keys: "+ Arrays.toString(keys));

    // Construct trie

    for (int i = 0; i < keys.length ; i++)
      t.insert(keys[i]);


    ArrayList < String > list = findWords(t.getRoot());
    for(int i = 0; i < list.size(); i++) {
      System.out.println(list.get(i));
    }


  }
}
```
- Explanation :

The findWords(root) function contains a result ArrayList which will contain all the words in the trie. word is a character array in which node characters are added one by one to keep track of all the alphabets in the same recursive call.

`getWords()` is our recursive function which begins from the root and traverses every node. Whenever a node is the end of a word, `temp`(containing the character array) is converted into a string and inserted into `result`.

Since `word` cannot be reset before recording every new word, we simply update the values at each index using `level`.

- Time Complexity :

As the algorithm traverses all the nodes, its run time is O(n) where n is the number of nodes in the trie.

### Sort The Elements Of An Array Using A Trie
<hr>

- Problem Statement :

In this problem, you have to implement the `sortArray()` function to sort the elements of an array of strings in alphabetical order.

- Function Prototype :
```
ArrayList< String > sortArray(String []arr);
```
Here, arr is a String array

- Output :

It returns the given array, sorted and in an ArrayList form.

- Sample Input :
```
String keys[] = {"the", "a", "there", "answer", "any", "by", "bye", "their","abc"};
```
- Sample Output :
```
{"a", "abc", "answer", "any", "by", "bye", "the", "their", "there"}
```
- Explanation :

There are 9 words total in the given keys array, so we need to sort them alphabetically before returning the list with strings in sorted order.

**Solution: Pre-Order Traversal**

- main.java :tada:
```java

class Sort {
  //Recursive Function to generate all words in alphabetic order
  public static void getWords(TrieNode root, ArrayList < String > result, int level, char[] str) {
    //Leaf denotes end of a word
    if (root.isEndWord) {
      //current word is stored till the 'level' in the character array
      String temp = "";
      for (int x = 0; x < level; x++) {
        temp += Character.toString(str[x]);
      }
      result.add(temp);
    }

    for (int i = 0; i < 26; i++) {
      if (root.children[i] != null) {
        //Non-null child, so add that index to the character array
        str[level] = (char)(i + 'a');
        getWords(root.children[i], result, level + 1, str);
      }
    }
  }
  public static ArrayList<String> sortArray(String[] arr){
    ArrayList<String> result = new ArrayList<String>();

    //Creating Trie and Inserting words from array
    Trie trie = new Trie();
    for (int x = 0; x < arr.length ; x++)
      trie.insert(arr[x]);

    char[] char_arr = new char[20];
    getWords(trie.getRoot(),result,0,char_arr);  
    return result;
  }

  public static void main(String args[]) {
    // Input keys (use only 'a' through 'z' and lower case)
    String keys[] = {"the", "a", "there", "answer", "any",
                     "by", "bye", "their","abc"};
    
    Trie t = new Trie();

    System.out.println("Keys: "+ Arrays.toString(keys));

    // Construct trie

    for (int i = 0; i < keys.length ; i++)
      t.insert(keys[i]);


    ArrayList < String > list = sortArray(keys);
    for(int i = 0; i < list.size(); i++) {
      System.out.println(list.get(i));
    }


  }

```
- Explanation :

This exercise is very similar to Challenge 2, except the fact that you have to create the trie yourself.

Since the children array for each node stores alphabets in alphabetical order, the tree itself is ordered from top to bottom. All we need to do is make a pre-order traversal (think of a as the left most child and z as the right most child) and store the words in a list just like we did in the previous challenge.

- Time Complexity :

We first insert the nodes into the graph and then traverse all the existing nodes. Hence, the bottleneck worst case time complexity is O(n).

### Word Formation From A Given Dictionary Using A Trie
<hr>

- Problem Statement :

In this problem, you have to implement the `isFormationPossible()` function to find whether or not the given word can be formed by combining two words from the dictionary.

- Function Prototype :
```
boolean isFormationPossible(String[] dict, String word);
```
Here, dict is the dictionary containing unique strings, and word is a string.

- Output :

It returns `true` if the given word can be generated by combining two words from the given dictionary; otherwise, it returns `false`.

- Sample Input :
```
String dict[] = {"the" ,"hello", "there", "answer", "any", "Dragon", "world", "their", "inc"}; String word = "helloworld"
```
- Sample Output :
```
true
```
- Explanation :

`helloworld` can be formed by combining hello and world from the ‚Äúdictionary‚Äù, so the program returns true.

**Solution: Iterative Word Matching**

- main.java :tada:
```java

class DictWord {
  
  public static boolean isFormationPossible(String[] dict,String word) {
    if(word.length() < 2 || dict.length < 2) {
      return false;
    }

    //Create Trie and insert dictionary elements in it
    Trie trie = new Trie();

    for(int i = 0; i < dict.length; i++) {
      trie.insert(dict[i]);
    }

    for(int i = 0; i < word.length(); i++) {
      //Slice the word into two strings in each iteration
      String first = word.substring(0, i);
      String second = word.substring(i, word.length());

      //If both substrings are present in the trie, the condition is fulfilled
      if(trie.search(first) && trie.search(second)) {
        return true;
      }
    }

    return false;
  }

  public static void main(String args[]){
    // Input dict (use only 'a' through 'z' and lower case)
    String dict[] = {"the", "hello", "there", "answer","any", "dragon", "world", "their",  "inc"};

    Trie t = new Trie();

    System.out.println("Keys: "+ Arrays.toString(dict));

    if(isFormationPossible(dict, "helloworld"))
      System.out.println("true");
    else
      System.out.println("false");

  }


}
```
- Explanation :

At the beginning of the algorithm, all the keys are inserted into the trie. Then, we iterate through the word, dividing it into two strings called first and second. We search for the two strings in the trie and if both are found, word can be formed with two words from the given dict.

- Time Complexity :

We perform the insert operation m times for a dictionary of size m. After that, the search operation runs on the word in the sequence:
```
"h", "he", "hel", "hell"...
```
If the length of the average word in the dictionary is h, then the time taken for trie construction is O(m*h). Let the length of the word being searched be n. Then, the complexity for this turns out to be n^2. Hence, the total time complexity is O(mh + n ^ 2).. We could argue that in some applications, the trie is constructed only once, and then many many lookups are performed. So, the cost of trie creation is amortized over all the lookups. In that case, the complexity reduces to O(n ^ 2).

## Recursion

### Find The Greatest Common Divisor

In this lesson, we will find the greatest common divisor (GCD) using recursion.

- What is GCD?

The GCD of two integers is the largest integer that can fully divide both numbers, without a remainder.

- How to find GCD?

- What is the greatest common divisor of 54 and 36?

The number 3636 can be expressed as a product of two integers in several different ways:

36x1=18x2= 12x3 = 9x4

Thus the divisors for 3636 are 1, 2, 3, 4, 6, 9, 12, 18, 36.

The number 5454 can be expressed as a product of two integers in several different ways:

54√ó1=27√ó2=18√ó3=9√ó6

Thus the divisors for 5454 are 1, 2, 3, 6, 9, 18, 27.

Common divisors are 1, 2, 3, 6, 9 and 18.

The greatest common divisor or GCD for 36 and 54 is 18.

- Problem Statement :

Write a recursive method that computes the GCD of two integers.

- Instructions :

1. The method should take two integers as input. Their GCD is to be computed, as input.
2. The method should return the GCD of the two integers as output.
3. The method should be recursive.

- Sample Input :
```
24, 18
```
- Sample Output :
```
6
```
**Solution: Greatest Common Divisor**

- Code :tada:
```java

class Solution {
    
    public static int gcd(int num1, int num2) {

        // Base case
        if (num1 == num2) {
            return num1;
        }
        // Recursive case
        if (num1 > num2) {
            return gcd(num1-num2, num2);
        }
        else {
            return gcd(num1, num2-num1);
        }
    }

    public static void main( String args[] ) {
        int x = 56;
        int y = 42;
        int result = gcd(x, y);
        System.out.println("The GCD of " + x + " and " + y + " is:");
        System.out.println(result);
    }
}
```
- Understanding the Code :

In the code above, the method `gcd` is a recursive method, since it makes a recursive call in the method body. Below is an explanation of the above code.

- Driver Method :

In the `main` code, we have defined three integer variables: `x`,`y` and `result`.
`result` stores the greatest common divisor of `x` and `y` when the `gcd` method is called.
Line 23 prints `result`.

- Recursive Method :

The return type of this method is an integer because GCD of two numbers is always an integer.

The method takes two integer input arguments `num1` and `num2`.

- Base Case :

The base case of the method is defined in the `if` block, from line 6 to line 8. When `num2` is equal to `num1`	, the method returns `num1`.

- Recursive Case  ;

If the base case does not compute to be true, the method checks the second `if` condition on line 10, to be true i.e `if num1 > num2`. If it computes to true, a recursive call is made with parameters `num1-num2` and `num2` respectively.

If the base case and the `if` condition does not compute to true, the method automatically goes to the `else` statement on line 14, where `num2 > num1` and a recursive call is made with parameters num1 and num2-num1 respectively.

In the case above the recursive calls will be as follows:

1. First recursive call will be for `num2 > num1` and will be `gcd(56-42,42)`.

2. Second recursive call will be for `num1 > num2` and will be `ogcd(14,42-14)`.

3. Third recursive call will be for `num1 > num2` and will be `gcd(14,28-14)`.

After the third recursive call, the `num1==num2` condition computes to true. So, the base case is reached; hence the method returns `num1`, which is equal to 14.

### Check For Prime Number
<hr>

In this lesson, you will implement the code to check if a number is prime using recursion.

- What is a prime number? :

A `prime number` is a number greater than 1 that has only two divisors: 1 and the number itself. The first few prime numbers are:

2, 3, 5, 7, 11, 13, 17, 19, 23, 29, .....

`Composite` numbers are numbers that are not prime; that is, they have divisors other than 11 and itself

4, 6, 8, 9, 10, 12, 14, 15, 16, 18.......
```
The numbers 11 and 00 are neither prime nor composite.
```
All the numbers are either prime or composite, except for 00 and 11.

- Problem Statement :

Write a recursive method, named `isPrime()` that checks if a number is prime or not.

- Instructions :

1. The method should take two integers as input.
2. The method should return Boolean, meaning it will return true if the number is prime or return false if the number is not prime.
3. The method should be recursive.

- Sample Input :
```
7
```
- Sample Output :
```
true
```
**Solution: Greatest Common Divisor**

- Code :tada:
```java

class ChallengeClass {

    public static boolean isPrime(int num, int i) {

        // First base case
        if (num < 2) {
            return false;
        }
        // Second base case
        else if (i == 1) {
            return true;
        }
        // Third base case
        else if (num%i == 0) {
            return false;
        }
        // Recursive case
        else {
            return isPrime(num, i-1);
        }
    }

    public static void main( String args[] ) {
        int input = 13;
        boolean result = isPrime(input, input/2);

        // Print if the number is prime
        if (result == true) {
            System.out.println(input + " is a prime number");
        }
        // Prints if the number is NOT a prime number
        else {
            System.out.println(input + " is NOT a prime number");
        }
    } 
}
```
- Understanding the Code :

In the code above, the method isPrime is a recursive method, since it makes a recursive call in the method body. Below is an explanation of the above code:

- Driver Method :

In the `main` code, we have defined an integer variable, named `input`, and a boolean variable, named `result`.

The `result` variable stores the output of the `isPrime` method.

The first parameter in the `isPrime` method is the number to be tested, named `input`. The second parameter, `input/2`, is half of the number to be tested.

Lines 28-30 and lines 32-34 print the type - prime or not prime - of the number based on the value of the `result`.

Recursive Method
The return type of this method is `Boolean` since we want to check if the number is prime or not and it takes the two integers, `num` and `i`, as input parameters.
`num` is the number to be tested and i is the iterator and has the initial value of `num/2` when the method is called in the main code.
`i` has the initial value of `num/2` because all the factors of a number are less than equal to the half of that number. We iterate through all the numbers less than or equal to `i` to check if `num` has a factor. We use the `%` operator to check for the factors of num.

- Base Case :

We have defined the base cases for the method in the `if` conditions.

1. In the first `if` condition, line 6-8, when `num` is less than or equal to 22, the method returns `num` since 00 and 11 are not prime numbers.

2. In the second `if` condition, lines 10-12, when `i` is equal to 11, the method returns true. We will need to understand the recursive part of the method to understand this base case.

3. In the third `if` condition, lines 14-16, if the number has a divisor other than 11, the method returns false. To check for this condition, we use the `%` operator to compute modulo of `num` with the iterator `i`.

- Recursive Case :

When the `if` condition for any of the base cases does not compute to be true, the method enters the `else` block, lines 18-20, where it makes a recursive call.

In the recursive call, the `isPrime` method is called with the first parameter, `num`, and the second parameter, `i-1`.

In this case, the recursive calls will be as follows:

1. The first recursive call will be `isPrime(13,5)`.

2. The second recursive call will be `sPrime(13,4)`.

3. The third recursive call will be `isPrime(13,3)`.

4. The fourth recursive call will be `isPrime(13,2)`.

5. The fifth recursive call will be `isPrime(13,1)` which is when the second base case condition will be reached since `i==1`.

The method will return `true` since `num` is divisible by 1 only.

### How does the Decimal to Binary Conversion work?
<hr>

Given a decimal number, you keep dividing the number by 2 until it reaches 1 and records the remainder at each step.

The resulting list of remainders is the equivalent binary number for your decimal number. For example:

- Input : 
```
1919
```
- Output : 
```
1001110011
```
The illustration below explains the process of converting a decimal number to a binary number.

- Problem Statement :

You are required to write a method that takes a decimal integer as an input parameter and returns its equivalent binary number.

It is recommended that you try solving the exercise yourself before viewing the solution.

- Code Implementation :tada:
```java
class ChallengeClass {

    public static int decimalToBinary(int decimalNum) {
        if (decimalNum == 0) {
            return 0;
        }
        else {
            return (decimalNum%2 + 10*decimalToBinary(decimalNum/2));
        }
    }

    public static void main( String args[] ) {
        int input = 27;
        int result = decimalToBinary(input);
        System.out.println("The binary form of " + input + " is: " + result);
    }

}
```
- Understanding the Code :

In the code above, the method `decimalToBinary` is a recursive method, since it calls itself in the method body. Below is an explanation of the above code:

- Driver Method :

In the main code, we have defined an integer variable, an input that represents the decimal number that is to be converted to its equivalent binary number.
The method `decimalToBinary` is called on line 14 and takes the input variable as its argument.
The `System.out.println` command on line 15 prints the integer value that returned from the `decimalToBinary method`.

- Recursive Method :

The return type of this method is `int` because the binary number will always be in an integer form.
The `decimalToBinary` method takes in only one integer, `decimalNum`, as its input parameter.
It consists of a base case and a recursive case both of which are explained in detail below.

- Base Case :

The base case makes sure that if or when the decimalNum equals to 0, the method should return 0 and get terminated.

- Recursive Case :

If the base condition does not compute to be true, the method enters the `else` block at line 8, where the recursive call is made. Note that in this recursive call, the input parameter is `(decimalNum/2)`, which is multiplied by 10, and `decimalNum%2` is further added to it.
With each recursive call, the input parameter decimalNum is reduced by half.
Let us look at the example below to see why this input parameter is passed to the recursive function.

Let the decimal number be 9.

1. 9 % 2 (which equals to 1) + 10 * (9/2)
2. 4 % 2 (which equals to 0) + 10 *‚àó (4/2)
3. 2 % 2 (which equals to 0) + 10 * (2/2)
4. 1 % 2 (which equals to 1) + 10 *‚àó (1/2)

The output equivalent binary number for 9 is thus 1001.

### Is this String a Palindrome?
<hr>

This challenge aims to test your understanding of recursion by finding out whether or not a string is a palindrome.

- Problem Statement :

Before we dive into the challenge, let‚Äôs learn what a palindrome is. A palindrome is a string of words that reads the same both backward and forwards, for example, the words mom or dad, or even madam. In this problem, we will have to determine whether or not the given string is a palindrome! The method where you must write your code is provided in the code snippet below. You may not change the input parameters.
```
SAMPLE INPUT: dad SAMPLE OUTPUT: true SAMPLE INPUT: Hello SAMPLE OUTPUT: false
```
- Code Implementation :tada:
```java

class ChallengeClass {

    public static boolean isPalindrome(String text) {
        if (text.length() == 0) {
            return false;
        }
        else if (text.length() == 1) {
            return true;
        }
        else {
            if (text.charAt(0) == text.charAt(text.length()-1)) {
                return isPalindrome(text.substring(1, text.length()-1));
            }
        }
        return false;
    }

    public static void main( String args[] ) { 
        String input1 = "hello";
        String input2 = "dadad";
        boolean answer1 = isPalindrome(input1);
        boolean answer2 = isPalindrome(input2);
        System.out.println("Is " + input1 + " a Palindrome? = " + answer1);
        System.out.println("Is " + input2 + " a Palindrome? = " + answer2);
    }  
}
```
- Understanding the Code :

Every recursive code has two methods: the recursive method and the main method.

- Driver Method :

The recursive method is called within the driver method. Let‚Äôs first look at what it does-from line 19 to 24.

In this driver method, we have two strings where `input2` is a palindrome and `input1` is not.

For each string, it calls on the `isPalindrome` method, and the output of the method is stored in the `answer1` and `answer2` variables.

On line 23 and line 24, the code prints `true` if the string is a palindrome. If it is not a palindrome, the code prints `false`.

- Recursive Method :

Now let‚Äôs look at the recursive method: the `isPalindrome` method from line 4 to line 15. Within this recursive method, you have the base case and the recursive case.

The method itself returns a `boolean` value, either true or false - depending on whether or not a palindrome is found. The method takes in one argument, the string `text` which is the string that will be checked.

- Base Case :

The first if condition from line 4 to line 6 states that if the length of the given `text` is zero, it will return false indicating that the string is not a palindrome since it is an empty string.
The else if condition from line 7 to line 9 states that if a given `text` has a length equal to one, it will return true, since a string of a single letter string is technically a palindrome.

- Recursive Case :

Provided that the above-mentioned base conditions are not met, we move to the recursive case.

The if condition on line 11 examines if the first and last index is equal. The function `isPalindrome` is called again-but with changed parameters. This enables the function to check if the entire string is a palindrome, rather than the first and last index.

We then pass the modified string `text` to the recursive method, `isPalindrome` comparing values from the next index using `substring(1, text.length()-1)` from the start of the string while decrementing the last index by 1.

The recursive call, in this case, terminates when the values mentioned above become equal, or when the values do not match at their respective positions.

### Insert Values In A Binary Search Tree
<hr>

This lesson will help you learn recursion through trees.

- What is a Binary Search Tree? :

A Binary Search Tree (BST) is a hierarchical data structure that consists of vertices connected through edges. The value of the left node is less than the value of the parent node, and the value of the right node is greater than the value of the parent node.

- Code Implementation :tada:
```java

class binarySearchTree {

	//Variables
	private Node root;
	//Getter for Root
	public Node getRoot() {
		return root;
	}
  //Setter for root
  public void setRoot(Node root) {
		this.root = root;
	}


	//Recursive function to insert a value in BST 
	public Node recursive_insert(Node currentNode, int value) {

		//Base Case
		if (currentNode == null) {
			return new Node(value);
		}

		if (value < currentNode.getData()) {
			//Iterate left sub-tree
			currentNode.setLeftChild(recursive_insert(currentNode.getLeftChild(), value));
		} else if (value > currentNode.getData()) {
			//Iterate right sub-tree
			currentNode.setRightChild(recursive_insert(currentNode.getRightChild(), value));
		} else {
			// value already exists
			return currentNode;
		}

		return currentNode;
	}

	//Function to call recursive insert
	public boolean insert(int value) {

		root = recursive_insert(this.root, value);
		return true;
	}

	//Function to check if Tree is empty or not  
	public boolean isEmpty() {
		return root == null; //if root is null then it means Tree is empty
	}

	//Just for Testing purpose 
	public void printTree(Node current) {

		if (current == null) return;

		System.out.print(current.getData() + ",");
		printTree(current.getLeftChild());
		printTree(current.getRightChild());

	}
	public static void main(String args[]) {

		binarySearchTree bsT = new binarySearchTree();
		bsT.insert(6);
		bsT.insert(4);
		bsT.insert(8);
		bsT.insert(5);
		bsT.insert(2);
		bsT.insert(8);
		bsT.insert(12);
		bsT.insert(10);
		bsT.insert(14);
		bsT.printTree(bsT.getRoot());

	}
}
```
- Understanding the Code :

In the code above, the function `insert` is a recursive method, since it makes a recursive call. Below is an explanation of the above code:

- Driver Method :

In the `main` code, we create a new `BST`, named bsT.
The `insert()` method is subsequently called to insert nodes in the BST.
The `printTree()` method prints the BST using the in order traversal. It takes the root of the tree to begin the traversal. This process just prints the BST in order.

- Recursive Method :

The return type of the `insert()` function is `boolean` and takes one integer type of input parameter `value` which depicts the value of the node. This method calls the actual recursive method `recursive_insert` that takes two input parameters. The first is `currentNode` of type `Node`. The second parameter `value` is the integer to be inserted in the BST. We will discuss the `recursive_insert` method below.

- Base Case :

We have defined a base case for the method in first if condition between lines 19 to 21.
If the value of the `currentNode` is `null`, meaning there is an available space for the child node to be inserted, a `new Node()` is created with the `value`.

- Recursive Case :

If the base case condition is not met and the `value` to be inserted is less than the value of `currentNode.getData()`, the function enters the second `if` condition, line 25, where it makes a recursive call.
In this process, the `recursive_insert` method is recursively .The first parameter is `currentNode.getLeftChild()` and the second parameter is `value`.
If the method has not reached the base and the inserted `value` is greater than the value of `currentNode.getData()`, the function enters the other `else if` condition, in line 26-28, where, it makes a recursive call.
In this `else if` condition, the `recursive_insert` method is called. The first parameter is `currentNode.getRightChild()` and the second parameter is `value`.
If all the above conditions are not met, we reach the `else` condition from lines 29 to 31 which returns the `currentNode` since the defined `value` already exists.
Line 34 returns the `currentNode` after being inserted into its position.
Subsequent recursive calls will continually be made until the first parameter equals `null`, which ensures the availability of a position for the new node. The new node is then added to its corresponding position.

## DP

### 0/1 Knapsack
<hr>

- Introduction :

Given the weights and profits of ‚ÄòN‚Äô items, we are asked to put these items in a knapsack that has a capacity ‚ÄòC‚Äô. The goal is to get the maximum profit from the items in the knapsack. Each item can only be selected once, as we don‚Äôt have multiple quantities of any item.

Let‚Äôs take Merry‚Äôs example, who wants to carry some fruits in the knapsack to get maximum profit. Here are the weights and profits of the fruits:

Items: { Apple, Orange, Banana, Melon } Weights: { 2, 3, 1, 4 } Profits: { 4, 5, 3, 7 } Knapsack capacity: 5

Let‚Äôs try to put different combinations of fruits in the knapsack, such that their total weight is not more than 5:

Apple + Orange (total weight 5) => 9 profit Apple + Banana (total weight 3) => 7 profit Orange + Banana (total weight 4) => 8 profit Banana + Melon (total weight 5) => 10 profit

This shows that Banana + Melon is the best combination, as it gives us the maximum profit and the total weight does not exceed the capacity.

- Problem Statement :

Given two integer arrays to represent weights and profits of ‚ÄòN‚Äô items, we need to find a subset of these items which will give us maximum profit such that their cumulative weight is not more than a given number ‚ÄòC‚Äô. Write a function that returns the maximum profit. Each item can only be selected once, which means either we put an item in the knapsack or skip it.

- Basic Solution :

A basic brute-force solution could be to try all combinations of the given items (as we did above), allowing us to choose the one with maximum profit and a weight that doesn‚Äôt exceed ‚ÄòC.‚Äô Take the example of four items (A, B, C, and D), as shown in the diagram below. To try all the combinations, our algorithm will look like:
```
for each item 'i' 
  create a new set which INCLUDES item 'i' if the total weight does not exceed the capacity, and 
     recursively process the remaining capacity and items
  create a new set WITHOUT item 'i', and recursively process the remaining items 
return the set from the above two sets with higher profit 
```
- Code :tada:
```java
class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    return this.knapsackRecursive(profits, weights, capacity, 0);
  }

  private int knapsackRecursive(int[] profits, int[] weights, int capacity, int currentIndex) {
    // base checks
    if (capacity <= 0 || currentIndex >= profits.length)
      return 0;

    // recursive call after choosing the element at the currentIndex
    // if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this
    int profit1 = 0;
    if( weights[currentIndex] <= capacity )
        profit1 = profits[currentIndex] + knapsackRecursive(profits, weights,
                capacity - weights[currentIndex], currentIndex + 1);

    // recursive call after excluding the element at the currentIndex
    int profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + 1);

    return Math.max(profit1, profit2);
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```
The above algorithm‚Äôs time complexity is exponential O(2^n), where ‚Äòn‚Äô represents the total number of items. This can also be confirmed from the above recursion tree. As we can see that we will have a total of ‚Äò31‚Äô recursive calls ‚Äì calculated through (2^n) + (2^n) ‚àí 1, which is asymptotically equivalent to O(2^n). The space complexity is O(n). This space will be used to store the recursion stack. Since our recursive algorithm works in a depth-first fashion, which means, we can‚Äôt have more than ‚Äòn‚Äô recursive calls on the call stack at any time.

- Top-down Dynamic Programming with Memoization :

We can use memoization to overcome the overlapping sub-problems. To reiterate, memoization is when we store the results of all the previously solved sub-problems and return the results from memory if we encounter a problem that has already been solved.

Since we have two changing values (`capacity` and `currentIndex`) in our recursive function `knapsackRecursive()`, we can use a two-dimensional array to store the results of all the solved sub-problems. As mentioned above, we need to store results for every sub-array (i.e., for every possible index ‚Äòi‚Äô) and for every possible capacity ‚Äòc‚Äô.

- Code :tada:
```java

class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    Integer[][] dp = new Integer[profits.length][capacity + 1];
    return this.knapsackRecursive(dp, profits, weights, capacity, 0);
  }

  private int knapsackRecursive(Integer[][] dp, int[] profits, int[] weights, int capacity,
      int currentIndex) {

    // base checks
    if (capacity <= 0 || currentIndex >= profits.length)
      return 0;

    // if we have already solved a similar problem, return the result from memory
    if(dp[currentIndex][capacity] != null)
      return dp[currentIndex][capacity];

    // recursive call after choosing the element at the currentIndex
    // if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this
    int profit1 = 0;
    if( weights[currentIndex] <= capacity )
        profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights,
                capacity - weights[currentIndex], currentIndex + 1);

    // recursive call after excluding the element at the currentIndex
    int profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + 1);

    dp[currentIndex][capacity] = Math.max(profit1, profit2);
    return dp[currentIndex][capacity];
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```
What is the time and space complexity of the above solution?
Since our memoization array `dp[profits.length][capacity+1]` stores the results for all the subproblems, we can conclude that we will not have more than NC subproblems (where ‚ÄòN‚Äô is the number of items and ‚ÄòC‚Äô is the knapsack capacity). This means that our time complexity will be O(NC).

The above algorithm will be using O(NC) space for the memoization array. Other than that, we will use O(N)O(N) space for the recursion call-stack. So the total space complexity will be O(NC + N), which is asymptotically equivalent to O(N*C).

- Bottom-up Dynamic Programming :

Let‚Äôs try to populate our `dp[][]` array from the above solution, working in a bottom-up fashion. Essentially, we want to find the maximum profit for every sub-array and for every possible capacity. `This means, dp[i][c] will represent the maximum knapsack profit for capacity ‚Äòc‚Äô calculated from the first ‚Äòi‚Äô items`.

So, for each item at index ‚Äòi‚Äô (0 <= i < items.length) and capacity ‚Äòc‚Äô (0 <= c <= capacity), we have two options:

Exclude the item at index ‚Äòi‚Äô. In this case, we will take whatever profit we get from the sub-array excluding this item => `dp[i-1][c]`.
Include the item at index ‚Äòi‚Äô if its weight is not more than the capacity. In this case, we include its profit plus whatever profit we get from the remaining capacity and from remaining items => `profits[i] + dp[i-1][c-weights[i]]`
Finally, our optimal solution will be maximum of the above two values:
```
dp[i][c] = max (dp[i-1][c], profits[i] + dp[i-1][c-weights[i]])
```
- Code :tada:

Here is the code for our bottom-up dynamic programming approach:
```java

class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    // basic checks
    if (capacity <= 0 || profits.length == 0 || weights.length != profits.length)
      return 0;

    int n = profits.length;
    int[][] dp = new int[n][capacity + 1];

    // populate the capacity=0 columns, with '0' capacity we have '0' profit
    for(int i=0; i < n; i++)
      dp[i][0] = 0;

    // if we have only one weight, we will take it if it is not more than the capacity
    for(int c=0; c <= capacity; c++) {
      if(weights[0] <= c)
        dp[0][c] = profits[0];
    }

    // process all sub-arrays for all the capacities
    for(int i=1; i < n; i++) {
      for(int c=1; c <= capacity; c++) {
        int profit1= 0, profit2 = 0;
        // include the item, if it is not more than the capacity
        if(weights[i] <= c)
          profit1 = profits[i] + dp[i-1][c-weights[i]];
        // exclude the item
        profit2 = dp[i-1][c];
        // take maximum
        dp[i][c] = Math.max(profit1, profit2);
      }
    }

    // maximum profit will be at the bottom-right corner.
    return dp[n-1][capacity];
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```
The above solution has a time and space complexity of O(N*C), where ‚ÄòN‚Äô represents total items, and ‚ÄòC‚Äô is the maximum capacity.

- How to find the selected items?

As we know that the final profit is at the bottom-right corner; therefore, we will start from there to find the items that will be going in the knapsack.

As you remember, at every step, we had two options: include an item or skip it. If we skip an item, then we take the profit from the remaining items (i.e., from the cell right above it); if we include the item, then we jump to the remaining profit to find more items.

Let‚Äôs write a function to print the set of items included in the knapsack.

- Code :tada:

```java
import java.util.*;

class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    // base checks
    if (capacity <= 0 || profits.length == 0 || weights.length != profits.length)
      return 0;

    int n = profits.length;
    int[][] dp = new int[n][capacity + 1];

    // populate the capacity=0 columns, with '0' capacity we have '0' profit
    for(int i=0; i < n; i++)
      dp[i][0] = 0;

    // if we have only one weight, we will take it if it is not more than the capacity
    for(int c=0; c <= capacity; c++) {
      if(weights[0] <= c)
        dp[0][c] = profits[0];
    }

    // process all sub-arrays for all the capacities
    for(int i=1; i < n; i++) {
      for(int c=1; c <= capacity; c++) {
        int profit1= 0, profit2 = 0;
        // include the item, if it is not more than the capacity
        if(weights[i] <= c)
          profit1 = profits[i] + dp[i-1][c-weights[i]];
        // exclude the item
        profit2 = dp[i-1][c];
        // take maximum
        dp[i][c] = Math.max(profit1, profit2);
      }
    }

    printSelectedElements(dp, weights, profits, capacity);
    // maximum profit will be at the bottom-right corner.
    return dp[n-1][capacity];
  }

 private void printSelectedElements(int dp[][], int[] weights, int[] profits, int capacity){
   System.out.print("Selected weights:");
   int totalProfit = dp[weights.length-1][capacity];
   for(int i=weights.length-1; i > 0; i--) {
     if(totalProfit != dp[i-1][capacity]) {
       System.out.print(" " + weights[i]);
       capacity -= weights[i];
       totalProfit -= profits[i];
     }
   }

   if(totalProfit != 0)
     System.out.print(" " + weights[0]);
   System.out.println("");
 }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

### Equal Subset Sum Partition
<hr>

- Problem Statement :

Given a set of positive numbers, find if we can partition it into two subsets such that the sum of elements in both the subsets is equal.

- Example 1 :
```
Input: {1, 2, 3, 4} Output: True Explanation: The given set can be partitioned into two subsets with equal sum: {1, 4} & {2, 3}
```
- Example 2 :
```
Input: {1, 1, 3, 4, 7} Output: True Explanation: The given set can be partitioned into two subsets with equal sum: {1, 3, 4} & {1, 7}
```
- Example 3 :
```
Input: {2, 3, 4, 6} Output: False Explanation: The given set cannot be partitioned into two subsets with equal sum.
```
- Basic Solution :

This problem follows the 0/1 Knapsack pattern. A basic brute-force solution could be to try all combinations of partitioning the given numbers into two sets to see if any pair of sets has an equal sum.

Assume if S represents the total sum of all the given numbers, then the two equal subsets must have a sum equal to S/2. This essentially transforms our problem to: "Find a subset of the given numbers that has a total sum of S/2".

So our brute-force algorithm will look like:
```j 
for each number 'i' 
  create a new set which INCLUDES number 'i' if it does not exceed 'S/2', and recursively 
      process the remaining numbers
  create a new set WITHOUT number 'i', and recursively process the remaining items 
return true if any of the above sets has a sum equal to 'S/2', otherwise return false
```
- Code :tada:
```java

class PartitionSet {

  public boolean canPartition(int[] num) {
    int sum = 0;
    for (int i = 0; i < num.length; i++)
      sum += num[i];

    // if 'sum' is a an odd number, we can't have two subsets with equal sum
    if(sum % 2 != 0)
      return false;

    return this.canPartitionRecursive(num, sum/2, 0);
  }

  private boolean canPartitionRecursive(int[] num, int sum, int currentIndex) {
    // base check
    if (sum == 0)
      return true;

    if(num.length == 0 || currentIndex >= num.length)
      return false;

    // recursive call after choosing the number at the currentIndex
    // if the number at currentIndex exceeds the sum, we shouldn't process this
    if( num[currentIndex] <= sum ) {
      if(canPartitionRecursive(num, sum - num[currentIndex], currentIndex + 1))
        return true;
    }

    // recursive call after excluding the number at the currentIndex
    return canPartitionRecursive(num, sum, currentIndex + 1);
  }

  public static void main(String[] args) {
    PartitionSet ps = new PartitionSet();
    int[] num = {1, 2, 3, 4};
    System.out.println(ps.canPartition(num));
    num = new int[]{1, 1, 3, 4, 7};
    System.out.println(ps.canPartition(num));
    num = new int[]{2, 3, 4, 6};
    System.out.println(ps.canPartition(num));
  }
}
```
The time complexity of the above algorithm is exponential O(2^n), where ‚Äòn‚Äô represents the total number. The space complexity is O(n), this memory which will be used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use memoization to overcome the overlapping sub-problems. As stated in previous lessons, memoization is when we store the results of all the previously solved sub-problems return the results from memory if we encounter a problem that has already been solved.

Since we need to store the results for every subset and for every possible sum, therefore we will be using a two-dimensional array to store the results of the solved sub-problems. The first dimension of the array will represent different subsets and the second dimension will represent different ‚Äòsums‚Äô that we can calculate from each subset. These two dimensions of the array can also be inferred from the two changing values (sum and currentIndex) in our recursive function `canPartitionRecursive()`.

- Code :tada:

Here is the code for Top-down DP with memoization:
```java

class PartitionSet {

  public boolean canPartition(int[] num) {
    int sum = 0;
    for (int i = 0; i < num.length; i++)
      sum += num[i];

    // if 'sum' is a an odd number, we can't have two subsets with equal sum
    if (sum % 2 != 0)
      return false;

    Boolean[][] dp = new Boolean[num.length][sum / 2 + 1];
    return this.canPartitionRecursive(dp, num, sum / 2, 0);
  }

  private boolean canPartitionRecursive(Boolean[][] dp, int[] num, int sum, int currentIndex) {
    // base check
    if (sum == 0)
      return true;

    if (num.length == 0 || currentIndex >= num.length)
      return false;

    // if we have not already processed a similar problem
    if (dp[currentIndex][sum] == null) {
      // recursive call after choosing the number at the currentIndex
      // if the number at currentIndex exceeds the sum, we shouldn't process this
      if (num[currentIndex] <= sum) {
        if (canPartitionRecursive(dp, num, sum - num[currentIndex], currentIndex + 1)) {
          dp[currentIndex][sum] = true;
          return true;
        }
      }

      // recursive call after excluding the number at the currentIndex
      dp[currentIndex][sum] = canPartitionRecursive(dp, num, sum, currentIndex + 1);
    }

    return dp[currentIndex][sum];
  }

  public static void main(String[] args) {
    PartitionSet ps = new PartitionSet();
    int[] num = { 1, 2, 3, 4 };
    System.out.println(ps.canPartition(num));
    num = new int[] { 1, 1, 3, 4, 7 };
    System.out.println(ps.canPartition(num));
    num = new int[] { 2, 3, 4, 6 };
    System.out.println(ps.canPartition(num));
  }
}
```
The above algorithm has time and space complexity of O(N*S), where ‚ÄòN‚Äô represents total numbers and ‚ÄòS‚Äô is the total sum of all the numbers.

- Bottom-up Dynamic Programming :

Let‚Äôs try to populate our `dp[][]` array from the above solution, working in a bottom-up fashion. Essentially, we want to find if we can make all possible sums with every subset.`This means, dp[i][s] will be ‚Äòtrue‚Äô if we can make sum ‚Äòs‚Äô from the first ‚Äòi‚Äô numbers`.

So, for each number at index ‚Äòi‚Äô (0 <= i < num.length) and sum ‚Äòs‚Äô (0 <= s <= S/2), we have two options:

Exclude the number. In this case, we will see if we can get ‚Äòs‚Äô from the subset excluding this number: `dp[i-1][s]`
Include the number if its value is not more than ‚Äòs‚Äô. In this case, we will see if we can find a subset to get the remaining sum: `dp[i-1][s-num[i]]`
If either of the two above scenarios is true, we can find a subset of numbers with a sum equal to ‚Äòs‚Äô.

- Code :tada:

Here is the code for our bottom-up dynamic programming approach:
```java

class PartitionSet {

  public boolean canPartition(int[] num) {
    int n = num.length;
    // find the total sum
    int sum = 0;
    for (int i = 0; i < n; i++)
      sum += num[i];

    // if 'sum' is a an odd number, we can't have two subsets with same total
    if(sum % 2 != 0)
      return false;

    // we are trying to find a subset of given numbers that has a total sum of ‚Äòsum/2‚Äô.
    sum /= 2;

    boolean[][] dp = new boolean[n][sum + 1];

    // populate the sum=0 column, as we can always have '0' sum without including any element
    for(int i=0; i < n; i++)
      dp[i][0] = true;

    // with only one number, we can form a subset only when the required sum is equal to its value
    for(int s=1; s <= sum ; s++) {
      dp[0][s] = (num[0] == s ? true : false);
    }

    // process all subsets for all sums
    for(int i=1; i < n; i++) {
      for(int s=1; s <= sum; s++) {
        // if we can get the sum 's' without the number at index 'i'
        if(dp[i-1][s]) {
          dp[i][s] = dp[i-1][s];
        } else if (s >= num[i]) { // else if we can find a subset to get the remaining sum
          dp[i][s] = dp[i-1][s-num[i]];
        }
      }
    }

    // the bottom-right corner will have our answer.
    return dp[n-1][sum];
  }

  public static void main(String[] args) {
    PartitionSet ps = new PartitionSet();
    int[] num = {1, 2, 3, 4};
    System.out.println(ps.canPartition(num));
    num = new int[]{1, 1, 3, 4, 7};
    System.out.println(ps.canPartition(num));
    num = new int[]{2, 3, 4, 6};
    System.out.println(ps.canPartition(num));
  }
}
```
The above solution has time and space complexity of O(N*S), where ‚ÄòN‚Äô represents total numbers and ‚ÄòS‚Äô is the total sum of all the numbers.

### Target Sum
<hr>

- Problem Statement :

Given a set of positive numbers (non zero) and a target sum ‚ÄòS‚Äô. Each number should be assigned either a ‚Äò+‚Äô or ‚Äò-‚Äô sign. We need to find out total ways to assign symbols to make the sum of numbers equal to target ‚ÄòS‚Äô.

- Example 1 :
```
Input: {1, 1, 2, 3}, S=1 Output: 3 Explanation: The given set has '3' ways to make a sum of '1': {+1-1-2+3} & {-1+1-2+3} & {+1+1+2-3}
```
- Example 2 :
```
Input: {1, 1, 2, 3}, S=1 Output: 3 Explanation: The given set has '3' ways to make a sum of '1': {+1-1-2+3} & {-1+1-2+3} & {+1+1+2-3}
```
**Solution**

This problem follows the `0/1 Knapsack pattern` and can be converted into Count of Subset Sum. Let‚Äôs dig into this.

We are asked to find two subsets of the given numbers whose difference is equal to the given target ‚ÄòS‚Äô. Take the first example above. As we saw, one solution is {+1-1-2+3}. So, the two subsets we are asked to find are {1, 3} & {1, 2} because,
```
(1 + 3) - (1 + 2 ) = 1
```
Now, let‚Äôs say ‚ÄòSum(s1)‚Äô denotes the total sum of set ‚Äòs1‚Äô, and ‚ÄòSum(s2)‚Äô denotes the total sum of set ‚Äòs2‚Äô. So the required equation is:
```
Sum(s1) - Sum(s2) = S
```
This equation can be reduced to the subset sum problem. Let‚Äôs assume that ‚ÄòSum(num)‚Äô denotes the total sum of all the numbers, therefore:
```
Sum(s1) + Sum(s2) = Sum(num)
```
Let‚Äôs add the above two equations:
```
=> Sum(s1) - Sum(s2) + Sum(s1) + Sum(s2) = S + Sum(num)
=> 2 * Sum(s1) =  S + Sum(num)
=> Sum(s1) = (S + Sum(num)) / 2
```
This essentially converts our problem to: ‚ÄúFind count of subsets of the given numbers whose sum is equal to‚Äù,
```
=> (S + Sum(num)) / 2
```
- Code :tada:
```java

Let‚Äôs take the dynamic programming code of Count of Subset Sum and extend it to solve this problem:

class TargetSum {

  public int findTargetSubsets(int[] num, int s) {
    int totalSum = 0;
    for (int n : num){
        totalSum += n;
        if(n < 1) return -1; //invalid input, the problem expects only positive numbers
    }

    // if 's + totalSum' is odd, we can't find a subset with sum equal to '(s + totalSum) / 2'
    if(totalSum < s || (s + totalSum) % 2 == 1)
        return 0;

    return countSubsets(num, (s + totalSum) / 2);
  }

  // this function is exactly similar to what we have in 'Count of Subset Sum' problem.
  private int countSubsets(int[] num, int sum) {
    int n = num.length;
    int[][] dp = new int[n][sum + 1];

    // populate the sum=0 columns, as we will always have an empty set for zero sum
    for(int i=0; i < n; i++)
      dp[i][0] = 1;

    // with only one number, we can form a subset only when the required sum is equal to the number
    for(int s=1; s <= sum ; s++) {
      dp[0][s] = (num[0] == s ? 1 : 0);
    }

    // process all subsets for all sums
    for(int i=1; i < num.length; i++) {
      for(int s=1; s <= sum; s++) {
          dp[i][s] = dp[i-1][s];
          if(s >= num[i])
            dp[i][s] += dp[i-1][s-num[i]];
      }
    }

    // the bottom-right corner will have our answer.
    return dp[num.length-1][sum];
  }

  public static void main(String[] args) {
    TargetSum ts = new TargetSum();
    int[] num = {1, 1, 2, 3};
    System.out.println(ts.findTargetSubsets(num, 1));
    num = new int[]{1, 2, 7, 1};
    System.out.println(ts.findTargetSubsets(num, 9));
  }
}
```
The above solution has time and space complexity of O(N*S), where ‚ÄòN‚Äô represents total numbers and ‚ÄòS‚Äô is the desired sum.

We can further improve the solution to use only O(S) space.

**Space Optimized Solution**

Here is the code for the space-optimized solution, using only a single array:

- Code :tada:
```java
class TargetSum {

  public int findTargetSubsets(int[] num, int s) {
    int totalSum = 0;
    for (int n : num){
        totalSum += n;
        if(n < 1) return -1; //invalid input, the problem expects only positive numbers
    }

    // if 's + totalSum' is odd, we can't find a subset with sum equal to '(s + totalSum) / 2'
    if(totalSum < s || (s + totalSum) % 2 == 1)
        return 0;

    return countSubsets(num, (s + totalSum) / 2);
  }

  // this function is exactly similar to what we have in 'Count of Subset Sum' problem.
  private int countSubsets(int[] num, int sum) {
    int n = num.length;
    int[] dp = new int[sum + 1];
    dp[0] = 1;

    // with only one number, we can form a subset only when the required sum is equal to the number
    for(int s=1; s <= sum ; s++) {
      dp[s] = (num[0] == s ? 1 : 0);
    }

    // process all subsets for all sums
    for(int i=1; i < num.length; i++) {
      for(int s=sum; s >= 0; s--) {
          if(s >= num[i])
            dp[s] += dp[s-num[i]];
      }
    }

    return dp[sum];
  }

  public static void main(String[] args) {
    TargetSum ts = new TargetSum();
    int[] num = {1, 1, 2, 3};
    System.out.println(ts.findTargetSubsets(num, 1));
    num = new int[]{1, 2, 7, 1};
    System.out.println(ts.findTargetSubsets(num, 9));
  }
}
```

### Unbounded Knapsack
<hr>

- Introduction ;

Given the weights and profits of ‚ÄòN‚Äô items, we are asked to put these items in a knapsack that has a capacity ‚ÄòC‚Äô. The goal is to get the maximum profit from the items in the knapsack. The only difference between the 0/1 Knapsack problem and this problem is that we are allowed to use an unlimited quantity of an item.

Let‚Äôs take the example of Merry, who wants to carry some fruits in the knapsack to get maximum profit. Here are the weights and profits of the fruits:

Items: { Apple, Orange, Melon } Weights: { 1, 2, 3 } Profits: { 15, 20, 50 } Knapsack capacity: 5

Let‚Äôs try to put different combinations of fruits in the knapsack, such that their total weight is not more than 5.

5 Apples (total weight 5) => 75 profit 1 Apple + 2 Oranges (total weight 5) => 55 profit 2 Apples + 1 Melon (total weight 5) => 80 profit 1 Orange + 1 Melon (total weight 5) => 70 profit

This shows that 2 apples + 1 melon is the best combination, as it gives us the maximum profit and the total weight does not exceed the capacity.

- Problem Statement :

Given two integer arrays to represent weights and profits of ‚ÄòN‚Äô items, we need to find a subset of these items which will give us maximum profit such that their cumulative weight is not more than a given number ‚ÄòC‚Äô. We can assume an infinite supply of item quantities; therefore, each item can be selected multiple times.

- Basic Solution :

A basic brute-force solution could be to try all combinations of the given items to choose the one with maximum profit and a weight that doesn‚Äôt exceed ‚ÄòC‚Äô. This is what our algorithm will look like:
```
for each item 'i' 
  create a new set which includes one quantity of item 'i' if it does not exceed the capacity, and 
     recursively call to process all items 
  create a new set without item 'i', and recursively process the remaining items 
return the set from the above two sets with higher profit
```
The only difference between the 0/1 Knapsack problem and this one is that, after including the item, we recursively call to process all the items (including the current item). In 0/1 Knapsack, however, we recursively call to process the remaining items.

- Code :tada:

Here is the code for the brute-force solution:
```java

class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    return this.knapsackRecursive(profits, weights, capacity, 0);
  }

  private int knapsackRecursive(int[] profits, int[] weights, int capacity, int currentIndex) {
    // base checks
    if (capacity <= 0 || profits.length == 0 || weights.length != profits.length || 
        currentIndex >= profits.length)
      return 0;

    // recursive call after choosing the items at the currentIndex, note that we recursive call on all
    // items as we did not increment currentIndex
    int profit1 = 0;
    if (weights[currentIndex] <= capacity)
      profit1 = profits[currentIndex]
          + knapsackRecursive(profits, weights, capacity - weights[currentIndex], currentIndex);

    // recursive call after excluding the element at the currentIndex
    int profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + 1);

    return Math.max(profit1, profit2);
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = { 15, 50, 60, 90 };
    int[] weights = { 1, 3, 4, 5 };
    int maxProfit = ks.solveKnapsack(profits, weights, 8);
    System.out.println(maxProfit);
  }
}
```
The time complexity of the above algorithm is exponential O(2^{N+C}), where ‚ÄòN‚Äô represents the total number of items. The space complexity will be O(N+C) to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

Once again, we can use memoization to overcome the overlapping sub-problems.

We will be using a two-dimensional array to store the results of solved sub-problems. As mentioned above, we need to store results for every sub-array and for every possible capacity. 

Here is the code :tada:
```java

class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    Integer[][] dp = new Integer[profits.length][capacity + 1];
    return this.knapsackRecursive(dp, profits, weights, capacity, 0);
  }

  private int knapsackRecursive(Integer[][] dp, int[] profits, int[] weights, int capacity,
      int currentIndex) {

    // base checks
    if (capacity <= 0 || profits.length == 0 || weights.length != profits.length ||
        currentIndex >= profits.length)
      return 0;

    // check if we have not already processed a similar sub-problem
    if(dp[currentIndex][capacity] == null) {
      // recursive call after choosing the items at the currentIndex, note that we recursive call on all
      // items as we did not increment currentIndex
      int profit1 = 0;
      if( weights[currentIndex] <= capacity )
          profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights,
                  capacity - weights[currentIndex], currentIndex);

      // recursive call after excluding the element at the currentIndex
      int profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + 1);

      dp[currentIndex][capacity] = Math.max(profit1, profit2);
    }

    return dp[currentIndex][capacity];
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {15, 50, 60, 90};
    int[] weights = {1, 3, 4, 5};
    System.out.println(ks.solveKnapsack(profits, weights, 8));
    System.out.println(ks.solveKnapsack(profits, weights, 6));
  }
}
```
- What is the time and space complexity of the above solution?

Since our memoization array `dp[profits.length][capacity+1]` stores the results for all the subproblems, we can conclude that we will not have more than NCN‚àóC subproblems (where ‚ÄòN‚Äô is the number of items and ‚ÄòC‚Äô is the knapsack capacity). This means that our time complexity will be O(NC).

The above algorithm will be using O(NC) space for the memoization array. Other than that we will use O(N) space for the recursion call-stack. So the total space complexity will be O(NC + N), which is asymptotically equivalent to O(N*C).

- Bottom-up Dynamic Programming :

Let‚Äôs try to populate our `dp[][]` array from the above solution, working in a bottom-up fashion. Essentially, what we want to achieve is: ‚ÄúFind the maximum profit for every sub-array and for every possible capacity‚Äù.

So for every possible capacity ‚Äòc‚Äô (0 <= c <= capacity), we have two options:

Exclude the item. In this case, we will take whatever profit we get from the sub-array excluding this item: `dp[index-1][c]`
Include the item if its weight is not more than the ‚Äòc‚Äô. In this case, we include its profit plus whatever profit we get from the remaining capacity: `profit[index] + dp[index][c-weight[index]]`
Finally, we have to take the maximum of the above two values:
```
dp[index][c] = max (dp[index-1][c], profit[index] + dp[index][c-weight[index]]) 
```
- Code :tada:

Here is the code for our bottom-up dynamic programming approach:
```java

class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    // base checks
    if (capacity <= 0 || profits.length == 0 || weights.length != profits.length)
      return 0;

    int n = profits.length;
    int[][] dp = new int[n][capacity + 1];

    // populate the capacity=0 columns
    for(int i=0; i < n; i++)
      dp[i][0] = 0;

    // process all sub-arrays for all capacities
    for(int i=0; i < n; i++) {
      for(int c=1; c <= capacity; c++) {
        int profit1=0, profit2=0;
        if(weights[i] <= c)
          profit1 = profits[i] + dp[i][c-weights[i]];
        if( i > 0 )
          profit2 = dp[i-1][c];
        dp[i][c] = profit1 > profit2 ? profit1 : profit2;
      }
    }

    // maximum profit will be in the bottom-right corner.
    return dp[n-1][capacity];
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {15, 50, 60, 90};
    int[] weights = {1, 3, 4, 5};
    System.out.println(ks.solveKnapsack(profits, weights, 8));
    System.out.println(ks.solveKnapsack(profits, weights, 6));
  }
}
```
The above solution has time and space complexity of O(N*C), where ‚ÄòN‚Äô represents total items and ‚ÄòC‚Äô is the maximum capacity.

- Find the selected items :

As we know, the final profit is at the right-bottom corner; hence we will start from there to find the items that will be going to the knapsack.

As you remember, at every step we had two options: include an item or skip it. If we skip an item, then we take the profit from the cell right above it; if we include the item, then we jump to the remaining profit to find more items.

Let‚Äôs assume the four items are identified as {A, B, C, and D}, and use the above example to better understand this:

1. ‚Äò140‚Äô did not come from the top cell (which is 130); hence we must include the item at index ‚Äò3‚Äô, which is ‚ÄòD‚Äô.
2. Subtract the profit of ‚ÄòD‚Äô from ‚Äò140‚Äô to get the remaining profit ‚Äò50‚Äô. We then jump to profit ‚Äò50‚Äô on the same row.
3. ‚Äò50‚Äô came from the top cell, so we jump to row ‚Äò2‚Äô.
4. Again, ‚Äò50‚Äô came from the top cell, so we jump to row ‚Äò1‚Äô.
5. ‚Äò50‚Äô is different than the top cell, so we must include this item, which is ‚ÄòB‚Äô.
6. Subtract the profit of ‚ÄòB‚Äô from ‚Äò50‚Äô to get the remaining profit ‚Äò0‚Äô. We then jump to profit ‚Äò0‚Äô on the same row. As soon as we hit zero remaining profit, we can finish our item search.
7. So items going into the knapsack are {B, D}.

### Rod Cutting
<hr>

- Problem Statement :

Given a rod of length ‚Äòn‚Äô, we are asked to cut the rod and sell the pieces in a way that will maximize the profit. We are also given the price of every piece of length ‚Äòi‚Äô where ‚Äò1 <= i <= n‚Äô.

- Example :

Lengths: [1, 2, 3, 4, 5] Prices: [2, 6, 7, 10, 13] Rod Length: 5

Let‚Äôs try different combinations of cutting the rod:

Five pieces of length 1 => 10 price Two pieces of length 2 and one piece of length 1 => 14 price One piece of length 3 and two pieces of length 1 => 11 price One piece of length 3 and one piece of length 2 => 13 price One piece of length 4 and one piece of length 1 => 12 price One piece of length 5 => 13 price

This shows that we get the maximum price (14) by cutting the rod into two pieces of length ‚Äò2‚Äô and one piece of length ‚Äò1‚Äô.

- Basic Solution :

This problem can be mapped to the Unbounded Knapsack pattern. The ‚ÄòWeights‚Äô array of the Unbounded Knapsack problem is equivalent to the ‚ÄòLengths‚Äô array, and Profits is equivalent to Prices.

A basic brute-force solution could be to try all combinations of the given rod lengths to choose the one with the maximum sale price. This is what our algorithm will look like:
```
for each rod length 'i' 
  create a new set which includes one quantity of length 'i', and recursively process 
      all rod lengths for the remaining length 
  create a new set without rod length 'i', and recursively process for remaining rod lengths
return the set from the above two sets with a higher sales price 
Since this problem is quite similar to Unbounded Knapsack, let‚Äôs jump directly to the bottom-up dynamic solution.
```
- Bottom-up Dynamic Programming :

Let‚Äôs try to populate our `dp[][]` array in a bottom-up fashion. Essentially, what we want to achieve is: ‚ÄúFind the maximum sales price for every rod length and for every possible sales price‚Äù.

So for every possible rod length ‚Äòlen‚Äô (0<= len <= n), we have two options:

1. Exclude the piece. In this case, we will take whatever price we get from the rod length excluding this piece => `dp[index-1][len]`
2. Include the piece if its length is not more than ‚Äòlen‚Äô. In this case, we include its price plus whatever price we get from the remaining rod length => `prices[index] + dp[index][len-lengths[index]]`
Finally, we have to take the maximum of the above two values:
```
dp[index][len] = max (dp[index-1][len], prices[index] + dp[index][len-lengths[index]]) 
```
Let‚Äôs draw this visually, with the example:
```
Lengths: [1, 2, 3, 4, 5]
Prices: [2, 6, 7, 10, 13]
Rod Length: 5
```
- Code :tada:

Here is the code for our bottom-up dynamic programming approach:
```java

class RodCutting {

  public int solveRodCutting(int[] lengths, int[] prices, int n) {
    // base checks
    if (n <= 0 || prices.length == 0 || prices.length != lengths.length)
      return 0;

    int lengthCount = lengths.length;
    int[][] dp = new int[lengthCount][n + 1];

    // process all rod lengths for all prices
    for(int i=0; i < lengthCount; i++) {
      for(int len=1; len <= n; len++) {
        int p1=0, p2=0;
        if(lengths[i] <= len)
          p1 = prices[i] + dp[i][len-lengths[i]];
        if( i > 0 )
          p2 = dp[i-1][len];
        dp[i][len] = Math.max(p1, p2);
      }
    }

    // maximum price will be at the bottom-right corner.
    return dp[lengthCount-1][n];
  }

  public static void main(String[] args) {
    RodCutting rc = new RodCutting();
    int[] lengths = {1, 2, 3, 4, 5};
    int[] prices = {2, 6, 7, 10, 13};
    int maxProfit = rc.solveRodCutting(lengths, prices, 5);
    System.out.println(maxProfit);
  }
}
```
The above solution has time and space complexity of O(N*C), where ‚ÄòN‚Äô represents total items and ‚ÄòC‚Äô is the maximum capacity.

### Coin Change
<hr>

- Introduction :

Given an infinite supply of ‚Äòn‚Äô coin denominations and a total money amount, we are asked to find the total number of distinct ways to make up that amount.

- Example :

Denominations: {1,2,3} Total amount: 5 Output: 5 Explanation: There are five ways to make the change for '5', here are those ways:

1. {1,1,1,1,1}
2. {1,1,1,2}
3. {1,2,2}
4. {1,1,3}
5. {2,3}

- Problem Statement :

Given a number array to represent different coin denominations and a total amount ‚ÄòT‚Äô, we need to find all the different ways to make a change for ‚ÄòT‚Äô with the given coin denominations. We can assume an infinite supply of coins, therefore, each coin can be chosen multiple times.

- Basic Solution :

A basic brute-force solution could be to try all combinations of the given coins to select the ones that give a total sum of ‚ÄòT‚Äô. This is what our algorithm will look like:
```
for each coin 'c' 
  create a new set which includes one quantity of coin 'c' if it does not exceed 'T', and 
     recursively call to process all coins 
  create a new set without coin 'c', and recursively call to process the remaining coins 
return the count of sets who have a sum equal to 'T'
```
This problem is quite similar to Count of Subset Sum. The only difference here is that after including the item (i.e., coin), we recursively call to process all the items (including the current coin). In ‚ÄòCount of Subset Sum‚Äô, however, we were recursively calling to process only the remaining items.

- Code :tada:
```java

class CoinChange {

  public int countChange(int[] denominations, int total) {
    return this.countChangeRecursive(denominations, total, 0);
  }

  private int countChangeRecursive(int[] denominations, int total, int currentIndex) {
    // basic checks
    if (total == 0)
      return 1;

    if(denominations.length == 0 || currentIndex >= denominations.length)
      return 0;

    // recursive call after selecting the coin at the currentIndex
    // if the coin at currentIndex exceeds the total, we shouldn't process this
    int sum1 = 0;
    if( denominations[currentIndex] <= total )
      sum1 = countChangeRecursive(denominations, total - denominations[currentIndex], currentIndex);

    // recursive call after excluding the coin at the currentIndex
    int sum2 = countChangeRecursive(denominations, total, currentIndex + 1);

    return sum1 + sum2;
  }

  public static void main(String[] args) {
    CoinChange cc = new CoinChange();
    int[] denominations = {1, 2, 3};
    System.out.println(cc.countChange(denominations, 5));
  }
}
```
The time complexity of the above algorithm is exponential O(2^{C+T}), where ‚ÄòC‚Äô represents total coin denominations and ‚ÄòT‚Äô is the total amount that we want to make change. The space complexity will be O(C+T).

- Top-down Dynamic Programming with Memoization :

We can use memoization to overcome the overlapping sub-problems. We will be using a two-dimensional array to store the results of solved sub-problems. As mentioned above, we need to store results for every coin combination and for every possible sum:

- Code :tada:
```java

class CoinChange {

  public int countChange(int[] denominations, int total)
  {
    Integer[][] dp = new Integer[denominations.length][total + 1];
    return this.countChangeRecursive(dp, denominations, total, 0);
  }

  private int countChangeRecursive(Integer[][] dp, int[] denominations, int total, int currentIndex)
  {
    // base checks
    if (total == 0)
      return 1;

    if(denominations.length == 0 || currentIndex >= denominations.length)
      return 0;

    // if we have already processed a similar sub-problem, return the result from memory
    if(dp[currentIndex][total] != null)
      return dp[currentIndex][total];

    // recursive call after selecting the coin at the currentIndex
    // if the number at currentIndex exceeds the total, we shouldn't process this
    int sum1 = 0;
    if( denominations[currentIndex] <= total )
      sum1 = countChangeRecursive(dp, denominations, total - denominations[currentIndex], currentIndex);

    // recursive call after excluding the number at the currentIndex
    int sum2 = countChangeRecursive(dp, denominations, total, currentIndex + 1);

    dp[currentIndex][total] = sum1 + sum2;
    return dp[currentIndex][total];
  }

  public static void main(String[] args) {
    CoinChange cc = new CoinChange();
    int[] denominations = {1, 2, 3};
    System.out.println(cc.countChange(denominations, 5));
  }
}
```
- Bottom-up Dynamic Programming :

We will try to find if we can make all possible sums, with every combination of coins, to populate the array `dp[TotalDenominations][Total+1]`.

So for every possible total ‚Äòt‚Äô (0<= t <= Total) and for every possible coin index (0 <= index < denominations.length), we have two options:

1. Exclude the coin. Count all the coin combinations without the given coin up to the total ‚Äòt‚Äô => `dp[index-1][t]`
2. Include the coin if its value is not more than ‚Äòt‚Äô. In this case, we will count all the coin combinations to get the remaining total: `dp[index][t-denominations[index]]`
Finally, to find the total combinations, we will add both the above two values:

dp[index][t] = dp[index-1][t] + dp[index][t-denominations[index]]

- Code :tada:

Here is the code for our bottom-up dynamic programming approach:
```java

class CoinChange {

  public int countChange(int[] denominations, int total) {
    int n = denominations.length;
    int[][] dp = new int[n][total + 1];

    // populate the total=0 columns, as we will always have an empty set for zero total
    for(int i=0; i < n; i++)
      dp[i][0] = 1;
    
    // process all sub-arrays for all capacities
    for(int i=0; i < n; i++) {
      for(int t=1; t <= total; t++) {
        if(i > 0)
          dp[i][t] = dp[i-1][t];
        if(t >= denominations[i])
          dp[i][t] += dp[i][t-denominations[i]];
      }
    }

    // total combinations will be at the bottom-right corner.
    return dp[n-1][total];
  }

  public static void main(String[] args) {
    CoinChange cc = new CoinChange();
    int[] denominations = {1, 2, 3};
    System.out.println(cc.countChange(denominations, 5));
  }
}
```

### Minimum Coin Change
<hr>

- Introduction :

Given an infinite supply of ‚Äòn‚Äô coin denominations and a total money amount, we are asked to find the minimum number of coins needed to make up that amount.

- Example :

Denominations: {1,2,3} Total amount: 5 Output: 2 Explanation: We need a minimum of two coins {2,3} to make a total of '5'

- Problem Statement :

Given a number array to represent different coin denominations and a total amount ‚ÄòT‚Äô, we need to find the minimum number of coins needed to make a change for ‚ÄòT‚Äô. We can assume an infinite supply of coins, therefore, each coin can be chosen multiple times.

- Basic Solution :

A basic brute-force solution could be to try all combinations of the given coins to select the ones that give a total sum of ‚ÄòT‚Äô. This is what our algorithm will look like:
```
for each coin 'c' 
  create a new set which includes one quantity of coin 'c' if it does not exceed 'T', and 
     recursively call to process all coins 
  create a new set without coin 'c', and recursively call to process the remaining coins 
return the count of coins from the above two sets with a smaller number of coins
```
- Code :tada:

Here is the code for the brute-force solution:
```java

class CoinChange {

  public int countChange(int[] denominations, int total) {
    int result = this.countChangeRecursive(denominations, total, 0);
    return (result == Integer.MAX_VALUE ? -1 : result);
  }

  private int countChangeRecursive(int[] denominations, int total, int currentIndex) {
    // base check
    if (total == 0)
      return 0;

    if(denominations.length == 0 || currentIndex >= denominations.length)
      return Integer.MAX_VALUE;

    // recursive call after selecting the coin at the currentIndex
    // if the coin at currentIndex exceeds the total, we shouldn't process this
    int count1 = Integer.MAX_VALUE;
    if( denominations[currentIndex] <= total ) {
      int res = countChangeRecursive(denominations, total - denominations[currentIndex], currentIndex);
      if(res != Integer.MAX_VALUE){
        count1 = res + 1;
      }
    }

    // recursive call after excluding the coin at the currentIndex
    int count2 = countChangeRecursive(denominations, total, currentIndex + 1);

    return Math.min(count1, count2);
  }

  public static void main(String[] args) {
    CoinChange cc = new CoinChange();
    int[] denominations = {1, 2, 3};
    System.out.println(cc.countChange(denominations, 5));
    System.out.println(cc.countChange(denominations, 11));
    System.out.println(cc.countChange(denominations, 7));
    denominations = new int[]{3, 5};
    System.out.println(cc.countChange(denominations, 7));
  }
}
```
The time complexity of the above algorithm is exponential O(2^{C+T}), where ‚ÄòC‚Äô represents total coin denominations and ‚ÄòT‚Äô is the total amount that we want to make change. The space complexity will be O(C+T).

- Top-down Dynamic Programming with Memoization :

We can use memoization to overcome the overlapping sub-problems. We will be using a two-dimensional array to store the results of solved sub-problems. As mentioned above, we need to store results for every coin combination and for every possible sum:

- Code :tada:
```java

class CoinChange {

  public int countChange(int[] denominations, int total)
  {
    Integer[][] dp = new Integer[denominations.length][total + 1];
    return this.countChangeRecursive(dp, denominations, total, 0);
  }

  private int countChangeRecursive(Integer[][] dp, int[] denominations, int total, int currentIndex)
  {
    // base checks
    if (total == 0)
      return 1;

    if(denominations.length == 0 || currentIndex >= denominations.length)
      return 0;

    // if we have already processed a similar sub-problem, return the result from memory
    if(dp[currentIndex][total] != null)
      return dp[currentIndex][total];

    // recursive call after selecting the coin at the currentIndex
    // if the number at currentIndex exceeds the total, we shouldn't process this
    int sum1 = 0;
    if( denominations[currentIndex] <= total )
      sum1 = countChangeRecursive(dp, denominations, total - denominations[currentIndex], currentIndex);

    // recursive call after excluding the number at the currentIndex
    int sum2 = countChangeRecursive(dp, denominations, total, currentIndex + 1);

    dp[currentIndex][total] = sum1 + sum2;
    return dp[currentIndex][total];
  }

  public static void main(String[] args) {
    CoinChange cc = new CoinChange();
    int[] denominations = {1, 2, 3};
    System.out.println(cc.countChange(denominations, 5));
  }
}
```
- Bottom-up Dynamic Programming :

Let‚Äôs try to populate our array `dp[TotalDenominations][Total+1]` for every possible total with a minimum number of coins needed.

So for every possible total ‚Äòt‚Äô (0<= t <= Total) and for every possible coin index (0 <= index < denominations.length), we have two options:

Exclude the coin: In this case, we will take the minimum coin count from the previous set => `dp[index-1][t]`
Include the coin if its value is not more than ‚Äòt‚Äô: In this case, we will take the minimum count needed to get the remaining total, plus include ‚Äò1‚Äô for the current coin => `dp[index][t-denominations[index]] + 1`
Finally, we will take the minimum of the above two values for our solution:
```
dp[index][t] = min(dp[index-1][t], dp[index][t-denominations[index]] + 1)
```
- Code :tada:

Here is the code for our bottom-up dynamic programming approach:
```java

import java.util.Arrays;

class CoinChange {

  public int countChange(int[] denominations, int total)
  {
    int n = denominations.length;
    int[][] dp = new int[n][total + 1];

    for(int i=0; i < n; i++)
      for(int j=0; j <= total; j++)
        dp[i][j] = Integer.MAX_VALUE;

    // populate the total=0 columns, as we don't need any coin to make zero total
    for(int i=0; i < n; i++)
      dp[i][0] = 0;

    for(int i=0; i < n; i++) {
      for(int t=1; t <= total; t++) {
        if(i > 0)
          dp[i][t] = dp[i-1][t]; //exclude the coin
        if(t >= denominations[i]) {
          if(dp[i][t-denominations[i]] != Integer.MAX_VALUE)
            dp[i][t] = Math.min(dp[i][t], dp[i][t-denominations[i]]+1); // include the coin
        }
      }
    }

    // total combinations will be at the bottom-right corner.
    return (dp[n-1][total] == Integer.MAX_VALUE ? -1 : dp[n-1][total]);
  }

  public static void main(String[] args) {
    CoinChange cc = new CoinChange();
    int[] denominations = {1, 2, 3};
    System.out.println(cc.countChange(denominations, 5));
    System.out.println(cc.countChange(denominations, 11));
    System.out.println(cc.countChange(denominations, 7));
    denominations = new int[]{3, 5};
    System.out.println(cc.countChange(denominations, 7));
  }
}
```
The above solution has time and space complexity of O(C*T), where ‚ÄòC‚Äô represents total coin denominations and ‚ÄòT‚Äô is the total amount that we want to make change.
The above solution has time and space complexity of O(C*T)O(C‚àóT), where ‚ÄòC‚Äô represents total coin denominations and ‚ÄòT‚Äô is the total amount that we want to make change.


### Fibonacci numbers
<hr>

- Problem Statement :

Write a function to calculate the nth Fibonacci number.

Fibonacci numbers are a series of numbers in which each number is the sum of the two preceding numbers. First few Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8, ‚Ä¶

Mathematically we can define the Fibonacci numbers as:
```
Fib(n) = Fib(n-1) + Fib(n-2), for n > 1

Given that: Fib(0) = 0, and Fib(1) = 1
```
- Basic Solution :

A basic solution could be to have a recursive implementation of the mathematical formula discussed above:

- Code :tada:
```java

class Fibonacci {

  public int CalculateFibonacci(int n) {
    if(n < 2)
      return n;
    return CalculateFibonacci(n-1) + CalculateFibonacci(n-2);
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```
The time complexity of the above algorithm is exponential O(2^n) as we are making two recursive calls in the same function. The space complexity is O(n)O(n) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use an array to store the already solved subproblems. Here is the code:

- Code :tada:
```java

class Fibonacci {

  public int CalculateFibonacci(int n) {
    int dp[] = new int[n + 1];
    return CalculateFibonacciRecursive(dp, n);
  }

  public int CalculateFibonacciRecursive(int[] dp, int n) {
    if (n < 2)
      return n;
    if (dp[n] == 0)
      dp[n] = CalculateFibonacciRecursive(dp, n - 1) + CalculateFibonacciRecursive(dp, n - 2);
    return dp[n];
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```
- Bottom-up Dynamic Programming :

Let‚Äôs try to populate our dp[] array from the above solution, working in a bottom-up fashion. Since every Fibonacci number is the sum of the previous two numbers, we can use this fact to populate our array.

Here is the code for the bottom-up dynamic programming approach:

- Code  :tada:

Here is the code for our bottom-up dynamic programming approach:
```java

class Fibonacci {

  public int CalculateFibonacci(int n) {
    if (n < 2)
      return n;

    int dp[] = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
      dp[i] = dp[i - 1] + dp[i - 2];
    return dp[n];
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```
The above solution has time and space complexity of O(n).

- Memory optimization :

We can optimize the space used in our previous solution. We don‚Äôt need to store all the Fibonacci numbers up to ‚Äòn‚Äô, as we only need two previous numbers to calculate the next Fibonacci number. We can use this fact to further improve our solution:

- Code :tada:
```java
class Fibonacci {

  public int CalculateFibonacci(int n) {
    if (n < 2)
      return n;
    int n1 = 0, n2 = 1, temp;
    for (int i = 2; i <= n; i++) {
      temp = n1 + n2;
      n1 = n2;
      n2 = temp;
    }
    return n2;
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```
The above solution has a time complexity of O(n) but a constant space complexity O(1).

### Staircase
<hr>

- Problem Statement :

Given a stair with ‚Äòn‚Äô steps, implement a method to count how many possible ways are there to reach the top of the staircase, given that, at every step you can either take 1 step, 2 steps, or 3 steps.

- Example 1 :
```
Number of stairs (n) : 3 Number of ways = 4 Explanation: Following are the four ways we can climb : {1,1,1}, {1,2}, {2,1}, {3}
```
- Example 2 :
```
Number of stairs (n) : 4 Number of ways = 7 Explanation: Following are the seven ways we can climb : {1,1,1,1}, {1,1,2}, {1,2,1}, {2,1,1}, {2,2}, {1,3}, {3,1}
```
- Basic Solution :

At every step, we have three options: either jump 1 step, 2 steps, or 3 steps. So our algorithm will look like this:

- Code :tada:
```java

class Staircase {

  public int CountWays(int n) {
    if( n == 0)
      return 1; // base case, we don't need to take any step, so there is only one way
      
    if(n == 1)
      return 1; // we can take one step to reach the end, and that is the only way

    if(n == 2)
      return 2; // we can take one step twice or jump two steps to reach at the top

    // if we take 1 step, we are left with 'n-1' steps;
    int take1Step = CountWays(n-1); 
    // similarly, if we took 2 steps, we are left with 'n-2' steps;
    int take2Step = CountWays(n-2); 
    // if we took 3 steps, we are left with 'n-3' steps;
    int take3Step = CountWays(n-3); 

    return take1Step + take2Step + take3Step;
  }

  public static void main(String[] args) {
    Staircase sc = new Staircase();
    System.out.println(sc.CountWays(3));
    System.out.println(sc.CountWays(4));
    System.out.println(sc.CountWays(5));
  }
}
```
The time complexity of the above algorithm is exponential O(3^n) as we are making three recursive call in the same function. The space complexity is O(n) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use an array to store the already solved subproblems. Here is the code:

- Code :tada:
```java

class Staircase {

  public int CountWays(int n) {
    int dp[] = new int[n+1];
    return CountWaysRecursive(dp, n);
  }
  
  public int CountWaysRecursive(int[] dp, int n) {
    if( n == 0)
      return 1; // base case, we don't need to take any step, so there is only one way

    if(n == 1)
      return 1; // we can take one step to reach the end, and that is the only way

    if(n == 2)
      return 2; // we can take one step twice or jump two steps to reach at the top

    if(dp[n] == 0) {
      // if we take 1 step, we are left with 'n-1' steps;
      int take1Step = CountWaysRecursive(dp, n-1);
      // similarly, if we took 2 steps, we are left with 'n-2' steps;
      int take2Step = CountWaysRecursive(dp, n-2);
      // if we took 3 steps, we are left with 'n-3' steps;
      int take3Step = CountWaysRecursive(dp, n-3);
      dp[n] = take1Step + take2Step + take3Step;
    }
    
    return dp[n];
  }

  public static void main(String[] args) {
    Staircase sc = new Staircase();
    System.out.println(sc.CountWays(3));
    System.out.println(sc.CountWays(4));
    System.out.println(sc.CountWays(5));
  }
}
```
- What is the time and space complexity of the above solution?

Since our memoization array dp[n+1] stores the results for all the subproblems, we can conclude that we will not have more than n+1n+1 subproblems (where ‚Äòn‚Äô represents the total number of steps). This means that our time complexity will be O(N). The space complexity will also be O(n); this space will be used to store the recursion-stack.

- Bottom-up Dynamic Programming :

Let‚Äôs try to populate our dp[] array from the above solution, working in a bottom-up fashion. As we saw in the above code, every CountWaysRecursive(n) is the sum of the previous three counts. We can use this fact to populate our array.

- Code :tada:

Here is the code for our bottom-up dynamic programming approach:
- Code :tada:
```java

class Staircase {

  public int CountWays(int n) {
    int dp[] = new int[n+1];
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;

    for(int i=3; i<=n; i++)
      dp[i] = dp[i-1] + dp[i-2] + dp[i-3];

    return dp[n];
  }

  public static void main(String[] args) {
    Staircase sc = new Staircase();
    System.out.println(sc.CountWays(3));
    System.out.println(sc.CountWays(4));
    System.out.println(sc.CountWays(5));
  }
}
```
The above solution has time and space complexity of O(n).

- Memory optimization :

We can optimize the space used in our previous solution. We don‚Äôt need to store all the counts up to ‚Äòn‚Äô, as we only need three previous numbers to calculate the next count. We can use this fact to further improve our solution:
- Code :tada:

```java
class Staircase {

  public int CountWays(int n) {
    if (n < 2) return 1;
    if (n == 2) return 2;
    int n1=1, n2=1, n3=2, temp;
    for(int i=3; i<=n; i++) {
      temp = n1 + n2 + n3;
      n1 = n2;
      n2 = n3;
      n3 = temp;
    }
    return n3;
  }

  public static void main(String[] args) {
    Staircase sc = new Staircase();
    System.out.println(sc.CountWays(3));
    System.out.println(sc.CountWays(4));
    System.out.println(sc.CountWays(5));
  }
}
```
The above solution has a time complexity of O(n) and a constant space complexity O(1).

- Fibonacci number pattern :

We can clearly see that this problem follows the Fibonacci number pattern. The only difference is that in Fibonacci numbers every number is a sum of the two preceding numbers, whereas in this problem every count is a sum of three preceding counts. Here is the recursive formula for this problem:

```
CountWays(n) = CountWays(n-1) + CountWays(n-2) + CountWays(n-3), for n >=3
```

This problem can be extended further. Instead of taking 1, 2, or 3 steps at any time, what if we can take up to ‚Äòk‚Äô steps at any time? In that case, our recursive formula will look like:

```
CountWays(n) = CountWays(n-1) + CountWays(n-2) + CountWays(n-3) + ... + CountWays(n-k), for n >= k
```

### Minimum Jumps To Reach The End
<hr>

- Problem Statement :

Given an array of positive numbers, where each element represents the max number of jumps that can be made forward from that element, write a program to find the minimum number of jumps needed to reach the end of the array (starting from the first element). If an element is 0, then we cannot move through that element.

- Example 1 :

```
Input = {2,1,1,1,4} Output = 3 Explanation: Starting from index '0', we can reach the last index through: 0->2->3->4
```
- Example 2 :
```
Input = {1,1,3,6,9,3,0,1,3} Output = 4 Explanation: Starting from index '0', we can reach the last index through: 0->1->2->3->8
```
- Basic Solution :

We will start with the '0‚Äôth index and try all options. So, if the value at the current index is ‚Äòp‚Äô, we will try every jump in the range (1 to ‚Äòp‚Äô) from that index. After taking a jump, we recursively try all options from that index. Here is the code:

- Code :tada:
```java

class ArrayJump {

  public int countMinJumps(int[] jumps) {
    return this.countMinJumpsRecursive(jumps, 0);
  }

  private int countMinJumpsRecursive(int[] jumps, int currentIndex) {
    // if we have reached the last index, we don't need any more jumps
    if( currentIndex == jumps.length - 1)
      return 0;

    if (jumps[currentIndex] == 0)
      return Integer.MAX_VALUE;

    int totalJumps = Integer.MAX_VALUE;
    int start = currentIndex + 1;
    int end = currentIndex + jumps[currentIndex];
    while(start < jumps.length && start <= end) {
      // jump one step and recurse for the remaining array
      int minJumps = countMinJumpsRecursive(jumps, start++);
      if(minJumps != Integer.MAX_VALUE)
        totalJumps = Math.min(totalJumps, minJumps + 1);
    }
    return totalJumps;
  }

  public static void main(String[] args) {
    ArrayJump aj = new ArrayJump();
    int[] jumps = {2, 1, 1, 1, 4};
    System.out.println(aj.countMinJumps(jumps));
    jumps = new int[]{1, 1, 3, 6, 9, 3, 0, 1, 3};
    System.out.println(aj.countMinJumps(jumps));
  }
}
```
The time complexity of the above algorithm is O(2^n), where ‚Äòn‚Äô is the size of the input array. The ‚Äòwhile loop‚Äô can execute a maximum of ‚Äòn‚Äô times (for the case where we can jump to all the steps ahead) and since in each iteration, the function recursively calls itself, therefore, the time complexity is O(2^n). The space complexity is O(n) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use an array to store the already solved subproblems. Here is the code:

- Code :tada:
```java
class ArrayJump {

  public int countMinJumps(int[] jumps) {
    int dp[] = new int[jumps.length];
    return this.countMinJumpsRecursive(dp, jumps, 0);
  }

  private int countMinJumpsRecursive(int[] dp, int[] jumps, int currentIndex) {
    // if we have reached the last index, we don't need any more jumps
    if( currentIndex == jumps.length - 1)
      return 0;

    // If an element is 0, then we cannot move through that element
    if (jumps[currentIndex] == 0)
      return Integer.MAX_VALUE;

    // if we have already solved this problem, return the result
    if(dp[currentIndex] != 0)
      return dp[currentIndex];

    int totalJumps = Integer.MAX_VALUE;
    int start = currentIndex + 1;
    int end = currentIndex + jumps[currentIndex];
    while(start < jumps.length && start <= end) {
      // jump one step and recurse for the remaining array
      int minJumps = countMinJumpsRecursive(dp, jumps, start++);
      if(minJumps != Integer.MAX_VALUE)
        totalJumps = Math.min(totalJumps, minJumps + 1);
    }
    dp[currentIndex] = totalJumps;
    return dp[currentIndex];
  }

  public static void main(String[] args) {
    ArrayJump aj = new ArrayJump();
    int[] jumps = {2, 1, 1, 1, 4};
    System.out.println(aj.countMinJumps(jumps));
    jumps = new int[]{1, 1, 3, 6, 9, 3, 0, 1, 3};
    System.out.println(aj.countMinJumps(jumps));
  }
}
```
- Bottom-up Dynamic Programming :

Let‚Äôs try to populate our dp[] array from the above solution, working in the bottom-up fashion. As we saw in the above code, we were trying to find the minimum jumps needed to reach every index (if it is within the range) from the current index. We can use this fact to populate our array. As we know, every index within the range of current index can be reached in one jump. Therefore, we can say that we can reach every index (within the range of current index) in:
```
'jumps to reach current index' + 1
```
So, while going through all the indexes, we will take the minimum value between the current jump-count and the jumps needed to reach the current index + 1.

- Code :tada:

Here is the code for our bottom-up dynamic programming approach:

```java
class ArrayJump {

  public int countMinJumps(int[] jumps) {
    int[] dp = new int[jumps.length];

    //initialize with infinity, except the first index which should be zero as we start from there
    for(int i=1; i<jumps.length; i++)
      dp[i] = Integer.MAX_VALUE;

    for(int start=0; start < jumps.length-1; start++) {
      for(int end=start+1; end <= start+jumps[start] && end < jumps.length; end++)
        dp[end] = Math.min(dp[end], dp[start]+1);
    }

    return dp[jumps.length-1];
  }

  public static void main(String[] args) {
    ArrayJump aj = new ArrayJump();
    int[] jumps = {2, 1, 1, 1, 4};
    System.out.println(aj.countMinJumps(jumps));
    jumps = new int[]{1, 1, 3, 6, 9, 3, 0, 1, 3};
    System.out.println(aj.countMinJumps(jumps));
  }
}
```
The above solution has a time complexity of O(n^2) (because of the two for loops) and space complexity of O(n) to store dp[].

- Fibonacci number pattern :

We can clearly see that this problem follows the Fibonacci number pattern. The only difference is that every Fibonacci number is a sum of the two preceding numbers, whereas in this problem every number is the minimum of two numbers (start and end):

```
dp[end] = Math.min(dp[end], dp[start]+1);
```

### House Thief
<hr>

There are n houses built in a line. A thief wants to steal the maximum possible money from these houses. The only restriction the thief has is that he can‚Äôt steal from two consecutive houses, as that would alert the security system. How should the thief maximize his stealing?

- Problem Statement :

Given a number array representing the wealth of n houses, determine the maximum amount of money the thief can steal without alerting the security system.

- Example 1 :
```
Input: {2, 5, 1, 3, 6, 2, 4} Output: 15 Explanation: The thief should steal from houses 5 + 6 + 4
```
- Example 2 :
```
Input: {2, 10, 14, 8, 1} Output: 18 Explanation: The thief should steal from houses 10 + 8
```
- Basic Solution :

For every house i, we have two options :

Steal from the current house (i), skip one and steal from (i+2). Skip the current house (i), and steal from the adjacent house (i+1). The thief should choose the one with the maximum amount from the above two options. So our algorithm will look like this:

- Code :tada:
```java
class HouseThief {

  public int findMaxSteal(int[] wealth) {
    return findMaxStealRecursive(wealth, 0);
  }

  private int findMaxStealRecursive(int[] wealth, int currentIndex) {
    if( currentIndex >= wealth.length)
      return 0;

    // steal from current house and skip one to steal from the next house
    int stealCurrent = wealth[currentIndex] + findMaxStealRecursive(wealth, currentIndex + 2);
    // skip current house to steel from the adjacent house
    int skipCurrent = findMaxStealRecursive(wealth, currentIndex + 1);

    return Math.max(stealCurrent, skipCurrent);
  }

  public static void main(String[] args) {
    HouseThief ht = new HouseThief();
    int[] wealth = {2, 5, 1, 3, 6, 2, 4};
    System.out.println(ht.findMaxSteal(wealth));
    wealth = new int[]{2, 10, 14, 8, 1};
    System.out.println(ht.findMaxSteal(wealth));
  }
}
```
The time complexity of the above algorithm is exponential O(2^n). The space complexity is O(n) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

To resolve overlapping subproblems, we can use an array to store the already solved subproblems.

Here is the code :

- Code :tada:
```java

class HouseThief {

  public int findMaxSteal(int[] wealth) {
    int dp[] = new int[wealth.length];
    return findMaxStealRecursive(dp, wealth, 0);
  }

  private int findMaxStealRecursive(int[] dp, int[] wealth, int currentIndex) {
    if( currentIndex >= wealth.length)
      return 0;

    if(dp[currentIndex] == 0) {
      // steal from current house and skip one to steal next
      int stealCurrent = wealth[currentIndex] + findMaxStealRecursive(dp, wealth, currentIndex + 2);
      // skip current house to steel from the adjacent house
      int skipCurrent = findMaxStealRecursive(dp, wealth, currentIndex + 1);

      dp[currentIndex] = Math.max(stealCurrent, skipCurrent);
    }
    return dp[currentIndex];
  }

  public static void main(String[] args) {
    HouseThief ht = new HouseThief();
    int[] wealth = {2, 5, 1, 3, 6, 2, 4};
    System.out.println(ht.findMaxSteal(wealth));
    wealth = new int[]{2, 10, 14, 8, 1};
    System.out.println(ht.findMaxSteal(wealth));
  }
}
```
- Bottom-up Dynamic Programming :

Let‚Äôs try to populate our dp[] array from the above solution, working in a bottom-up fashion. As we saw in the above code, every findMaxStealRecursive() is the maximum of the two recursive calls; we can use this fact to populate our array.

- Code :tada:

Here is the code for our bottom-up dynamic programming approach:
```java

class HouseThief {

  public int findMaxSteal(int[] wealth) {
    if(wealth.length == 0) return 0;
    int dp[] = new int[wealth.length+1]; // '+1' to handle the zero house
    dp[0] = 0; // if there are no houses, the thief can't steal anything
    dp[1] = wealth[0]; // only one house, so the thief have to steal from it

    // please note that dp[] has one extra element to handle zero house
    for(int i=1; i < wealth.length; i++)
      dp[i+1] = Math.max(wealth[i] + dp[i-1], dp[i]);

    return dp[wealth.length];
  }

  public static void main(String[] args) {
    HouseThief ht = new HouseThief();
    int[] wealth = {2, 5, 1, 3, 6, 2, 4};
    System.out.println(ht.findMaxSteal(wealth));
    wealth = new int[]{2, 10, 14, 8, 1};
    System.out.println(ht.findMaxSteal(wealth));
  }
}
```
The above solution has time and space complexity of O(n).

- Memory optimization :

We can optimize the space used in our previous solution. We don‚Äôt need to store all the previous numbers up to n, as we only need two previous numbers to calculate the next number in the sequence. Let‚Äôs use this fact to further improve our solution:

- Code :tada:
```java

class HouseThief {

  public int findMaxSteal(int[] wealth) {
    if(wealth.length == 0) return 0;
    int n1=0, n2=wealth[0], temp;
    for(int i=1; i < wealth.length; i++) {
      temp = Math.max(n1 + wealth[i], n2);
      n1 = n2;
      n2 = temp;
    }
    return n2;
  }

  public static void main(String[] args) {
    HouseThief ht = new HouseThief();
    int[] wealth = {2, 5, 1, 3, 6, 2, 4};
    System.out.println(ht.findMaxSteal(wealth));
    wealth = new int[]{2, 10, 14, 8, 1};
    System.out.println(ht.findMaxSteal(wealth));
  }
}
```
The above solution has a time complexity of O(n) and a constant space complexity O(1).

- Fibonacci number pattern :

We can clearly see that this problem follows the Fibonacci number pattern. The only difference is that every Fibonacci number is a sum of the two preceding numbers, whereas in this problem every number (total wealth) is the maximum of previous two numbers.

### Longest Palindromic Subsequence
<hr>

- Problem Statement :

Given a sequence, find the length of its Longest Palindromic Subsequence (LPS). In a palindromic subsequence, elements read the same backward and forward.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

Example 1 :
```
Input: "abdbca" Output: 5 Explanation: LPS is "abdba".
```
Example 2 :
```
Input: = "cddpd" Output: 3 Explanation: LPS is "ddd".
```
Example 3 :
```
Input: = "pqr" Output: 1 Explanation: LPS could be "p", "q" or "r".
```
- Basic Solution :

A basic brute-force solution could be to try all the subsequences of the given sequence. We can start processing from the beginning and the end of the sequence. So at any step, we have two options:

1. If the element at the beginning and the end are the same, we increment our count by two and make a recursive call for the remaining sequence.
We will skip the element either from the beginning or the end to make two recursive calls for the remaining subsequence.
2. If option one applies then it will give us the length of LPS; otherwise, the length of LPS will be the maximum number returned by the two recurse calls from the second option.

- Code :tada:
```java

class LPS {

  public int findLPSLength(String st) {
    return findLPSLengthRecursive(st, 0, st.length()-1);
  }

  private int findLPSLengthRecursive(String st, int startIndex, int endIndex) {
    if(startIndex > endIndex)
      return 0;

    // every sequence with one element is a palindrome of length 1
    if(startIndex == endIndex)
      return 1;

    // case 1: elements at the beginning and the end are the same
    if(st.charAt(startIndex) == st.charAt(endIndex))
      return 2 + findLPSLengthRecursive(st, startIndex+1, endIndex-1);

    // case 2: skip one element either from the beginning or the end
    int c1 =  findLPSLengthRecursive(st, startIndex+1, endIndex);
    int c2 =  findLPSLengthRecursive(st, startIndex, endIndex-1);
    return Math.max(c1, c2);
  }

  public static void main(String[] args) {
    LPS lps = new LPS();
    System.out.println(lps.findLPSLength("abdbca"));
    System.out.println(lps.findLPSLength("cddpd"));
    System.out.println(lps.findLPSLength("pqr"));
  }
}
```
In each function call, we are either having one recursive call or two recursive calls (we will never have three recursive calls); hence, the time complexity of the above algorithm is exponential O(2^n), where ‚Äòn‚Äô is the length of the input sequence. The space complexity is O(n), which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use an array to store the already solved subproblems.

The two changing values to our recursive function are the two indexes, startIndex and endIndex. Therefore, we can store the results of all the subproblems in a two-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (startIndex + ‚Äú|‚Äù + endIndex))

- Code :tada:
```java

class LPS {

  public int findLPSLength(String st) {
    Integer[][] dp = new Integer[st.length()][st.length()];
    return findLPSLengthRecursive(dp, st, 0, st.length()-1);
  }

  private int findLPSLengthRecursive(Integer[][] dp, String st, int startIndex, int endIndex) {
    if(startIndex > endIndex)
      return 0;

    // every sequence with one element is a palindrome of length 1
    if(startIndex == endIndex)
      return 1;

    if(dp[startIndex][endIndex] == null) {
      // case 1: elements at the beginning and the end are the same
      if(st.charAt(startIndex) == st.charAt(endIndex)) {
        dp[startIndex][endIndex] = 2 + findLPSLengthRecursive(dp, st, startIndex+1, endIndex-1);
      } else {
        // case 2: skip one element either from the beginning or the end
        int c1 =  findLPSLengthRecursive(dp, st, startIndex+1, endIndex);
        int c2 =  findLPSLengthRecursive(dp, st, startIndex, endIndex-1);
        dp[startIndex][endIndex] = Math.max(c1, c2);
      }
    }

    return dp[startIndex][endIndex];
  }

  public static void main(String[] args) {
    LPS lps = new LPS();
    System.out.println(lps.findLPSLength("abdbca"));
    System.out.println(lps.findLPSLength("cddpd"));
    System.out.println(lps.findLPSLength("pqr"));
  }
}
```
- What is the time and space complexity of the above solution?
- 
Since our memoization array `dp[st.length()][st.length()]` stores the results for all the subproblems, we can conclude that we will not have more than N*N subproblems (where ‚ÄòN‚Äô is the length of the input sequence). This means that our time complexity will be O(N^2). The above algorithm will be using O(N^2) space for the memoization array. Other than that we will use O(N)space for the recursion call-stack. So the total space complexity will be O(N^2 + N), which is asymptotically equivalent to O(N^2).

- Bottom-up Dynamic Programming :

Since we want to try all the subsequences of the given sequence, we can use a two-dimensional array to store our results. We can start from the beginning of the sequence and keep adding one element at a time. At every step, we will try all of its subsequences. So for every startIndex and endIndex in the given string, we will choose one of the following two options:

1. If the element at the startIndex matches the element at the endIndex, the length of LPS would be two plus the length of LPS till startIndex+1 and endIndex-1.
2. If the element at the startIndex does not match the element at the endIndex, we will take the maximum LPS created by either skipping element at the startIndex or the endIndex.
So our recursive formula would be:
```
if st[endIndex] == st[startIndex] 
  dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1]
else 
  dp[startIndex][endIndex] = Math.max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1])
```
- Code :tada:

Here is the code for our bottom-up dynamic programming approach :
```java
class LPS {

  public int findLPSLength(String st) {
    // dp[i][j] stores the length of LPS from index 'i' to index 'j'
    int[][] dp = new int[st.length()][st.length()];

    // every sequence with one element is a palindrome of length 1
    for (int i = 0; i < st.length(); i++)
      dp[i][i] = 1;

    for (int startIndex = st.length() - 1; startIndex >= 0; startIndex--) {
      for (int endIndex = startIndex + 1; endIndex < st.length(); endIndex++) {
        // case 1: elements at the beginning and the end are the same
        if (st.charAt(startIndex) == st.charAt(endIndex)) {
          dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];
        } else { // case 2: skip one element either from the beginning or the end
          dp[startIndex][endIndex] = Math.max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1]);
        }
      }
    }
    return dp[0][st.length() - 1];
  }

  public static void main(String[] args) {
    LPS lps = new LPS();
    System.out.println(lps.findLPSLength("abdbca"));
    System.out.println(lps.findLPSLength("cddpd"));
    System.out.println(lps.findLPSLength("pqr"));
  }
}
```
The time and space complexity of the above algorithm is O(n^2), where ‚Äòn‚Äô is the length of the input sequence.

### Longest Palindromic Substring
<hr>

- Problem Statement :

Given a string, find the length of its Longest Palindromic Substring (LPS). In a palindromic string, elements read the same backward and forward.

- Example 1 :
```
Input: "abdbca" Output: 3 Explanation: LPS is "bdb".
```
- Example 2 :
```
Input: = "cddpd" Output: 3 Explanation: LPS is "dpd".
```
- Example 3 :
```
Input: = "pqr" Output: 1 Explanation: LPS could be "p", "q" or "r".
```
Basic Solution : 

This problem follows the Longest Palindromic Subsequence pattern. The only difference is that in a palindromic subsequence characters can be non-adjacent, whereas in a substring all characters should form a palindrome. We will follow a similar approach though. The brute-force solution will be to try all the substrings of the given string. We can start processing from the beginning and the end of the string. So at any step, we will have two options:

1. If the element at the beginning and the end are the same, we make a recursive call to check if the remaining substring is also a palindrome. If so, the substring is a palindrome from beginning to end.
2. We will skip either the element from the beginning or the end to make two recursive calls for the remaining substring. The length of LPS would be the maximum of these two recursive calls.

- Code :tada:
```java

class LPS {

  public int findLPSLength(String st) {
    return findLPSLengthRecursive(st, 0, st.length() - 1);
  }

  private int findLPSLengthRecursive(String st, int startIndex, int endIndex) {
    if (startIndex > endIndex)
      return 0;

    // every string with one character is a palindrome
    if (startIndex == endIndex)
      return 1;

    // case 1: elements at the beginning and the end are the same
    if (st.charAt(startIndex) == st.charAt(endIndex)) {
      int remainingLength = endIndex - startIndex - 1;
      // check if the remaining string is also a palindrome
      if (remainingLength == findLPSLengthRecursive(st, startIndex + 1, endIndex - 1))
        return remainingLength + 2;
    }

    // case 2: skip one character either from the beginning or the end
    int c1 = findLPSLengthRecursive(st, startIndex + 1, endIndex);
    int c2 = findLPSLengthRecursive(st, startIndex, endIndex - 1);
    return Math.max(c1, c2);
  }

  public static void main(String[] args) {
    LPS lps = new LPS();
    System.out.println(lps.findLPSLength("abdbca"));
    System.out.println(lps.findLPSLength("cddpd"));
    System.out.println(lps.findLPSLength("pqr"));
  }
}
```
Due to the three recursive calls, the time complexity of the above algorithm is exponential O(3^n), where ‚Äòn‚Äô is the length of the input string. The space complexity is O(n) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use an array to store the already solved subproblems.

The two changing values to our recursive function are the two indexes, startIndex and endIndex. Therefore, we can store the results of all the subproblems in a two-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (startIndex + ‚Äú|‚Äù + endIndex))

Here is the code for this:

- Code :tada:
```java

class LPS {

  public int findLPSLength(String st) {
    Integer[][] dp = new Integer[st.length()][st.length()];
    return findLPSLengthRecursive(dp, st, 0, st.length() - 1);
  }

  private int findLPSLengthRecursive(Integer[][] dp, String st, int startIndex, int endIndex) {
    if (startIndex > endIndex)
      return 0;

    // every string with one character is a palindrome
    if (startIndex == endIndex)
      return 1;

    if (dp[startIndex][endIndex] == null) {
      // case 1: elements at the beginning and the end are the same
      if (st.charAt(startIndex) == st.charAt(endIndex)) {
        int remainingLength = endIndex - startIndex - 1;
        // check if the remaining string is also a palindrome
        if (remainingLength == findLPSLengthRecursive(dp, st, startIndex + 1, endIndex - 1)) {
          dp[startIndex][endIndex] = remainingLength + 2;
          return dp[startIndex][endIndex];
        }
      }

      // case 2: skip one character either from the beginning or the end
      int c1 = findLPSLengthRecursive(dp, st, startIndex + 1, endIndex);
      int c2 = findLPSLengthRecursive(dp, st, startIndex, endIndex - 1);
      dp[startIndex][endIndex] = Math.max(c1, c2);
    }

    return dp[startIndex][endIndex];
  }

  public static void main(String[] args) {
    LPS lps = new LPS();
    System.out.println(lps.findLPSLength("abdbca"));
    System.out.println(lps.findLPSLength("cddpd"));
    System.out.println(lps.findLPSLength("pqr"));
  }
}
```
The above algorithm has a time and space complexity of O(n^2) because we will not have more than n*nn‚àón subproblems.

- Bottom-up Dynamic Programming :

Since we want to try all the substrings of the given string, we can use a two-dimensional array to store the subproblems‚Äô results. So dp[i][j] will be ‚Äòtrue‚Äô if the substring from index ‚Äòi‚Äô to index ‚Äòj‚Äô is a palindrome.

We can start from the beginning of the string and keep adding one element at a time. At every step, we will try all of its substrings. So for every endIndex and startIndex in the given string, we need to check the following thing:

If the element at the startIndex matches the element at the endIndex, we will further check if the remaining substring (from startIndex+1 to endIndex-1) is a substring too.

So our recursive formula will look like:
```
if st[startIndex] == st[endIndex], and 
        if the remaing string is of zero length or dp[startIndex+1][endIndex-1] is a palindrome then
   dp[startIndex][endIndex] = true
```
- Code :tada:
```java

Here is the code for our bottom-up dynamic programming approach:

class LPS {

  public int findLPSLength(String st) {
    // dp[i][j] will be 'true' if the string from index 'i' to index 'j' is a
    // palindrome
    boolean[][] dp = new boolean[st.length()][st.length()];

    // every string with one character is a palindrome
    for (int i = 0; i < st.length(); i++)
      dp[i][i] = true;

    int maxLength = 1;
    for (int startIndex = st.length() - 1; startIndex >= 0; startIndex--) {
      for (int endIndex = startIndex + 1; endIndex < st.length(); endIndex++) {
        if (st.charAt(startIndex) == st.charAt(endIndex)) {
          // if it's a two character string or if the remaining string is a palindrome too
          if (endIndex - startIndex == 1 || dp[startIndex + 1][endIndex - 1]) {
            dp[startIndex][endIndex] = true;
            maxLength = Math.max(maxLength, endIndex - startIndex + 1);
          }
        }
      }
    }

    return maxLength;
  }

  public static void main(String[] args) {
    LPS lps = new LPS();
    System.out.println(lps.findLPSLength("abdbca"));
    System.out.println(lps.findLPSLength("cdpdd"));
    System.out.println(lps.findLPSLength("pqr"));
  }
}
```
The time and space complexity of the above algorithm is O(n^2), where ‚Äòn‚Äô is the length of the input string.

### Count Of Palindromic Substrings
<hr>

- Problem Statement :

Given a string, find the total number of palindromic substrings in it. Please note we need to find the total number of substrings and not subsequences.

- Example 1 :
```
Input: "abdbca" Output: 7 Explanation: Here are the palindromic substrings, "a", "b", "d", "b", "c", "a", "bdb".
```
- Example 2 :
```
Input: = "cddpd" Output: 7 Explanation: Here are the palindromic substrings, "c", "d", "d", "p", "d", "dd", "dpd".
```
- Basic Solution :

This problem follows the Longest Palindromic Subsequence pattern, and can be easily converted to Longest Palindromic Substring. The only difference is that instead of calculating the longest palindromic substring, we will instead count all the palindromic substrings. Let‚Äôs jump directly to the bottom-up dynamic programming solution:

- Code :tada:
```java

class CPS {

  public int findCPS(String st) {
    // dp[i][j] will be 'true' if the string from index 'i' to index 'j' is a
    // palindrome
    boolean[][] dp = new boolean[st.length()][st.length()];
    int count = 0;

    // every string with one character is a palindrome
    for (int i = 0; i < st.length(); i++) {
      dp[i][i] = true;
      count++;
    }

    for (int startIndex = st.length() - 1; startIndex >= 0; startIndex--) {
      for (int endIndex = startIndex + 1; endIndex < st.length(); endIndex++) {
        if (st.charAt(startIndex) == st.charAt(endIndex)) {
          // if it's a two character string or if the remaining string is a palindrome too
          if (endIndex - startIndex == 1 || dp[startIndex + 1][endIndex - 1]) {
            dp[startIndex][endIndex] = true;
            count++;
          }
        }
      }
    }

    return count;
  }

  public static void main(String[] args) {
    CPS cps = new CPS();
    System.out.println(cps.findCPS("abdbca"));
    System.out.println(cps.findCPS("cdpdd"));
    System.out.println(cps.findCPS("pqr"));
  }
}
```
The time and space complexity of the above algorithm is O(n^2), where ‚Äòn‚Äô is the length of the input string.

### Minimum Deletions In A String To Make It A Palindrome
<hr>

- Problem Statement :

Given a string, find the minimum number of characters that we can remove to make it a palindrome.

Example 1 :
```
Input: "abdbca" Output: 1 Explanation: By removing "c", we get a palindrome "abdba".
```
Example 2 :
```
Input: = "cddpd" Output: 2 Explanation: Deleting "cp", we get a palindrome "ddd".
```
- Basic Solution :

This problem can be easily converted to the Longest Palindromic Subsequence (LPS) problem. We can use the fact that LPS is the best subsequence we can have, so any character that is not part of LPS must be removed. Please note that it is ‚ÄòLongest Palindromic SubSequence‚Äô and not ‚ÄòLongest Palindrome Substring‚Äô. So, our solution for a given string ‚Äòst‚Äô will be:

Minimum_deletions_to_make_palindrome = Length(st) - LPS(st)

- Code :tada:

Let‚Äôs jump directly to bottom-up dynamic programming:
```java

class MDSP {

  public int findMinimumDeletions(String st) {
    // subtracting the length of Longest Palindromic Subsequence from the length of
    // the input string to get minimum number of deletions
    return st.length() - findLPSLength(st);
  }

  public int findLPSLength(String st) {
    // dp[i][j] stores the length of LPS from index 'i' to index 'j'
    int[][] dp = new int[st.length()][st.length()];

    // every sequence with one element is a palindrome of length 1
    for (int i = 0; i < st.length(); i++)
      dp[i][i] = 1;

    for (int startIndex = st.length() - 1; startIndex >= 0; startIndex--) {
      for (int endIndex = startIndex + 1; endIndex < st.length(); endIndex++) {
        // case 1: elements at the beginning and the end are the same
        if (st.charAt(startIndex) == st.charAt(endIndex)) {
          dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];
        } else { // case 2: skip one element either from the beginning or the end
          dp[startIndex][endIndex] = Math.max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1]);
        }
      }
    }
    return dp[0][st.length() - 1];
  }

  public static void main(String[] args) {
    MDSP mdsp = new MDSP();
    System.out.println(mdsp.findMinimumDeletions("abdbca"));
    System.out.println(mdsp.findMinimumDeletions("cddpd"));
    System.out.println(mdsp.findMinimumDeletions("pqr"));
  }
}
```
The time and space complexity of the above algorithm is O(n^2), where ‚Äòn‚Äô is the length of the input string.

### Palindromic Partitioning
<hr>

- Problem Statement :

Given a string, we want to cut it into pieces such that each piece is a palindrome. Write a function to return the minimum number of cuts needed.

- Example 1 :
```
Input: "abdbca" Output: 3 Explanation: Palindrome pieces are "a", "bdb", "c", "a".
```
- Example 2 :
```
Input: = "cddpd" Output: 2 Explanation: Palindrome pieces are "c", "d", "dpd".
```
- Basic Solution :

This problem follows the Longest Palindromic Subsequence pattern and shares a similar approach as that of the Longest Palindromic Substring. The brute-force solution will be to try all the substring combinations of the given string. We can start processing from the beginning of the string and keep adding one character at a time. At any step, if we get a palindrome, we take it as one piece and recursively process the remaining length of the string to find the minimum cuts needed. Here is the code:

- Code :tada:
```java

class MPP {

  public int findMPPCuts(String st) {
    return this.findMPPCutsRecursive(st, 0, st.length()-1);
  }

  private int findMPPCutsRecursive(String st, int startIndex, int endIndex) {
    // we don't need to cut the string if it is a palindrome
    if(startIndex >= endIndex || isPalindrome(st, startIndex, endIndex))
      return 0;

    // at max, we need to cut the string into its 'length-1' pieces
    int minimumCuts = endIndex-startIndex;
    for (int i=startIndex; i <= endIndex; i++) {
      if(isPalindrome(st, startIndex, i)){
        // we can cut here as we have a palindrome from 'startIndex' to 'i'
        minimumCuts = Math.min(minimumCuts, 1 + findMPPCutsRecursive(st, i+1, endIndex));
      }
    }
    return minimumCuts;
  }

  private boolean isPalindrome(String st, int x, int y) {
    while(x < y) {
      if(st.charAt(x++) != st.charAt(y--))
        return false;
    }
    return true;
  }

  public static void main(String[] args) {
    MPP mpp = new MPP();
    System.out.println(mpp.findMPPCuts("abdbca"));
    System.out.println(mpp.findMPPCuts("cdpdd"));
    System.out.println(mpp.findMPPCuts("pqr"));
    System.out.println(mpp.findMPPCuts("pp"));
   }
}
```
The time complexity of the above algorithm is exponential O(2^n), where ‚Äòn‚Äô is the length of the input string. The space complexity is O(n) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can memoize both functions `findMPPCutsRecursive()` and `isPalindrome()`. The two changing values in both these functions are the two indexes; therefore, we can store the results of all the subproblems in a two-dimensional array. (alternatively, we can use a hash-table). Here is the code:

- Code :tada:
```java

class MPP {

  public int findMPPCuts(String st) {
    Integer dp[][] = new Integer[st.length()][st.length()];
    Boolean dpIsPalindrome[][] = new Boolean[st.length()][st.length()];
    return this.findMPPCutsRecursive(dp, dpIsPalindrome, st, 0, st.length()-1);
  }

  private int findMPPCutsRecursive(Integer dp[][], Boolean dpIsPalindrome[][],
      String st, int startIndex, int endIndex) {

    if(startIndex >= endIndex || isPalindrome(dpIsPalindrome, st, startIndex, endIndex))
      return 0;

    if(dp[startIndex][endIndex] == null) {
      // at max, we need to cut the string into its 'length-1' pieces
      int minimumCuts = endIndex-startIndex;
      for (int i=startIndex; i <= endIndex; i++) {
        if(isPalindrome(dpIsPalindrome, st, startIndex, i)){
          // we can cut here as we have a palindrome from 'startIndex' to 'i'
          minimumCuts = Math.min(minimumCuts, 1+findMPPCutsRecursive(dp, dpIsPalindrome, st, i+1, endIndex));
        }
      }
      dp[startIndex][endIndex] = minimumCuts;
    }
    return dp[startIndex][endIndex];
  }

  private boolean isPalindrome(Boolean dpIsPalindrome[][], String st, int x, int y) {
    if(dpIsPalindrome[x][y] == null) {
      dpIsPalindrome[x][y]=true;
      int i=x, j=y;
      while(i < j) {
        if(st.charAt(i++) != st.charAt(j--)) {
          dpIsPalindrome[x][y]=false;
          break;
        }
        // use memoization to find if the remaining string is a palindrome
        if(i < j && dpIsPalindrome[i][j] != null) {
          dpIsPalindrome[x][y] = dpIsPalindrome[i][j];
          break;
        }
      }
    }
    return dpIsPalindrome[x][y];
  }

  public static void main(String[] args) {
    MPP mpp = new MPP();
    System.out.println(mpp.findMPPCuts("abdbca"));
    System.out.println(mpp.findMPPCuts("cdpdd"));
    System.out.println(mpp.findMPPCuts("pqr"));
    System.out.println(mpp.findMPPCuts("pp"));
   }
}
```
- Bottom-up Dynamic Programming :

The above solution tells us that we need to build two tables, one for the `isPalindrome()` and one for finding the minimum cuts needed. If you remember, we built a table in the Longest Palindromic Substring (LPS) chapter that can tell us what substrings (of the input string) are palindrome. We will use the same approach here to build the table required for `isPalindrome()`.

Here is the code for the bottom-up approach:

- Code :tada:
```java

class MPP {

  public int findMPPCuts(String st) {
    // isPalindrome[i][j] will be 'true' if the string from index 'i' to index 'j' is a palindrome
    boolean[][] isPalindrome = new boolean[st.length()][st.length()];

    // every string with one character is a palindrome
    for (int i = 0; i < st.length(); i++)
      isPalindrome[i][i] = true;

    // populate isPalindrome table
    for (int startIndex = st.length() - 1; startIndex >= 0; startIndex--) {
      for (int endIndex = startIndex + 1; endIndex < st.length(); endIndex++) {
        if (st.charAt(startIndex) == st.charAt(endIndex)) {
          // if it's a two character string or if the remaining string is a palindrome too
          if (endIndex - startIndex == 1 || isPalindrome[startIndex + 1][endIndex - 1]) {
            isPalindrome[startIndex][endIndex] = true;
          }
        }
      }
    }

    // now lets populate the second table, every index in 'cuts' stores the minimum cuts needed 
    // for the substring from that index till the end
    int[] cuts = new int[st.length()];
    for (int startIndex = st.length() - 1; startIndex >= 0; startIndex--) {
      int minCuts = st.length(); // maximum cuts
      for (int endIndex = st.length() - 1; endIndex >= startIndex; endIndex--) {
        if (isPalindrome[startIndex][endIndex]) {
          // we can cut here as we got a palindrome
          // also we dont need any cut if the whole substring is a palindrome
          minCuts = (endIndex == st.length() - 1) ? 0 : Math.min(minCuts, 1 + cuts[endIndex + 1]);
        }
      }
      cuts[startIndex] = minCuts;
    }

    return cuts[0];
  }

  public static void main(String[] args) {
    MPP mpp = new MPP();
    System.out.println(mpp.findMPPCuts("abdbca"));
    System.out.println(mpp.findMPPCuts("cdpdd"));
    System.out.println(mpp.findMPPCuts("pqr"));
    System.out.println(mpp.findMPPCuts("pp"));
    System.out.println(mpp.findMPPCuts("madam"));
  }
}
```
The time and space complexity of the above algorithm is O(n^2), where ‚Äòn‚Äô is the length of the input string.

### Longest Common Substring
<hr>

- Problem Statement :

Given two strings ‚Äòs1‚Äô and ‚Äòs2‚Äô, find the length of the longest substring which is common in both the strings.

- Example 1 :
```
Input: s1 = "abdca" s2 = "cbda" Output: 2 Explanation: The longest common substring is "bd".
```
- Example 2 :
```
Input: s1 = "passport" s2 = "ppsspt" Output: 3 Explanation: The longest common substring is "ssp".
```
- Basic Solution :

A basic brute-force solution could be to try all substrings of ‚Äòs1‚Äô and ‚Äòs2‚Äô to find the longest common one. We can start matching both the strings one character at a time, so we have two options at any step:

If the strings have a matching character, we can recursively match for the remaining lengths and keep a track of the current matching length.
If the strings don‚Äôt match, we start two new recursive calls by skipping one character separately from each string and reset the matching length.
The length of the Longest Common Substring (LCS) will be the maximum number returned by the three recurse calls in the above two options.

- Code :tada:
```java

class LCS {

  public int findLCSLength(String s1, String s2) {
      return findLCSLengthRecursive(s1, s2, 0, 0, 0);
  }

  private int findLCSLengthRecursive(String s1, String s2, int i1, int i2, int count) {
    if(i1 == s1.length() || i2 == s2.length())
      return count;

    if(s1.charAt(i1) == s2.charAt(i2))
      count = findLCSLengthRecursive(s1, s2, i1+1, i2+1, count+1);

    int c1 = findLCSLengthRecursive(s1, s2, i1, i2+1, 0);
    int c2 = findLCSLengthRecursive(s1, s2, i1+1, i2, 0);

    return Math.max(count, Math.max(c1, c2));
  }

  public static void main(String[] args) {
    LCS lcs = new LCS();
    System.out.println(lcs.findLCSLength("abdca", "cbda"));
    System.out.println(lcs.findLCSLength("passport", "ppsspt"));
  }
}
```
Because of the three recursive calls, the time complexity of the above algorithm is exponential O(3^{m+n}), where ‚Äòm‚Äô and ‚Äòn‚Äô are the lengths of the two input strings. The space complexity is O(m+n), this space will be used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use an array to store the already solved subproblems. The three changing values to our recursive function are the two indexes (i1 and i2) and the ‚Äòcount‚Äô. Therefore, we can store the results of all subproblems in a three-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (i1 + ‚Äú|‚Äù i2 + ‚Äú|‚Äù + count)).

- Code :tada:
```java

class LCS {

  public int findLCSLength(String s1, String s2) {
    int maxLength = Math.min(s1.length(), s2.length());
    Integer[][][] dp = new Integer[s1.length()][s2.length()][maxLength];
    return findLCSLengthRecursive(dp, s1, s2, 0, 0, 0);
  }

  private int findLCSLengthRecursive(Integer[][][] dp, String s1, String s2, int i1, int i2, int count) {
    if(i1 == s1.length() || i2 == s2.length())
      return count;

    if(dp[i1][i2][count] == null) {
      int c1 = count;
      if(s1.charAt(i1) == s2.charAt(i2))
        c1 = findLCSLengthRecursive(dp, s1, s2, i1+1, i2+1, count+1);
      int c2 = findLCSLengthRecursive(dp, s1, s2, i1, i2+1, 0);
      int c3 = findLCSLengthRecursive(dp, s1, s2, i1+1, i2, 0);
      dp[i1][i2][count] = Math.max(c1, Math.max(c2, c3));
    }

    return dp[i1][i2][count];
  }

  public static void main(String[] args) {
    LCS lcs = new LCS();
    System.out.println(lcs.findLCSLength("abdca", "cbda"));
    System.out.println(lcs.findLCSLength("passport", "ppsspt"));
  }
}
```
- Bottom-up Dynamic Programming :

Since we want to match all the substrings of the given two strings, we can use a two-dimensional array to store our results. The lengths of the two strings will define the size of the two dimensions of the array. So for every index ‚Äòi‚Äô in string ‚Äòs1‚Äô and ‚Äòj‚Äô in string ‚Äòs2‚Äô, we have two options:

If the character at `s1[i]` matches `s2[j]`, the length of the common substring would be one plus the length of the common substring till `i-1` and `j-1` indexes in the two strings.
If the character at the `s1[i]` does not match `s2[j]`, we don‚Äôt have any common substring. So our recursive formula would be:
```
if s1[i] == s2[j] 
  dp[i][j] = 1 + dp[i-1][j-1]
else 
  dp[i][j] = 0 
  ```
- Code :tada:
```java

class LCS {

  public int findLCSLength(String s1, String s2) {
    int[][] dp = new int[s1.length()+1][s2.length()+1];
    int maxLength = 0;
    for(int i=1; i <= s1.length(); i++) {
      for(int j=1; j <= s2.length(); j++) {
        if(s1.charAt(i-1) == s2.charAt(j-1)) {
          dp[i][j] = 1 + dp[i-1][j-1];
          maxLength = Math.max(maxLength, dp[i][j]);
        }
      }
    }
    return maxLength;
  }

  public static void main(String[] args) {
    LCS lcs = new LCS();
    System.out.println(lcs.findLCSLength("abdca", "cbda"));
    System.out.println(lcs.findLCSLength("passport", "ppsspt"));
  }
}
```
The time and space complexity of the above algorithm is O(mn)*, where ‚Äòm‚Äô and ‚Äòn‚Äô are the lengths of the two input strings.

### Longest Common Subsequence
<hr>

- Problem Statement :

Given two strings ‚Äòs1‚Äô and ‚Äòs2‚Äô, find the length of the longest subsequence which is common in both the strings. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

- Example 1 :
```
Input: s1 = "abdca" s2 = "cbda" Output: 3 Explanation: The longest common subsequence is "bda".
```
- Example 2 :
```
Input: s1 = "passport" s2 = "ppsspt" Output: 5 Explanation: The longest common subsequence is "psspt".
```
- Basic Solution :

A basic brute-force solution could be to try all subsequences of ‚Äòs1‚Äô and ‚Äòs2‚Äô to find the longest one. We can match both the strings one character at a time. So for every index ‚Äòi‚Äô in ‚Äòs1‚Äô and ‚Äòj‚Äô in ‚Äòs2‚Äô we must choose between:

If the character s1[i] matches s2[j], we can recursively match for the remaining lengths.
If the character s1[i] does not match s2[j], we will start two new recursive calls by skipping one character separately from each string.

- Code :tada:
```java

class LCS {

  public int findLCSLength(String s1, String s2) {
      return findLCSLengthRecursive(s1, s2, 0, 0);
  }

  private int findLCSLengthRecursive(String s1, String s2, int i1, int i2) {
    if(i1 == s1.length() || i2 == s2.length())
      return 0;

    if(s1.charAt(i1) == s2.charAt(i2))
      return 1 + findLCSLengthRecursive(s1, s2, i1+1, i2+1);

    int c1 = findLCSLengthRecursive(s1, s2, i1, i2+1);
    int c2 = findLCSLengthRecursive(s1, s2, i1+1, i2);

    return Math.max(c1, c2);
  }

  public static void main(String[] args) {
    LCS lcs = new LCS();
    System.out.println(lcs.findLCSLength("abdca", "cbda"));
    System.out.println(lcs.findLCSLength("passport", "ppsspt"));
  }
}
```
The time complexity of the above algorithm is exponential O(2^{m+n}), where ‚Äòm‚Äô and ‚Äòn‚Äô are the lengths of the two input strings. The space complexity is O(n+m) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use an array to store the already solved subproblems.

The two changing values to our recursive function are the two indexes, i1 and i2. Therefore, we can store the results of all the subproblems in a two-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (i1 + ‚Äú|‚Äù + i2)).

Here is the code:

- Code :tada:
```java

class LCS {

  public int findLCSLength(String s1, String s2) {
    Integer[][] dp = new Integer[s1.length()][s2.length()];
    return findLCSLengthRecursive(dp, s1, s2, 0, 0);
  }

  private int findLCSLengthRecursive(Integer[][] dp, String s1, String s2, int i1, int i2) {
    if (i1 == s1.length() || i2 == s2.length())
      return 0;

    if (dp[i1][i2] == null) {
      if (s1.charAt(i1) == s2.charAt(i2))
        dp[i1][i2] = 1 + findLCSLengthRecursive(dp, s1, s2, i1 + 1, i2 + 1);
      else {
        int c1 = findLCSLengthRecursive(dp, s1, s2, i1, i2 + 1);
        int c2 = findLCSLengthRecursive(dp, s1, s2, i1 + 1, i2);
        dp[i1][i2] = Math.max(c1, c2);
      }
    }

    return dp[i1][i2];
  }

  public static void main(String[] args) {
    LCS lcs = new LCS();
    System.out.println(lcs.findLCSLength("abdca", "cbda"));
    System.out.println(lcs.findLCSLength("passport", "ppsspt"));
  }
}
```
- Bottom-up Dynamic Programming :

Since we want to match all the subsequences of the given two strings, we can use a two-dimensional array to store our results. The lengths of the two strings will define the size of the array‚Äôs two dimensions. So for every index ‚Äòi‚Äô in string ‚Äòs1‚Äô and ‚Äòj‚Äô in string ‚Äòs2‚Äô, we will choose one of the following two options:

If the character `s1[i]` matches `s2[j]`, the length of the common subsequence would be one plus the length of the common subsequence till the `i-1` and `j-1` indexes in the two respective strings.
If the character `s1[i]` does not match `2[j]`, we will take the longest subsequence by either skipping ith or jth character from the respective strings. So our recursive formula would be:
```
if s1[i] == s2[j] 
  dp[i][j] = 1 + dp[i-1][j-1]
else 
  dp[i][j] = max(dp[i-1][j], dp[i][j-1])
  ```
Here is the code for our bottom-up dynamic programming approach:

- Code :tada:
```java

class LCS {

  public int findLCSLength(String s1, String s2) {
    int[][] dp = new int[s1.length()+1][s2.length()+1];
    int maxLength = 0;
    for(int i=1; i <= s1.length(); i++) {
      for(int j=1; j <= s2.length(); j++) {
        if(s1.charAt(i-1) == s2.charAt(j-1))
          dp[i][j] = 1 + dp[i-1][j-1];
        else
          dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        
        maxLength = Math.max(maxLength, dp[i][j]);
      }
    }
    return maxLength;
  }

  public static void main(String[] args) {
    LCS lcs = new LCS();
    System.out.println(lcs.findLCSLength("abdca", "cbda"));
    System.out.println(lcs.findLCSLength("passport", "ppsspt"));
  }
}
```
The time and space complexity of the above algorithm is O(mn)*, where ‚Äòm‚Äô and ‚Äòn‚Äô are the lengths of the two input strings.

### Minimum Deletions & Insertions to Transform a String into another
<hr>

- Problem Statement :

Given strings s1 and s2, we need to transform s1 into s2 by deleting and inserting characters. Write a function to calculate the count of the minimum number of deletion and insertion operations.

- Example 1 :
```
Input: s1 = "abc" s2 = "fbc" Output: 1 deletion and 1 insertion. Explanation: We need to delete {'a'} and insert {'f'} to s1 to transform it into s2.
```
- Example 2 :
```
Input: s1 = "abdca" s2 = "cbda" Output: 2 deletions and 1 insertion. Explanation: We need to delete {'a', 'c'} and insert {'c'} to s1 to transform it into s2.
```
- Example 3 :
```
- Input: s1 = "passport" s2 = "ppsspt" Output: 3 deletions and 1 insertion Explanation: We need to delete {'a', 'o', 'r'} and insert {'p'} to s1 to transform it into s2.
```
- Solution :

This problem can easily be converted to the Longest Common Subsequence (LCS). If we can find the LCS of the two input strings, we can easily find how many characters we need to insert and delete from s1. Here is how we can do this:

1. Let‚Äôs assume len1 is the length of s1 and len2 is the length of s2.
2. Now let‚Äôs assume c1 is the length of LCS of the two strings s1 and s2.
3. To transform s1 into s2, we need to delete everything from s1 which is not part of LCS, so minimum deletions we need to perform from s1 => len1 - c1
5. Similarly, we need to insert everything in s1 which is present in s2 but not part of LCS, so minimum insertions we need to perform in s1 => len2 - c
Let‚Äôs jump directly to the bottom-up dynamic programming solution:

- Bottom-up Dynamic Programming :

Here is the code for our bottom-up dynamic programming approach:

- Code :tada:
```java

Here is the code for our bottom-up dynamic programming approach:

class MDI {

  public void findMDI(String s1, String s2) {
    int c1 = findLCSLength(s1, s2);
    System.out.println("Minimum deletions needed: " + (s1.length() - c1));
    System.out.println("Minimum insertions needed: " + (s2.length() - c1));
  }
  
  private int findLCSLength(String s1, String s2) {
    int[][] dp = new int[s1.length()+1][s2.length()+1];
    int maxLength = 0;
    for(int i=1; i <= s1.length(); i++) {
      for(int j=1; j <= s2.length(); j++) {
        if(s1.charAt(i-1) == s2.charAt(j-1))
          dp[i][j] = 1 + dp[i-1][j-1];
        else
          dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        
        maxLength = Math.max(maxLength, dp[i][j]);
      }
    }
    return maxLength;
  }

  public static void main(String[] args) {
    MDI mdi = new MDI();
    mdi.findMDI("abc", "fbc");
    mdi.findMDI("abdca", "cbda");
    mdi.findMDI("passport", "ppsspt");
  }
}
```
The time and space complexity of the above algorithm is O(m*n), where ‚Äòm‚Äô and ‚Äòn‚Äô are the lengths of the two input strings.

### Longest Increasing Subsequence
<hr>

- Problem Statement :

Given a number sequence, find the length of its Longest Increasing Subsequence (LIS). In an increasing subsequence, all the elements are in increasing order (from lowest to highest).

- Example 1 :
```
Input: {4,2,3,6,10,1,12} Output: 5 Explanation: The LIS is {2,3,6,10,12}.
```
- Example 2:
```
Input: {-4,10,3,7,15} Output: 4 Explanation: The LIS is {-4,3,7,15}.
```
- Basic Solution :

A basic brute-force solution could be to try all the subsequences of the given number sequence. We can process one number at a time, so we have two options at any step:

If the current number is greater than the previous number that we included, we can increment our count and make a recursive call for the remaining array. We can skip the current number to make a recursive call for the remaining array. The length of the longest increasing subsequence will be the maximum number returned by the two recurse calls from the above two options.

- Code :tada:
```java

class LIS {

  public int findLISLength(int[] nums) {
      return findLISLengthRecursive(nums, 0, -1);
  }

  private int findLISLengthRecursive(int[] nums, int currentIndex, int previousIndex) {
    if(currentIndex == nums.length)
      return 0;

    // include nums[currentIndex] if it is larger than the last included number
    int c1 = 0;
    if(previousIndex == -1 || nums[currentIndex] > nums[previousIndex])
      c1 = 1 + findLISLengthRecursive(nums, currentIndex+1, currentIndex);

    // excluding the number at currentIndex
    int c2 = findLISLengthRecursive(nums, currentIndex+1, previousIndex);

    return Math.max(c1, c2);
  }

  public static void main(String[] args) {
    LIS lis = new LIS();
    int[] nums = {4,2,3,6,10,1,12};
    System.out.println(lis.findLISLength(nums));
    nums = new int[]{-4,10,3,7,15};
    System.out.println(lis.findLISLength(nums));
  }
}
```
The time complexity of the above algorithm is exponential O(2^n), where ‚Äòn‚Äô is the lengths of the input array. The space complexity is O(n) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

To overcome the overlapping subproblems, we can use an array to store the already solved subproblems.

The two changing values for our recursive function are the current and the previous index. Therefore, we can store the results of all subproblems in a two-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (currentIndex + ‚Äú|‚Äù + previousIndex)).

- Code :tada:
```java

class LIS {

  public int findLISLength(int[] nums) {
    Integer[][] dp = new Integer[nums.length][nums.length+1];
    return findLISLengthRecursive(dp, nums, 0, -1);
  }

  private int findLISLengthRecursive(Integer[][] dp, int[] nums, int currentIndex, int previousIndex) {
    if(currentIndex == nums.length)
      return 0;

    if(dp[currentIndex][previousIndex+1] == null) {
      // include nums[currentIndex] if it is larger than the last included number
      int c1 = 0;
      if(previousIndex == -1 || nums[currentIndex] > nums[previousIndex])
        c1 = 1 + findLISLengthRecursive(dp, nums, currentIndex+1, currentIndex);

      int c2 = findLISLengthRecursive(dp, nums, currentIndex+1, previousIndex);
      dp[currentIndex][previousIndex+1] = Math.max(c1, c2);
    }

    return dp[currentIndex][previousIndex+1];
  }

  public static void main(String[] args) {
    LIS lis = new LIS();
    int[] nums = {4,2,3,6,10,1,12};
    System.out.println(lis.findLISLength(nums));
    nums = new int[]{-4,10,3,7,15};
    System.out.println(lis.findLISLength(nums));
  }
}
```
- What is the time and space complexity of the above solution?

Since our memoization array `dp[nums.length()][nums.length()]` stores the results for all the subproblems, we can conclude that we will not have more than N*NN‚àóN subproblems (where ‚ÄòN‚Äô is the length of the input sequence). This means that our time complexity will be O(N^2). The above algorithm will be using O(N^2) space for the memoization array. Other than that we will use O(N)space for the recursion call-stack. So the total space complexity will be O(N^2 + N), which is asymptotically equivalent to O(N^2).

- Bottom-up Dynamic Programming :

The above algorithm tells us two things:

1. If the number at the current index is bigger than the number at the previous index, we increment the count for LIS up to the current index.
2. But if there is a bigger LIS without including the number at the current index, we take that.
So we need to find all the increasing subsequences for the number at index ‚Äòi‚Äô, from all the previous numbers (i.e. number till index ‚Äòi-1‚Äô), to eventually find the longest increasing subsequence.

If ‚Äòi‚Äô represents the ‚ÄòcurrentIndex‚Äô and ‚Äòj‚Äô represents the ‚ÄòpreviousIndex‚Äô, our recursive formula would look like:
```
  if num[i] > num[j] => dp[i] = dp[j] + 1 if there is no bigger LIS for 'i'
```
  Here is the code for our bottom-up dynamic programming approach:
  
- Code :tada:
```java

class LIS {

  public int findLISLength(int[] nums) {
    int[] dp = new int[nums.length];
    dp[0] = 1;    

    int maxLength = 1;
    for (int i=1; i<nums.length; i++) { 
      dp[i] = 1; 
      for (int j=0; j<i; j++)   
        if (nums[i] > nums[j] && dp[i] <= dp[j] ) {
          dp[i] = dp[j]+1;  
          maxLength = Math.max(maxLength, dp[i]);
        }
    } 
    return maxLength;
  }

  public static void main(String[] args) {
    LIS lis = new LIS();
    int[] nums = {4,2,3,6,10,1,12};
    System.out.println(lis.findLISLength(nums));
    nums = new int[]{-4,10,3,7,15};
    System.out.println(lis.findLISLength(nums));
  }
}
```
The time complexity of the above algorithm is O(n^2) and the space complexity is O(n).


### Maximum Sum Increasing Subsequence
<hr>

- Problem Statement :

Given a number sequence, find the increasing subsequence with the highest sum. Write a method that returns the highest sum.

- Example 1 :
```
Input: {4,1,2,6,10,1,12} Output: 32 Explanation: The increaseing sequence is {4,6,10,12}. Please note the difference, as the LIS is {1,2,6,10,12} which has a sum of '31'.
```
- Example 2 :
```
Input: {-4,10,3,7,15} Output: 25 Explanation: The increaseing sequences are {10, 15} and {3,7,15}.
```
- Basic Solution :

The problem is quite similar to the Longest Increasing Subsequence. The only difference is that, instead of finding the increasing subsequence with the maximum length, we need to find an increasing sequence with the maximum sum.

A basic brute-force solution could be to try all the subsequences of the given array. We can process one number at a time, so we have two options at any step:

If the current number is greater than the previous number that we included, we include that number in a running sum and make a recursive call for the remaining array. We can skip the current number to make a recursive call for the remaining array. The highest sum of any increasing subsequence would be the max value returned by the two recurse calls from the above two options. Here is the code:

- Code :tada:
```java

class MSIS {

  public int findMSIS(int[] nums) {
      return findMSISRecursive(nums, 0, -1, 0);
  }

  private int findMSISRecursive(int[] nums, int currentIndex, int previousIndex, int sum) {
    if(currentIndex == nums.length)
      return sum;

    // include nums[currentIndex] if it is larger than the last included number
    int s1 = sum;
    if(previousIndex == -1 || nums[currentIndex] > nums[previousIndex])
      s1 = findMSISRecursive(nums, currentIndex+1, currentIndex, sum + nums[currentIndex]);

    // excluding the number at currentIndex
    int s2 = findMSISRecursive(nums, currentIndex+1, previousIndex, sum);

    return Math.max(s1, s2);
  }

  public static void main(String[] args) {
    MSIS msis = new MSIS();
    int[] nums = {4,1,2,6,10,1,12};
    System.out.println(msis.findMSIS(nums));
    nums = new int[]{-4,10,3,7,15};
    System.out.println(msis.findMSIS(nums));
  }
}
```
The time complexity of the above algorithm is exponential O(2^n), where ‚Äòn‚Äô is the lengths of the input array. The space complexity is O(n) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use memoization to overcome the overlapping subproblems.

The three changing values for our recursive function are the current index, the previous index, and the sum. An efficient way of storing the results of the subproblems could be a hash-table whose key would be a string (currentIndex + ‚Äú|‚Äù + previousIndex + ‚Äú|‚Äù + sum).

Here is the code :

- Code :tada:
```java

import java.util.HashMap;
import java.util.Map;

class MSIS {

  public int findMSIS(int[] nums) {
    Map<String, Integer> dp = new HashMap<>();  
    return findMSISRecursive(dp, nums, 0, -1, 0);
  }

  private int findMSISRecursive(Map<String, Integer> dp, int[] nums, int currentIndex, int previousIndex, int sum) {
    if(currentIndex == nums.length)
      return sum;

    String subProblemKey = currentIndex + "-" + previousIndex + "-" + sum;
    if(!dp.containsKey(subProblemKey)) {
      // include nums[currentIndex] if it is larger than the last included number
      int s1 = sum;
      if(previousIndex == -1 || nums[currentIndex] > nums[previousIndex])
        s1 = findMSISRecursive(dp, nums, currentIndex+1, currentIndex, sum + nums[currentIndex]);

      // excluding the number at currentIndex
      int s2 = findMSISRecursive(dp, nums, currentIndex+1, previousIndex, sum);
      dp.put(subProblemKey, Math.max(s1, s2));
    }

    return dp.get(subProblemKey);
  }

  public static void main(String[] args) {
    MSIS msis = new MSIS();
    int[] nums = {4,1,2,6,10,1,12};
    System.out.println(msis.findMSIS(nums));
    nums = new int[]{-4,10,3,7,15};
    System.out.println(msis.findMSIS(nums));
    nums = new int[]{1,3,8,4,14,6,14,1,9,4,13,3,11,17,29};
    System.out.println(msis.findMSIS(nums));
  }
}
```
- Bottom-up Dynamic Programming :

The above algorithm tells us two things:

If the number at the current index is bigger than the number at the previous index, we include that number in the sum for an increasing sequence up to the current index. But if there is a maximum sum increasing subsequence (MSIS), without including the number at the current index, we take that. So we need to find all the increasing subsequences for a number at index i, from all the previous numbers (i.e. numbers till index i-1), to find MSIS.

If i represents the currentIndex and ‚Äòj‚Äô represents the previousIndex, our recursive formula would look like:
```
if num[i] > num[j] => dp[i] = dp[j] + num[i] if there is no bigger MSIS for 'i'
```
Here is the code for our bottom-up dynamic programming approach:

- Code :tada:
```java

class MSIS {

  public int findMSIS(int[] nums) {
    int[] dp = new int[nums.length];
    dp[0] = nums[0];    

    int maxSum = nums[0];
    for (int i=1; i<nums.length; i++) { 
      dp[i] = nums[i];
      for (int j=0; j<i; j++) {   
        if (nums[i] > nums[j] && dp[i] < dp[j] + nums[i])
          dp[i] = dp[j] + nums[i];  
      }
      maxSum = Math.max(maxSum, dp[i]);
    } 

    return maxSum;
  }

  public static void main(String[] args) {
    MSIS msis = new MSIS();
    int[] nums = {4,1,2,6,10,1,12};
    System.out.println(msis.findMSIS(nums));
    nums = new int[]{-4,10,3,7,15};
    System.out.println(msis.findMSIS(nums));
    nums = new int[]{1,3,8,4,14,6,14,1,9,4,13,3,11,17,29};
    System.out.println(msis.findMSIS(nums));
  }
}
```
The time complexity of the above algorithm is O(n^2) and the space complexity is O(n).

### Subsequence Pattern Matching
<hr>

- Problem Statement :

Given a string and a pattern, write a method to count the number of times the pattern appears in the string as a subsequence.

- Example 1 :
```
Input: string: ‚Äúbaxmx‚Äù, pattern: ‚Äúax‚Äù Output: 2 Explanation: {baxmx, baxmx}.
```
- Example 2 :
```
Input: string: ‚Äútomorrow‚Äù, pattern: ‚Äútor‚Äù Output: 4 Explanation: Following are the four occurences: {tomorrow, tomorrow, tomorrow, tomorrow}.
```
- Basic Solution :

This problem follows the Longest Common Subsequence (LCS) pattern and is quite similar to the Longest Repeating Subsequence; the difference is that we need to count the total occurrences of the subsequence.

A basic brute-force solution could be to try all the subsequences of the given string to count all that match the given pattern. We can match the pattern with the given string one character at a time, so we can do two things at any step:

1. If the pattern has a matching character with the string, we can recursively match for the remaining lengths of the pattern and the string.
2. At every step, we can always skip a character from the string to try to match the remaining string with the pattern. So we can start a recursive call by skipping one character from the string.
Our total count will be the sum of the counts returned by the above two options.

Here is the code:

- Code :tada:
```java

class SPM {

  public int findSPMCount(String str, String pat) {
    return findSPMCountRecursive(str, pat, 0, 0);
  }

  private int findSPMCountRecursive(String str, String pat, int strIndex, int patIndex) {

    // if we have reached the end of the pattern
    if(patIndex == pat.length())
      return 1;

    // if we have reached the end of the string but pattern has still some characters left
    if(strIndex == str.length())
      return 0;

    int c1 = 0;
    if(str.charAt(strIndex) == pat.charAt(patIndex))
      c1 = findSPMCountRecursive(str, pat, strIndex+1, patIndex+1);

    int c2 = findSPMCountRecursive(str, pat, strIndex+1, patIndex);

    return c1 + c2;
  }

  public static void main(String[] args) {
    SPM spm = new SPM();
    System.out.println(spm.findSPMCount("baxmx", "ax"));
    System.out.println(spm.findSPMCount("tomorrow", "tor"));
  }
}
```
The time complexity of the above algorithm is exponential O(2^{m}), where ‚Äòm‚Äô is the length of the string, as our recursion stack will not be deeper than m. The space complexity is O(m) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use an array to store the already solved subproblems.

The two changing values to our recursive function are the two indexes strIndex and patIndex. Therefore, we can store the results of all the subproblems in a two-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (strIndex + ‚Äú|‚Äù + patIndex)).

Here is the code:

- Code  :tada:
```java

class SPM {

  public int findSPMCount(String str, String pat) {
    Integer[][] dp = new Integer[str.length()][pat.length()];
    return findSPMCountRecursive(dp, str, pat, 0, 0);
  }

  private int findSPMCountRecursive(Integer[][] dp, String str, String pat, int strIndex, int patIndex) {

    // if we have reached the end of the pattern
    if(patIndex == pat.length())
      return 1;

    // if we have reached the end of the string but pattern has still some characters left
    if(strIndex == str.length())
      return 0;

    if(dp[strIndex][patIndex] == null) {
      int c1 = 0;
      if(str.charAt(strIndex) == pat.charAt(patIndex))
        c1 = findSPMCountRecursive(dp, str, pat, strIndex+1, patIndex+1);
      int c2 = findSPMCountRecursive(dp, str, pat, strIndex+1, patIndex);
      dp[strIndex][patIndex] = c1 + c2;
    }

    return dp[strIndex][patIndex];
  }

  public static void main(String[] args) {
    SPM spm = new SPM();
    System.out.println(spm.findSPMCount("baxmx", "ax"));
    System.out.println(spm.findSPMCount("tomorrow", "tor"));
  }
}
```
- Bottom-up Dynamic Programming :

Since we want to match all the subsequences of the given string, we can use a two-dimensional array to store our results. As mentioned above, we will be tracking separate indexes for the string and the pattern, so we will be doing two things for every value of strIndex and patIndex:

1. If the character at the strIndex (in the string) matches the character at patIndex (in the pattern), the count of the SPM would be equal to the count of SPM up to strIndex-1 and patIndex-1.
2. At every step, we can always skip a character from the string to try matching the remaining string with the pattern; therefore, we can add the SPM count from the indexes strIndex-1 and patIndex.
So our recursive formula would be:
```
if str[strIndex] == pat[patIndex] {
  dp[strIndex][patIndex] = dp[strIndex-1][patIndex-1]
}
dp[strIndex][patIndex] += dp[strIndex-1][patIndex]
```
Here is the code for our bottom-up dynamic programming approach:

- Code :tada:
```java

class SPM {

  public int findSPMCount(String str, String pat) {
    // every empty pattern has one match
    if(pat.length() == 0)
      return 1;
    
    if(str.length() == 0 || pat.length() > str.length())
      return 0;

    // dp[strIndex][patIndex] will be storing the count of SPM up to str[0..strIndex-1][0..patIndex-1]
    int[][] dp = new int[str.length()+1][pat.length()+1];

    // for the empty pattern, we have one matching
    for(int i=0; i<=str.length(); i++)
      dp[i][0] = 1;

    for(int strIndex=1; strIndex<=str.length(); strIndex++) {
      for(int patIndex=1; patIndex<=pat.length(); patIndex++) {
        if(str.charAt(strIndex-1) == pat.charAt(patIndex-1))
          dp[strIndex][patIndex] = dp[strIndex-1][patIndex-1];
        dp[strIndex][patIndex] += dp[strIndex-1][patIndex];
      }
    }

    return dp[str.length()][pat.length()];
  }

  public static void main(String[] args) {
    SPM spm = new SPM();
    System.out.println(spm.findSPMCount("baxmx", "ax"));
    System.out.println(spm.findSPMCount("tomorrow", "tor"));
  }
}
```
The time and space complexity of the above algorithm is O(m*n), where ‚Äòm‚Äô and ‚Äòn‚Äô are the lengths of the string and the pattern respectively.

### Longest Bitonic Subsequence
<hr>

- Problem Statement :

Given a number sequence, find the length of its Longest Bitonic Subsequence (LBS). A subsequence is considered bitonic if it is monotonically increasing and then monotonically decreasing.

- Example 1:
```
Input: {4,2,3,6,10,1,12} Output: 5 Explanation: The LBS is {2,3,6,10,1}.
```
- Example 2 :
```
Input: {4,2,5,9,7,6,10,3,1} Output: 7 Explanation: The LBS is {4,5,9,7,6,3,1}.
```
- Basic Solution :

A basic brute-force solution could be to try finding the Longest Decreasing Subsequences (LDS), starting from every number in both directions. So for every index ‚Äòi‚Äô in the given array, we will do two things:

1. Find LDS starting from ‚Äòi‚Äô to the end of the array.
2. Find LDS starting from ‚Äòi‚Äô to the beginning of the array.
LBS would be the maximum sum of the above two subsequences. Here is the code:

- Code :tada:
```java

class LBS {

  private int findLBSLength(int[] nums) {
    int maxLength = 0;
    for(int i=0; i<nums.length; i++) {
      int c1 = findLDSLength(nums, i, -1);
      int c2 = findLDSLengthRev(nums, i, -1);
      maxLength = Math.max(maxLength, c1+c2-1);
    }
    return maxLength;
  }

  // find the longest decreasing subsequence from currentIndex till the end of the array
  private int findLDSLength(int[] nums, int currentIndex, int previousIndex) {
    if(currentIndex == nums.length)
      return 0;

    // include nums[currentIndex] if it is smaller than the previous number
    int c1 = 0;
    if(previousIndex == -1 || nums[currentIndex] < nums[previousIndex])
      c1 = 1 + findLDSLength(nums, currentIndex+1, currentIndex);

    // excluding the number at currentIndex
    int c2 = findLDSLength(nums, currentIndex+1, previousIndex);

    return Math.max(c1, c2);
  }

  // find the longest decreasing subsequence from currentIndex till the beginning of the array
  private int findLDSLengthRev(int[] nums, int currentIndex, int previousIndex) {
    if(currentIndex < 0)
      return 0;

    // include nums[currentIndex] if it is smaller than the previous number
    int c1 = 0;
    if(previousIndex == -1 || nums[currentIndex] < nums[previousIndex])
      c1 = 1 + findLDSLengthRev(nums, currentIndex-1, currentIndex);

    // excluding the number at currentIndex
    int c2 = findLDSLengthRev(nums, currentIndex-1, previousIndex);

    return Math.max(c1, c2);
  }

  public static void main(String[] args) {
    LBS lbs = new LBS();
    int[] nums = {4,2,3,6,10,1,12};
    System.out.println(lbs.findLBSLength(nums));
    nums = new int[]{4,2,5,9,7,6,10,3,1};
    System.out.println(lbs.findLBSLength(nums));
  }
}
```
The time complexity of the above algorithm is exponential O(2^n), where ‚Äòn‚Äô is the lengths of the input array. The space complexity is O(n) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

To overcome the overlapping subproblems, we can use an array to store the already solved subproblems.

We need to memoize the recursive functions that calculate the longest decreasing subsequence. The two changing values for our recursive function are the current and the previous index. Therefore, we can store the results of all subproblems in a two-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (currentIndex + ‚Äú|‚Äù + previousIndex)).

Here is the code:

- Code :tada:
```java

class LBS {

  private int findLBSLength(int[] nums) {
    Integer[][] lds = new Integer[nums.length][nums.length+1];
    Integer[][] ldsRev = new Integer[nums.length][nums.length+1];

    int maxLength = 0;
    for(int i=0; i<nums.length; i++) {
      int c1 = findLDSLength(lds, nums, i, -1);
      int c2 = findLDSLengthReverse(ldsRev, nums, i, -1);
      maxLength = Math.max(maxLength, c1+c2-1);
    }

    return maxLength;
  }

  // find the longest decreasing subsequence from currentIndex till the end of the array
  private int findLDSLength(Integer[][] dp, int[] nums, int currentIndex, int previousIndex) {
    if(currentIndex == nums.length)
      return 0;

    if(dp[currentIndex][previousIndex+1] == null) {
      // include nums[currentIndex] if it is smaller than the previous number
      int c1 = 0;
      if(previousIndex == -1 || nums[currentIndex] < nums[previousIndex])
        c1 = 1 + findLDSLength(dp, nums, currentIndex+1, currentIndex);

      // excluding the number at currentIndex
      int c2 = findLDSLength(dp, nums, currentIndex+1, previousIndex);

      dp[currentIndex][previousIndex+1] = Math.max(c1, c2);
    }

    return dp[currentIndex][previousIndex+1];
  }

  // find the longest decreasing subsequence from currentIndex till the beginning of the array
  private int findLDSLengthReverse(Integer[][] dp, int[] nums, int currentIndex, int previousIndex) {
    if(currentIndex < 0)
      return 0;

    if(dp[currentIndex][previousIndex+1] == null) {
      // include nums[currentIndex] if it is smaller than the previous number
      int c1 = 0;
      if(previousIndex == -1 || nums[currentIndex] < nums[previousIndex])
        c1 = 1 + findLDSLengthReverse(dp, nums, currentIndex-1, currentIndex);

      // excluding the number at currentIndex
      int c2 = findLDSLengthReverse(dp, nums, currentIndex-1, previousIndex);

      dp[currentIndex][previousIndex+1] = Math.max(c1, c2);
    }
    return dp[currentIndex][previousIndex+1];
  }

  public static void main(String[] args) {
    LBS lbs = new LBS();
    int[] nums = {4,2,3,6,10,1,12};
    System.out.println(lbs.findLBSLength(nums));
    nums = new int[]{4,2,5,9,7,6,10,3,1};
    System.out.println(lbs.findLBSLength(nums));
  }
}
```
- Bottom-up Dynamic Programming :

The above algorithm shows us a clear bottom-up approach. We can separately calculate LDS for every index i.e., from the beginning to the end of the array and vice versa. The required length of LBS would be the one that has the maximum sum of LDS for a given index (from both ends).

Here is the code for our bottom-up dynamic programming approach:

- Code :tada:
```java

class LBS {
  private int findLBSLength(int[] nums) {
    int[] lds = new int[nums.length];
    int[] ldsReverse = new int[nums.length];

    // find LDS for every index up to the beginning of the array
    for (int i = 0; i < nums.length; i++) {
      lds[i] = 1; // every element is an LDS of length 1
      for (int j = i - 1; j >= 0; j--)
        if (nums[j] < nums[i]) {
          lds[i] = Math.max(lds[i], lds[j] + 1);
        }
    }

    // find LDS for every index up to the end of the array
    for (int i = nums.length - 1; i >= 0; i--) {
      ldsReverse[i] = 1; // every element is an LDS of length 1
      for (int j = i + 1; j < nums.length; j++)
        if (nums[j] < nums[i]) {
          ldsReverse[i] = Math.max(ldsReverse[i], ldsReverse[j] + 1);
        }
    }

    int maxLength = 0;
    for (int i = 0; i < nums.length; i++) {
      maxLength = Math.max(maxLength, lds[i] + ldsReverse[i] - 1);
    }

    return maxLength;
  }

  public static void main(String[] args) {
    LBS lbs = new LBS();
    int[] nums = { 4, 2, 3, 6, 10, 1, 12 };
    System.out.println(lbs.findLBSLength(nums));
    nums = new int[] { 4, 2, 5, 9, 7, 6, 10, 3, 1 };
    System.out.println(lbs.findLBSLength(nums));
  }
}
```
The time complexity of the above algorithm is O(n^2) and the space complexity is O(n).

### Edit Distance
<hr>

- Problem Statement :

Given strings s1 and s2, we need to transform s1 into s2 by deleting, inserting, or replacing characters. Write a function to calculate the count of the minimum number of edit operations.

- Example 1 :
```
Input: s1 = "bat" s2 = "but" Output: 1 Explanation: We just need to replace 'a' with 'u' to transform s1 to s2.
```
- Example 2 :
```
Input: s1 = "abdca" s2 = "cbda" Output: 2 Explanation: We can replace first 'a' with 'c' and delete second 'c'.
```
- Example 3 :
```
Input: s1 = "passpot" s2 = "ppsspqrt" Output: 3 Explanation: Replace 'a' with 'p', 'o' with 'q', and insert 'r'.
```
- Basic Solution :

A basic brute-force solution could be to try all operations (one by one) on each character of s1. We can iterate through s1 and s2 together. Let‚Äôs assume index1 and index2 point to the current indexes of s1 and s2 respectively, so we have two options at every step:

If the strings have a matching character, we can recursively match for the remaining lengths.
If the strings don‚Äôt match, we start three new recursive calls representing the three edit operations. Whichever recursive call returns the minimum count of operations will be our answer.

- Code :tada:
```java

Here is the recursive implementation:

class EditDistance {

  public int findMinOperations(String s1, String s2) {
    return findMinOperationsRecursive(s1, s2, 0, 0);
  }

  private int findMinOperationsRecursive(String s1, String s2, int i1, int i2) {

    // if we have reached the end of s1, then we have to insert all the remaining characters of s2
    if(i1 == s1.length())
      return s2.length() - i2;

    // if we have reached the end of s2, then we have to delete all the remaining characters of s1
    if(i2 == s2.length())
      return s1.length() - i1;

    // If the strings have a matching character, we can recursively match for the remaining lengths.
    if(s1.charAt(i1) == s2.charAt(i2))
      return findMinOperationsRecursive(s1, s2, i1+1, i2+1);

    int c1 = 1 + findMinOperationsRecursive(s1, s2, i1+1, i2); //perform deletion
    int c2 = 1 + findMinOperationsRecursive(s1, s2, i1, i2+1); //perform insertion
    int c3 = 1 + findMinOperationsRecursive(s1, s2, i1+1, i2+1); // perform replacement

    return  Math.min(c1, Math.min(c2, c3));
  }

  public static void main(String[] args) {
    EditDistance editDisatnce = new EditDistance();
    System.out.println(editDisatnce.findMinOperations("bat", "but"));
    System.out.println(editDisatnce.findMinOperations("abdca", "cbda"));
    System.out.println(editDisatnce.findMinOperations("passpot", "ppsspqrt"));
  }
}
```
Because of the three recursive calls, the time complexity of the above algorithm is exponential O(3^{m+n}), where ‚Äòm‚Äô and ‚Äòn‚Äô are the lengths of the two input strings. The space complexity is O(n+m) which is used to store the recursion stack.

- Top-down Dynamic Programming with Memoization :

We can use an array to store the already solved subproblems.

The two changing values in our recursive function are the two indexes, i1 and i2. Therefore, we can store the results of all the subproblems in a two-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (i1 + ‚Äú|‚Äù + i2)).

Here is the code:

- Code :tada:
```java

class EditDistance {

  public int findMinOperations(String s1, String s2) {
    Integer[][] dp = new Integer[s1.length()+1][s2.length()+1];
    return findMinOperationsRecursive(dp, s1, s2, 0, 0);
  }

  private int findMinOperationsRecursive(Integer[][] dp, String s1, String s2, int i1, int i2) {
    
    if(dp[i1][i2] == null) {
      // if we have reached the end of s1, then we have to insert all the remaining characters of s2
      if(i1 == s1.length())
        dp[i1][i2] = s2.length() - i2;

      // if we have reached the end of s2, then we have to delete all the remaining characters of s1
      else if(i2 == s2.length())
        dp[i1][i2] = s1.length() - i1;

      // If the strings have a matching character, we can recursively match for the remaining lengths
      else if(s1.charAt(i1) == s2.charAt(i2))
        dp[i1][i2] = findMinOperationsRecursive(dp, s1, s2, i1+1, i2+1);
      else {
        int c1 = findMinOperationsRecursive(dp, s1, s2, i1+1, i2); //delete
        int c2 = findMinOperationsRecursive(dp, s1, s2, i1, i2+1); //insert
        int c3 = findMinOperationsRecursive(dp, s1, s2, i1+1, i2+1); //replace
        dp[i1][i2] = 1 + Math.min(c1, Math.min(c2, c3));
      }
    }
    
    return dp[i1][i2];
  }

  public static void main(String[] args) {
    EditDistance editDisatnce = new EditDistance();
    System.out.println(editDisatnce.findMinOperations("bat", "but"));
    System.out.println(editDisatnce.findMinOperations("abdca", "cbda"));
    System.out.println(editDisatnce.findMinOperations("passpot", "ppsspqrt"));
  }
}
```
- What is the time and space complexity of the above solution?

Since our memoization array `dp[s1.length()][s2.length()]` stores the results for all the subproblems, we can conclude that we will not have more than mnm‚àón subproblems (where ‚Äòm‚Äô and ‚Äòn‚Äô are the lengths of the two input strings.). This means that our time complexity will be O(mn).

The above algorithm will be using O(mn) space for the memoization array. Other than that we will use O(m+n) space for the recursion call-stack. So the total space complexity will be O(mn + (m+n)), which is asymptotically equivalent to O(m*n).

- Bottom-up Dynamic Programming :

Since we want to match all the characters of the given two strings, we can use a two-dimensional array to store our results. The lengths of the two strings will define the size of the two dimensions of the array. So for every index ‚Äòi1‚Äô in string ‚Äòs1‚Äô and ‚Äòi2‚Äô in string ‚Äòs2‚Äô, we will choose one of the following options:

1. If the character s1[i1] matches s2[i2], the count of the edit operations will be equal to the count of the edit operations for the remaining strings.
2. If the character s1[i1] does not match s2[i2], we will take the minimum count from the remaining strings after performing any of the three edit operations.
So our recursive formula would be:
```
if s1[i1] == s2[i2] 
  dp[i1][i2] = dp[i1-1][i2-1]
else 
  dp[i1][i2] = 1 + min(dp[i1-1][i2], // delete
                       dp[i1][i2-1], // insert 
                       dp[i1-1][i2-1]) // replace
```
Here is the code for our bottom-up dynamic programming approach:

- Code :tada:
```java

class EditDistance {

  public int findMinOperations(String s1, String s2) {
    int[][] dp = new int[s1.length()+1][s2.length()+1];

    // if s2 is empty, we can remove all the characters of s1 to make it empty too
    for(int i1=0; i1 <= s1.length(); i1++)
      dp[i1][0] = i1;

    // if s1 is empty, we have to insert all the characters of s2
    for(int i2=0; i2 <= s2.length(); i2++)
      dp[0][i2] = i2;
      
    for(int i1=1; i1 <= s1.length(); i1++) {
      for(int i2=1; i2 <= s2.length(); i2++) {
        // If the strings have a matching character, we can recursively match for the remaining lengths
        if(s1.charAt(i1-1) == s2.charAt(i2-1))
          dp[i1][i2] = dp[i1-1][i2-1];
        else
          dp[i1][i2] = 1 + Math.min(dp[i1-1][i2], //delete
                            Math.min(dp[i1][i2-1], //insert
                                     dp[i1-1][i2-1])); //replace
      }
    }

    return dp[s1.length()][s2.length()];
  }

  public static void main(String[] args) {
    EditDistance editDisatnce = new EditDistance();
    System.out.println(editDisatnce.findMinOperations("bat", "but"));
    System.out.println(editDisatnce.findMinOperations("abdca", "cbda"));
    System.out.println(editDisatnce.findMinOperations("passpot", "ppsspqrt"));
  }
}
```
The time and space complexity of the above algorithm is O(n*m), where ‚Äòm‚Äô and ‚Äòn‚Äô are the lengths of the two input strings.

### Egg Dropping Problem
<hr>

- Problem Statement :

Given a tall skyscraper and a few eggs, write a function to figure out how many tries it would take to figure out which floor of the skyscraper the eggs can be dropped from without breaking. Here are some rules:

1. An egg that survives a fall can be used again but a broken egg must be discarded.
2. The effect of a fall is the same for all eggs.
3. If an egg breaks when dropped from a certain floor, it would also break if dropped from a higher floor.
4. If an egg survives a fall from a certain floor, it would also survive a shorter fall.

- Input :

The inputs are two integers that represent the number of stories of the skyscraper and number of eggs respectively

- Output :

The output is the least number of egg-droppings to figure out the critical floor

- Sample input :
```
int eggs = 6; int floors = 15;
```
- Sample output :
```
4
```
- Brute force :

Let‚Äôs start by looking at the brute force solution to this problem:

Here is the recursive implementation:

- Code :tada:
```java

class EggDropping
{
  public static int eggDrop(int eggs, int floors) 
  {
    // If there are no eggs, then there can't be any tries
    if (eggs <= 0)
      return 0;
    
    // If there are no floors, then no trials needed. OR if there is 
    // one floor, one trial needed.
    if (floors == 1 || floors == 0)
      return floors;

    // We need k trials for one egg and k floors 
    if (eggs == 1)
      return floors;

    int min = Integer.MAX_VALUE;
    int x, res;

    // Consider all droppings from 1st floor to kth floor and 
    // return the minimum of these values plus 1. 
    for (x = 1; x <= floors; x++) {
      res = Math.max(eggDrop(eggs - 1, x - 1), eggDrop(eggs, floors - x));
    if (res < min)
        min = res;
    }

    return min + 1;
  }
 
  public static void main(String args[]) 
  {
    int eggs = 2, floors = 10;
    System.out.println("With " + eggs + " eggs and " + floors + " floors, the minimum number of trials in worst are: " + eggDrop(eggs, floors));
  }
};
```
- Explanation :

When we drop an egg from a floor x, there can be two cases:

The egg breaks.
The egg doesn‚Äôt break.
1. If the egg breaks after dropping it from xth floor, we only need to check for floors lower than x with the remaining eggs; so, the problem reduces to x-1 floors and n-1 eggs (line 24).
2. If the egg doesn‚Äôt break after dropping it from the xth floor, we only need to check for floors higher than x; so, the problem reduces to k-x floors and n eggs (line 24).
Since we need to minimize the number of trials in the worst case, we take the maximum from both cases (line 24). We consider the max of the above two cases for every floor and choose the one which yields the minimum number of trials (lines 25-26).

**Solution #2: Memoization**

The solution above, even though it is correct, results in redundant recursive calls which can be avoided if the solution is memoized:

Here is the code:

- Code :tada:
```java

class EggDropping
{
  public static int eggDropRec(int eggs, int floors, int [][] lookupTable) 
  {
    // If there are no eggs, then there can't be any tries
    if (eggs <= 0)
      return 0;
    
    // If there are no floors, then no trials needed. OR if there is 
    // one floor, one trial needed.
    if (floors == 1 || floors == 0)
      return floors;

    // We need k trials for one egg and k floors 
    if (eggs == 1)
      return floors;
    
    lookupTable[eggs][floors] = Integer.MAX_VALUE;
    int x, res;

    // Consider all droppings from 1st floor to kth floor and 
    // return the minimum of these values plus 1. 
    for (x = 1; x <= floors; x++) 
    {
      res = 1 + Math.max(eggDropRec(eggs - 1, x - 1, lookupTable), eggDropRec(eggs, floors - x, lookupTable));
      if (res < lookupTable[eggs][floors])
        lookupTable[eggs][floors] = res;
    }
    return lookupTable[eggs][floors];
  }

  public static int eggDrop(int eggs, int floors) 
  {
    int [][] lookupTable;
    lookupTable = new int[eggs + 1][];
    for (int i = 0; i < eggs + 1; i++) {
      lookupTable[i] = new int[floors + 1];
      for (int j = 0; j < floors + 1; j++)
        lookupTable[i][j] = 0;
    }
    return eggDropRec(eggs, floors, lookupTable);
  }

  public static void main(String args[]) 
  {
    int eggs = 2, floors = 10;
    System.out.println("With " + eggs + " eggs and " + floors + " floors, the minimum number of trials in worst case are: " + eggDrop(eggs, floors));
  }
};
```
- Explanation :

In the memoized approach, we use a 2-D array, `lookupTable` (initialized in the `eggDrop` function (lines 34-39)), to keep track of the eggs as well as the floors. We store all the computations in this lookupTable. Hence, we store the minimum number of tries needed for i eggs and j floors in the `lookupTable` (lines 25-27).

The only difference between this approach and the brute force solution is that, since the values are stored in the `lookupTable`, the next time the function is called with the same arguments, instead of making another recursive call, the value is returned directly from the `lookupTable` (line 29).

**Solution #3: Tabularization**

In the above solution, we saw the top-down approach. Now let‚Äôs look at the bottom-up tabular approach.

Here is the code for our bottom-up dynamic programming approach:

- Code :tada"
```java

class EggDropping
{

  public static int eggDrop(int eggs, int floors) 
  {
    // If there are no eggs, then there can't be any tries
    if (eggs <= 0)
      return 0;
    
    // If there are no floors, then no trials needed. OR if there is 
    // one floor, one trial needed.
    if (floors == 1 || floors == 0)
      return floors;

    // We need k trials for one egg and k floors 
    if (eggs == 1)
      return floors;
    
    //A 2D table where entery eggFloor[i][j] will represent minimum 
    //number of trials needed for i eggs and j floors. 
    int [][] eggFloor = new int[eggs + 1][floors + 1];
    int res;
    int i, j, x;

    // We need one trial for one floor and zero trials for zero floors 
    for (i = 1; i <= eggs; i++) {
      eggFloor[i][1] = 1;
      eggFloor[i][0] = 0;
    }

    // We always need j trials for one egg and j floors. 
    for (j = 1; j <= floors; j++)
      eggFloor[1][j] = j;

    // Fill rest of the entries in table using optimal substructure 
    // property 
    for (i = 2; i <= eggs; i++) {
      for (j = 2; j <= floors; j++) {
        eggFloor[i][j] = Integer.MAX_VALUE;
        for (x = 1; x <= j; x++) {
          res = 1 + Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);
          if (res < eggFloor[i][j])
            eggFloor[i][j] = res;
        }
      }
    }
    // eggFloor[n][k] holds the result 
    return eggFloor[eggs][floors];
  }
  
  public static void main(String args[]) 
  {
    int eggs = 2, floors = 10;
    System.out.println("With " + eggs + " eggs and " + floors + " floors, the minimum number of trials in worst are: " + eggDrop(eggs, floors));
  }
};
```
- Explanation :

In this solution, we again make use of a 2-D array, `lookupTable`, that stores the minimum number of tries needed for `i` eggs and `j` floors.

In this case, we build the solution bottom-up by dividing our problem into subproblems. We know that we only need one try for one floor and zero trials for zero floors, so we set these values in the `lookupTable` beforehand (lines 27-28).

Since we always need `j` trials for one egg and `j` floors, we set those values equal to `j` in the `lookupTable` (line 33).

We calculate the rest of the values using the optimal substructure property. The idea is that the number of tries needed is going to be the minimum number of tries needed if the egg broke at the current floor or if it didn‚Äôt (line 41). We consider the max of these two cases and choose the one that yields the minimum number of trials (lines 42-44).

- Time complexity :

The time complexity of this code is in O(eggs*floors^2).

**Solution #4: Using the Binomial Coefficient and Search Solution**

- Code:tada:
```java

class EggDropping {

 public static int binomialCoeff(int x, int n, int k) {
  int sum = 0, term = 1;
  for (int i = 1; i <= n && sum < k; ++i) {
   term *= x - i + 1;
   term /= i;
   sum += term;
  }
  return sum;
 }
 // Do binary search to find minimum number of trials in worst case. 
 public static int eggDrop(int eggs, int floors) {
  // If there are no eggs, then there can't be any tries
  if (eggs <= 0)
   return 0;

  // If there are no floors, then no trials needed. OR if there is one floor, one trial needed.
  if (floors == 1 || floors == 0)
   return floors;

  // We need k trials for one egg and k floors 
  if (eggs == 1)
   return floors;

  // Initialize low and high as 1st and last floors 
  int low = 1, high = floors;

  // Do binary search, for every mid, find sum of binomial coefficients and check if the sum is greater than k or not. 
  while (low < high) {
   int mid = (low + high) / 2;
   if (binomialCoeff(mid, eggs, floors) < floors)
    low = mid + 1;
   else
    high = mid;
  }
  return low;
 }

 public static void main(String args[]) {
  int eggs = 2, floors = 10;
  System.out.println("With " + eggs + " eggs and " + floors + " floors, the minimum number of trials in worst are: " + eggDrop(eggs, floors));
 }
};
```
This solution is not relevant to this chapter, but since it is the most optimized, we decided to mention it. This is the one that you would want to come up with in an actual interview.

- Time complexity :

The time complexity of this code is O(eggs*log(floors)).
... (rest of your README)
